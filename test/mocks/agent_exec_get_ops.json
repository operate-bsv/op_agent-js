{"data":[{"addr":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":607673,"t":1573078327},"conf":true,"fn":"--[[\nGenerates the specified number of unique random integers, between the given\nminimum and maximum range.\n\n## Examples\n\n    OP_FALSE OP_RETURN\n      $REF\n        \"6\"\n        \"1\"\n        \"59\"\n    # [3, 35, 49, 2, 5, 22]\n\n@version 0.1.1\n@author Libs\n]]--\nreturn function(state, n, min, max)\n  state = state or {}\n  local nums = {}\n  assert(\n    type(state) == 'table',\n    'Invalid state. Must receive a table.')\n  assert(\n    max - (min-1) >= tonumber(n),\n    'Invalid arguments. Insufficent range.')\n\n  -- Set the seed for the random generate based on the txid\n  local seed = tonumber(ctx.tx.txid, 16)\n  math.randomseed(seed)\n\n  -- Local helper method to generate unique random number\n  local function unique_random(nums, min, max)\n    local n = math.random(min, max)\n    if nums[n] then n = unique_random(nums, min, max) end\n    return n\n  end\n\n  -- Iterate from 1 to n, adding unique random numbers to the state\n  for i = 1, n do\n    local num = unique_random(nums, min, max)\n    nums[num] = num\n    table.insert(state, num)\n  end\n\n  return state\nend\n","hash":"b3d08d9eed26f880a948816e5e2728cea823204a9fadc674b64ad7c5a0f7cb33","i":1370,"meta":{"author":"Libs","version":"0.1.1"},"name":"math/rand_int","ref":"b3d08d9e","txid":"9f618e547285d9af7e071d388feba558070321f196dbb6b35e97385df66cb35e"},{"addr":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":604489,"t":1571181097},"conf":true,"fn":"--[[\nCreates a new object and places the state at the given path. The object is\nextended by placing the given values at the given keys unless the key already\nexists. Effectively the inverse of `object/put`.\n\nTakes a variable length number of arguments and maps them into key value pairs.\nWhere a key is a path seperated by `.`, the table is traversed creating a nested\ntable until the value is set on the tip.\n\n## Examples\n\n    OP_FALSE OP_RETURN\n      $REF\n        \"account\"\n        \"user.name\"\n        \"Joe Bloggs\"\n        \"user.age\"\n        20\n    # {\n    #   account: {...},\n    #   user: {\n    #     age: 20,\n    #     name: \"Joe Bloggs\"\n    #   }\n    # }\n\n@version 0.1.0\n@author Libs\n]]--\nreturn function(state, path, ...)\n  state = state or {}\n  local obj = {}\n  assert(\n    type(state) == 'table',\n    'Invalid state. Must receive a table.')\n  assert(\n    type(path) == 'string' and string.len(path) > 0,\n    'Invalid path. Must receive a string.')\n\n  -- Helper function to extend the given object with the path and value.\n  -- Splits the path into an array of keys and iterrates over each, either\n  -- extending the state object or setting the value on the tip, without\n  -- overwriting any existing value.\n  local function extend_new(state, path, value)\n    local keys = {}\n    string.gsub(path, '[^%.]+', function(k) table.insert(keys, k) end)\n    for i, k in ipairs(keys) do\n      if type(state) ~= 'table' then\n        break\n      elseif state[k] == nil then\n        if i == #keys then state[k] = value else state[k] = {} end\n      end\n      state = state[k]\n    end\n  end\n\n  -- Extend new object with state\n  extend_new(obj, path, state)\n\n  -- Iterrate over each vararg pair to get the path and value\n  -- Unless path is blank, the state is extended\n  for n = 1, select('#', ...) do\n    if math.fmod(n, 2) > 0 then\n      local path = select(n, ...)\n      local value = select(n+1, ...)\n      if path ~= nil and string.len(path) > 0 then\n        extend_new(obj, path, value)\n      end\n    end\n  end\n\n  return obj\nend","hash":"0ca59130e08741a0d54d808dd17aab2a205114767e9959f6da08cc163841499c","i":37,"meta":{"author":"Libs","version":"0.1.0"},"name":"object/put_new","ref":"0ca59130","txid":"b7925d4c1e1b9a6222139c0293ef8c93a8dc320810f82745c9c66cafb8e3e6b1"}]}