{"data":[{"addr":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":609384,"t":1574118733},"conf":true,"fn":"--[[\nImplements the [Author Idendity Protocol](https://github.com/BitcoinFiles/AUTHOR_IDENTITY_PROTOCOL).\n\nAn `_AIP` attribute is added to the state containing a table of AIP signatures,\nallowing multiple signatures to be appended to the state. Each AIP object\ncontains the protocol paramaters, plus a `verified` boolean attribute.\n\n## Examples\n\n    OP_FALSE OP_RETURN\n      \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\"\n        \"Hello world!\"\n        \"text/plain\"\n        \"utf8\"\n        0\n        |\n      $REF\n        \"BITCOIN_ECDSA\"\n        \"1EXhSbGFiEAZCE5eeBvUxT6cBVHhrpPWXz\"\n        \"HKzuHb43Xj4XpmK1YJROD/eN/58ZR0T7LuRi2QW8eFcnQg1d7tSy3QGQI/VQr09PeTQFAXniFyIFkqQYgvAlHvQ=\"\n    # {\n    #   _AIP: [\n    #     {\n    #       algo: \"BITCOIN_ECDSA\",\n    #       address: \"1EXhSbGFiEAZCE5eeBvUxT6cBVHhrpPWXz\",\n    #       indices: [],\n    #       signature: \"HKzuHb43Xj4XpmK1YJROD/eN/58ZR0T7LuRi2QW8eFcnQg1d7tSy3QGQI/VQr09PeTQFAXniFyIFkqQYgvAlHvQ=\",\n    #       verified: true\n    #     }\n    #   ],\n    #   data: \"Hello world\",\n    #   encoding: \"utf8\",\n    #   name: null,\n    #   type: \"text/plain\",\n    # }\n\n@version 0.1.2\n@author Libs\n]]--\nreturn function(state, algo, address, signature, ...)\n  state = state or {}\n  local algo = string.upper(algo or '')\n  local indices = {}\n  local message = ''\n\n  assert(\n    type(state) == 'table',\n    'Invalid state type.')\n  assert(\n    algo == 'BITCOIN_ECDSA',\n    'Invalid signature algorithm. Must be BITCOIN_ECDSA.')\n\n  -- Define AIP object\n  local aip = {\n    algo = algo,\n    address = address,\n    signature = signature,\n    verified = false\n  }\n\n  -- If no indices provided, assume all fields prior to current global index\n  -- Otherwise, get fields by index as specified\n  if next({...}) == nil then\n    local max = ctx.data_index or 0\n    for idx = 0, max-1 do\n      table.insert(indices, idx)\n    end\n    aip.indices = {}\n  else\n    for k, idx in ipairs({...}) do\n      -- Indices can be encoded as strings or unsigned integers\n      if string.match(idx, '^%d+$')\n        then idx = tonumber(idx)\n        else idx = string.byte(idx)\n      end\n      table.insert(indices, idx)\n    end\n    aip.indices = indices\n  end\n\n  -- Get tape data, then iterate over indeces to build message for verification\n  local tape = ctx.get_tape()\n  if tape ~= nil then\n    for k, idx in ipairs(indices) do\n      local data = tape[idx + 1]\n      message = message .. data.b\n    end\n    aip.verified = crypto.bitcoin_message.verify(signature, message, address, {encoding = 'binary'})\n  end\n\n  -- Add signature to table, allowing multiple signature adding to same state\n  state['_AIP'] = state['_AIP'] or {}\n  table.insert(state['_AIP'], aip)\n\n  return state\nend","hash":"a3a83843f3d4eba4a8c3d3d0a9303a4987c465261a4b6094fda6f18e391805a8","i":3681,"meta":{"author":"Libs","version":"0.1.2"},"name":"bitcom/aip","ref":"a3a83843","txid":"240247d706f0481041616cb6773858db9b4ea6e1a2de172715aef6f2aba80d29"},{"addr":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":604488,"t":1571180396},"conf":true,"fn":"--[[\nImplements the B:// protocal and creates a file object using the given\nparameters.\n\n## Examples\n\n    OP_FALSE OP_RETURN\n      $REF\n        \"Hello world\"\n        \"text/plain\"\n        \"utf8\"\n        \"example.txt\"\n    # {\n    #   data: \"Hello world\",\n    #   encoding: \"utf8\",\n    #   name: \"example.txt\"\n    #   type: \"text/plain\",\n    # }\n\n@version 0.1.0\n@author Libs\n]]--\nreturn function(state, data, mediatype, encoding, name)\n  local file = state or {}\n  assert(\n    type(file) == 'table',\n    'Invalid state. Must receive a table.')\n\n  -- Local helper method to determine if a string is blank\n  local function isblank(str)\n    return str == nil or str == ''\n  end\n\n  assert(\n    not isblank(data),\n    'Invalid file parameters.')\n\n  -- Build the file object\n  file.data = data\n  file.type = mediatype\n  file.encoding = encoding\n  file.name = name\n\n  -- Nullify blank attributes\n  if isblank(file.type) then file.type = nil end\n  if isblank(file.name) then file.name = nil end\n  if isblank(file.encoding) then\n    -- Default text files to utf8 encoding\n    if not isblank(file.type) and string.match(file.type, '^text%/') then\n      file.encoding = 'utf8'\n    else\n      file.encoding = nil\n    end\n  end\n\n  return file\nend","hash":"6232de0444a6eb50ead6b3a9649df35ef72d80b5f0d487bb185ad0b65a1ecd1f","i":67,"meta":{"author":"Libs","version":"0.1.0"},"name":"bitcom/b","ref":"6232de04","txid":"bdd79d0275e37b8dbf333df9527b0837b784a5585a4f0657aa849613f0b9e31b"},{"addr":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":604488,"t":1571180396},"conf":true,"fn":"--[[\nImplements the Magic Attribute Protocol. Depending on the given mode, the\nstate is either extended with the given values at the given keys (overriding\nvalues where keys already exist), or the given keys are deleted from the state.\n\nIn addition a `_MAP` attribute is attached to the state listing the mapping\nchanges.\n\n## Examples\n\n    OP_FALSE OP_RETURN\n      $REF\n        \"SET\"\n        \"user.name\"\n        \"Joe Bloggs\"\n        \"user.age\"\n        20\n    # {\n    #   user: {\n    #     age: 20,\n    #     name: \"Joe Bloggs\"\n    #   },\n    #   _MAP: {\n    #     PUT: {\n    #       \"user.age\": 20,\n    #       \"user.name\": \"Joe Bloggs\"\n    #     }\n    #   }\n    # }\n\n@version 0.1.0\n@author Libs\n]]--\nreturn function(state, mode, ...)\n  state = state or {}\n  local obj = {}\n  local mode = string.upper(mode or '')\n  assert(\n    type(state) == 'table',\n    'Invalid state type.')\n  assert(\n    mode == 'SET' or mode == 'DELETE',\n    'Invalid MAP mode. Must be SET or DELETE.')\n\n  -- Helper function to extend the given object with the path and value.\n  -- Splits the path into an array of keys and iterrates over each, either\n  -- extending the state object or setting the value on the tip.\n  local function extend(state, path, value)\n    local keys = {}\n    string.gsub(path, '[^%.]+', function(k) table.insert(keys, k) end)\n    for i, k in ipairs(keys) do\n      if i == #keys then\n        state[k] = value\n      elseif type(state[k]) ~= 'table' then\n        state[k] = {}\n      end\n      state = state[k]\n    end\n  end\n\n  -- Helper function to drop the path from the given object.\n  -- Splits the path into an array of keys and traverses the state object\n  -- until it nullifies the tip.\n  local function drop(state, path)\n    local keys = {}\n    string.gsub(path, '[^%.]+', function(k) table.insert(keys, k) end)\n    for i, k in ipairs(keys) do\n      if type(state) ~= 'table' then\n        break\n      elseif state[k] ~= nil then\n        if i == #keys then state[k] = nil end\n      end\n      state = state[k]\n    end\n  end\n\n  if mode == 'SET' then\n    -- Iterrate over each vararg pair to get the path and value\n    -- Unless path is blank, the state is extended\n    for n = 1, select('#', ...) do\n      if math.fmod(n, 2) > 0 then\n        local path = select(n, ...)\n        local value = select(n+1, ...)\n        \n        if path ~= nil and string.len(path) > 0 then\n          obj[path] = value\n          extend(state, path, value)\n        end\n      end\n    end\n  elseif mode == 'DELETE' then\n    -- Iterrate over each vararg and drop from the state\n    for i, path in ipairs({...}) do\n      table.insert(obj, path)\n      drop(state, path)\n    end\n  end\n  \n  -- Attach mapping to state\n  state['_MAP'] = {}\n  state['_MAP'][mode] = obj\n\n  return state\nend","hash":"1fec30d4912449053b7717b290a2707d62fa786d8c1400a30f4ea8e0bc876d21","i":68,"meta":{"author":"Libs","version":"0.1.0"},"name":"bitcom/map","ref":"1fec30d4","txid":"0ae2b05f25db7eef0629360cef71ed2172f2ca65faf3dbc228a4c15a473c5f26"}]}