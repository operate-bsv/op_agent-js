/*!
 * Operate / Agent - v0.1.0-beta.1
 * Operate JavaScript agent used to load and run Bitcoin programs.
 * github.com:operate-bsv/op_agent-js
 * Copyright Â© 2020 Chronos Labs Ltd. MIT License.
 * @preserve
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("crypto"), require("window"));
	else if(typeof define === 'function' && define.amd)
		define(["crypto", "window"], factory);
	else if(typeof exports === 'object')
		exports["Operate"] = factory(require("crypto"), require("window"));
	else
		root["Operate"] = factory(root["crypto"], root["window"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__19__, __WEBPACK_EXTERNAL_MODULE__47__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 49);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {// cspell: ignore accum, contramap, promap


function Parsimmon(action) {
  if (!(this instanceof Parsimmon)) {
    return new Parsimmon(action);
  }

  this._ = action;
}

var _ = Parsimmon.prototype;

function times(n, f) {
  var i = 0;

  for (i; i < n; i++) {
    f(i);
  }
}

function forEach(f, arr) {
  times(arr.length, function (i) {
    f(arr[i], i, arr);
  });
}

function reduce(f, seed, arr) {
  forEach(function (elem, i, arr) {
    seed = f(seed, elem, i, arr);
  }, arr);
  return seed;
}

function map(f, arr) {
  return reduce(function (acc, elem, i, a) {
    return acc.concat([f(elem, i, a)]);
  }, [], arr);
}

function lshiftBuffer(input) {
  var asTwoBytes = reduce(function (a, v, i, b) {
    return a.concat(i === b.length - 1 ? Buffer.from([v, 0]).readUInt16BE(0) : b.readUInt16BE(i));
  }, [], input);
  return Buffer.from(map(function (x) {
    return (x << 1 & 0xffff) >> 8;
  }, asTwoBytes));
}

function consumeBitsFromBuffer(n, input) {
  var state = {
    v: 0,
    buf: input
  };
  times(n, function () {
    state = {
      v: state.v << 1 | bitPeekBuffer(state.buf),
      buf: lshiftBuffer(state.buf)
    };
  });
  return state;
}

function bitPeekBuffer(input) {
  return input[0] >> 7;
}

function sum(numArr) {
  return reduce(function (x, y) {
    return x + y;
  }, 0, numArr);
}

function find(pred, arr) {
  return reduce(function (found, elem) {
    return found || (pred(elem) ? elem : found);
  }, null, arr);
}

function bufferExists() {
  return typeof Buffer !== 'undefined';
}

function ensureBuffer() {
  if (!bufferExists()) {
    throw new Error('Buffer global does not exist; please consider using https://github.com/feross/buffer if you are running Parsimmon in a browser.');
  }
}

function bitSeq(alignments) {
  ensureBuffer();
  var totalBits = sum(alignments);

  if (totalBits % 8 !== 0) {
    throw new Error('The bits [' + alignments.join(', ') + '] add up to ' + totalBits + ' which is not an even number of bytes; the total should be divisible by 8');
  }

  var bytes = totalBits / 8;
  var tooBigRange = find(function (x) {
    return x > 48;
  }, alignments);

  if (tooBigRange) {
    throw new Error(tooBigRange + ' bit range requested exceeds 48 bit (6 byte) Number max.');
  }

  return new Parsimmon(function (input, i) {
    var newPos = bytes + i;

    if (newPos > input.length) {
      return makeFailure(i, bytes.toString() + ' bytes');
    }

    return makeSuccess(newPos, reduce(function (acc, bits) {
      var state = consumeBitsFromBuffer(bits, acc.buf);
      return {
        coll: acc.coll.concat(state.v),
        buf: state.buf
      };
    }, {
      coll: [],
      buf: input.slice(i, newPos)
    }, alignments).coll);
  });
}

function bitSeqObj(namedAlignments) {
  ensureBuffer();
  var seenKeys = {};
  var totalKeys = 0;
  var fullAlignments = map(function (item) {
    if (isArray(item)) {
      var pair = item;

      if (pair.length !== 2) {
        throw new Error('[' + pair.join(', ') + '] should be length 2, got length ' + pair.length);
      }

      assertString(pair[0]);
      assertNumber(pair[1]);

      if (Object.prototype.hasOwnProperty.call(seenKeys, pair[0])) {
        throw new Error('duplicate key in bitSeqObj: ' + pair[0]);
      }

      seenKeys[pair[0]] = true;
      totalKeys++;
      return pair;
    } else {
      assertNumber(item);
      return [null, item];
    }
  }, namedAlignments);

  if (totalKeys < 1) {
    throw new Error('bitSeqObj expects at least one named pair, got [' + namedAlignments.join(', ') + ']');
  }

  var namesOnly = map(function (pair) {
    return pair[0];
  }, fullAlignments);
  var alignmentsOnly = map(function (pair) {
    return pair[1];
  }, fullAlignments);
  return bitSeq(alignmentsOnly).map(function (parsed) {
    var namedParsed = map(function (name, i) {
      return [name, parsed[i]];
    }, namesOnly);
    return reduce(function (obj, kv) {
      if (kv[0] !== null) {
        obj[kv[0]] = kv[1];
      }

      return obj;
    }, {}, namedParsed);
  });
}

function parseBufferFor(other, length) {
  ensureBuffer();
  return new Parsimmon(function (input, i) {
    if (i + length > input.length) {
      return makeFailure(i, length + ' bytes for ' + other);
    }

    return makeSuccess(i + length, input.slice(i, i + length));
  });
}

function parseBuffer(length) {
  return parseBufferFor('buffer', length).map(function (unsafe) {
    return Buffer.from(unsafe);
  });
}

function encodedString(encoding, length) {
  return parseBufferFor('string', length).map(function (buff) {
    return buff.toString(encoding);
  });
}

function isInteger(value) {
  return typeof value === 'number' && Math.floor(value) === value;
}

function assertValidIntegerByteLengthFor(who, length) {
  if (!isInteger(length) || length < 0 || length > 6) {
    throw new Error(who + ' requires integer length in range [0, 6].');
  }
}

function uintBE(length) {
  assertValidIntegerByteLengthFor('uintBE', length);
  return parseBufferFor('uintBE(' + length + ')', length).map(function (buff) {
    return buff.readUIntBE(0, length);
  });
}

function uintLE(length) {
  assertValidIntegerByteLengthFor('uintLE', length);
  return parseBufferFor('uintLE(' + length + ')', length).map(function (buff) {
    return buff.readUIntLE(0, length);
  });
}

function intBE(length) {
  assertValidIntegerByteLengthFor('intBE', length);
  return parseBufferFor('intBE(' + length + ')', length).map(function (buff) {
    return buff.readIntBE(0, length);
  });
}

function intLE(length) {
  assertValidIntegerByteLengthFor('intLE', length);
  return parseBufferFor('intLE(' + length + ')', length).map(function (buff) {
    return buff.readIntLE(0, length);
  });
}

function floatBE() {
  return parseBufferFor('floatBE', 4).map(function (buff) {
    return buff.readFloatBE(0);
  });
}

function floatLE() {
  return parseBufferFor('floatLE', 4).map(function (buff) {
    return buff.readFloatLE(0);
  });
}

function doubleBE() {
  return parseBufferFor('doubleBE', 8).map(function (buff) {
    return buff.readDoubleBE(0);
  });
}

function doubleLE() {
  return parseBufferFor('doubleLE', 8).map(function (buff) {
    return buff.readDoubleLE(0);
  });
}

function toArray(arrLike) {
  return Array.prototype.slice.call(arrLike);
} // -*- Helpers -*-


function isParser(obj) {
  return obj instanceof Parsimmon;
}

function isArray(x) {
  return {}.toString.call(x) === '[object Array]';
}

function isBuffer(x) {
  /* global Buffer */
  return bufferExists() && Buffer.isBuffer(x);
}

function makeSuccess(index, value) {
  return {
    status: true,
    index: index,
    value: value,
    furthest: -1,
    expected: []
  };
}

function makeFailure(index, expected) {
  if (!isArray(expected)) {
    expected = [expected];
  }

  return {
    status: false,
    index: -1,
    value: null,
    furthest: index,
    expected: expected
  };
}

function mergeReplies(result, last) {
  if (!last) {
    return result;
  }

  if (result.furthest > last.furthest) {
    return result;
  }

  var expected = result.furthest === last.furthest ? union(result.expected, last.expected) : last.expected;
  return {
    status: result.status,
    index: result.index,
    value: result.value,
    furthest: last.furthest,
    expected: expected
  };
}

function makeLineColumnIndex(input, i) {
  if (isBuffer(input)) {
    return {
      offset: i,
      line: -1,
      column: -1
    };
  }

  var lines = input.slice(0, i).split('\n'); // Note that unlike the character offset, the line and column offsets are
  // 1-based.

  var lineWeAreUpTo = lines.length;
  var columnWeAreUpTo = lines[lines.length - 1].length + 1;
  return {
    offset: i,
    line: lineWeAreUpTo,
    column: columnWeAreUpTo
  };
} // Returns the sorted set union of two arrays of strings


function union(xs, ys) {
  var obj = {};

  for (var i = 0; i < xs.length; i++) {
    obj[xs[i]] = true;
  }

  for (var j = 0; j < ys.length; j++) {
    obj[ys[j]] = true;
  }

  var keys = [];

  for (var k in obj) {
    if ({}.hasOwnProperty.call(obj, k)) {
      keys.push(k);
    }
  }

  keys.sort();
  return keys;
}

function assertParser(p) {
  if (!isParser(p)) {
    throw new Error('not a parser: ' + p);
  }
}

function get(input, i) {
  if (typeof input === 'string') {
    return input.charAt(i);
  }

  return input[i];
} // TODO[ES5]: Switch to Array.isArray eventually.


function assertArray(x) {
  if (!isArray(x)) {
    throw new Error('not an array: ' + x);
  }
}

function assertNumber(x) {
  if (typeof x !== 'number') {
    throw new Error('not a number: ' + x);
  }
}

function assertRegexp(x) {
  if (!(x instanceof RegExp)) {
    throw new Error('not a regexp: ' + x);
  }

  var f = flags(x);

  for (var i = 0; i < f.length; i++) {
    var c = f.charAt(i); // Only allow regexp flags [imu] for now, since [g] and [y] specifically
    // mess up Parsimmon. If more non-stateful regexp flags are added in the
    // future, this will need to be revisited.

    if (c !== 'i' && c !== 'm' && c !== 'u') {
      throw new Error('unsupported regexp flag "' + c + '": ' + x);
    }
  }
}

function assertFunction(x) {
  if (typeof x !== 'function') {
    throw new Error('not a function: ' + x);
  }
}

function assertString(x) {
  if (typeof x !== 'string') {
    throw new Error('not a string: ' + x);
  }
} // -*- Error Formatting -*-


var linesBeforeStringError = 2;
var linesAfterStringError = 3;
var bytesPerLine = 8;
var bytesBefore = bytesPerLine * 5;
var bytesAfter = bytesPerLine * 4;
var defaultLinePrefix = '  ';

function repeat(string, amount) {
  return new Array(amount + 1).join(string);
}

function formatExpected(expected) {
  if (expected.length === 1) {
    return 'Expected:\n\n' + expected[0];
  }

  return 'Expected one of the following: \n\n' + expected.join(', ');
}

function leftPad(str, pad, char) {
  var add = pad - str.length;

  if (add <= 0) {
    return str;
  }

  return repeat(char, add) + str;
}

function toChunks(arr, chunkSize) {
  var length = arr.length;
  var chunks = [];
  var chunkIndex = 0;

  if (length <= chunkSize) {
    return [arr.slice()];
  }

  for (var i = 0; i < length; i++) {
    if (!chunks[chunkIndex]) {
      chunks.push([]);
    }

    chunks[chunkIndex].push(arr[i]);

    if ((i + 1) % chunkSize === 0) {
      chunkIndex++;
    }
  }

  return chunks;
} // Get a range of indexes including `i`-th element and `before` and `after` amount of elements from `arr`.


function rangeFromIndexAndOffsets(i, before, after, length) {
  return {
    // Guard against the negative upper bound for lines included in the output.
    from: i - before > 0 ? i - before : 0,
    to: i + after > length ? length : i + after
  };
}

function byteRangeToRange(byteRange) {
  // Exception for inputs smaller than `bytesPerLine`
  if (byteRange.from === 0 && byteRange.to === 1) {
    return {
      from: byteRange.from,
      to: byteRange.to
    };
  }

  return {
    from: byteRange.from / bytesPerLine,
    // Round `to`, so we don't get float if the amount of bytes is not divisible by `bytesPerLine`
    to: Math.floor(byteRange.to / bytesPerLine)
  };
}

function formatGot(input, error) {
  var index = error.index;
  var i = index.offset;
  var verticalMarkerLength = 1;
  var column;
  var lineWithErrorIndex;
  var lines;
  var lineRange;
  var lastLineNumberLabelLength;

  if (i === input.length) {
    return 'Got the end of the input';
  }

  if (isBuffer(input)) {
    var byteLineWithErrorIndex = i - i % bytesPerLine;
    var columnByteIndex = i - byteLineWithErrorIndex;
    var byteRange = rangeFromIndexAndOffsets(byteLineWithErrorIndex, bytesBefore, bytesAfter + bytesPerLine, input.length);
    var bytes = input.slice(byteRange.from, byteRange.to);
    var bytesInChunks = toChunks(bytes.toJSON().data, bytesPerLine);
    var byteLines = map(function (byteRow) {
      return map(function (byteValue) {
        // Prefix byte values with a `0` if they are shorter than 2 characters.
        return leftPad(byteValue.toString(16), 2, '0');
      }, byteRow);
    }, bytesInChunks);
    lineRange = byteRangeToRange(byteRange);
    lineWithErrorIndex = byteLineWithErrorIndex / bytesPerLine;
    column = columnByteIndex * 3; // Account for an extra space.

    if (columnByteIndex >= 4) {
      column += 1;
    }

    verticalMarkerLength = 2;
    lines = map(function (byteLine) {
      return byteLine.length <= 4 ? byteLine.join(' ') : byteLine.slice(0, 4).join(' ') + '  ' + byteLine.slice(4).join(' ');
    }, byteLines);
    lastLineNumberLabelLength = ((lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8).toString(16).length;

    if (lastLineNumberLabelLength < 2) {
      lastLineNumberLabelLength = 2;
    }
  } else {
    var inputLines = input.split(/\r\n|[\n\r\u2028\u2029]/);
    column = index.column - 1;
    lineWithErrorIndex = index.line - 1;
    lineRange = rangeFromIndexAndOffsets(lineWithErrorIndex, linesBeforeStringError, linesAfterStringError, inputLines.length);
    lines = inputLines.slice(lineRange.from, lineRange.to);
    lastLineNumberLabelLength = lineRange.to.toString().length;
  }

  var lineWithErrorCurrentIndex = lineWithErrorIndex - lineRange.from;

  if (isBuffer(input)) {
    lastLineNumberLabelLength = ((lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8).toString(16).length;

    if (lastLineNumberLabelLength < 2) {
      lastLineNumberLabelLength = 2;
    }
  }

  var linesWithLineNumbers = reduce(function (acc, lineSource, index) {
    var isLineWithError = index === lineWithErrorCurrentIndex;
    var prefix = isLineWithError ? '> ' : defaultLinePrefix;
    var lineNumberLabel;

    if (isBuffer(input)) {
      lineNumberLabel = leftPad(((lineRange.from + index) * 8).toString(16), lastLineNumberLabelLength, '0');
    } else {
      lineNumberLabel = leftPad((lineRange.from + index + 1).toString(), lastLineNumberLabelLength, ' ');
    }

    return [].concat(acc, [prefix + lineNumberLabel + ' | ' + lineSource], isLineWithError ? [defaultLinePrefix + repeat(' ', lastLineNumberLabelLength) + ' | ' + leftPad('', column, ' ') + repeat('^', verticalMarkerLength)] : []);
  }, [], lines);
  return linesWithLineNumbers.join('\n');
}

function formatError(input, error) {
  return ['\n', '-- PARSING FAILED ' + repeat('-', 50), '\n\n', formatGot(input, error), '\n\n', formatExpected(error.expected), '\n'].join('');
}

function flags(re) {
  var s = '' + re;
  return s.slice(s.lastIndexOf('/') + 1);
}

function anchoredRegexp(re) {
  return RegExp('^(?:' + re.source + ')', flags(re));
} // -*- Combinators -*-


function seq() {
  var parsers = [].slice.call(arguments);
  var numParsers = parsers.length;

  for (var j = 0; j < numParsers; j += 1) {
    assertParser(parsers[j]);
  }

  return Parsimmon(function (input, i) {
    var result;
    var accum = new Array(numParsers);

    for (var j = 0; j < numParsers; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);

      if (!result.status) {
        return result;
      }

      accum[j] = result.value;
      i = result.index;
    }

    return mergeReplies(makeSuccess(i, accum), result);
  });
}

function seqObj() {
  var seenKeys = {};
  var totalKeys = 0;
  var parsers = toArray(arguments);
  var numParsers = parsers.length;

  for (var j = 0; j < numParsers; j += 1) {
    var p = parsers[j];

    if (isParser(p)) {
      continue;
    }

    if (isArray(p)) {
      var isWellFormed = p.length === 2 && typeof p[0] === 'string' && isParser(p[1]);

      if (isWellFormed) {
        var key = p[0];

        if (Object.prototype.hasOwnProperty.call(seenKeys, key)) {
          throw new Error('seqObj: duplicate key ' + key);
        }

        seenKeys[key] = true;
        totalKeys++;
        continue;
      }
    }

    throw new Error('seqObj arguments must be parsers or [string, parser] array pairs.');
  }

  if (totalKeys === 0) {
    throw new Error('seqObj expects at least one named parser, found zero');
  }

  return Parsimmon(function (input, i) {
    var result;
    var accum = {};

    for (var j = 0; j < numParsers; j += 1) {
      var name;
      var parser;

      if (isArray(parsers[j])) {
        name = parsers[j][0];
        parser = parsers[j][1];
      } else {
        name = null;
        parser = parsers[j];
      }

      result = mergeReplies(parser._(input, i), result);

      if (!result.status) {
        return result;
      }

      if (name) {
        accum[name] = result.value;
      }

      i = result.index;
    }

    return mergeReplies(makeSuccess(i, accum), result);
  });
}

function seqMap() {
  var args = [].slice.call(arguments);

  if (args.length === 0) {
    throw new Error('seqMap needs at least one argument');
  }

  var mapper = args.pop();
  assertFunction(mapper);
  return seq.apply(null, args).map(function (results) {
    return mapper.apply(null, results);
  });
} // TODO[ES5]: Revisit this with Object.keys and .bind.


function createLanguage(parsers) {
  var language = {};

  for (var key in parsers) {
    if ({}.hasOwnProperty.call(parsers, key)) {
      (function (key) {
        var func = function () {
          return parsers[key](language);
        };

        language[key] = lazy(func);
      })(key);
    }
  }

  return language;
}

function alt() {
  var parsers = [].slice.call(arguments);
  var numParsers = parsers.length;

  if (numParsers === 0) {
    return fail('zero alternates');
  }

  for (var j = 0; j < numParsers; j += 1) {
    assertParser(parsers[j]);
  }

  return Parsimmon(function (input, i) {
    var result;

    for (var j = 0; j < parsers.length; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);

      if (result.status) {
        return result;
      }
    }

    return result;
  });
}

function sepBy(parser, separator) {
  // Argument asserted by sepBy1
  return sepBy1(parser, separator).or(succeed([]));
}

function sepBy1(parser, separator) {
  assertParser(parser);
  assertParser(separator);
  var pairs = separator.then(parser).many();
  return seqMap(parser, pairs, function (r, rs) {
    return [r].concat(rs);
  });
} // -*- Core Parsing Methods -*-


_.parse = function (input) {
  if (typeof input !== 'string' && !isBuffer(input)) {
    throw new Error('.parse must be called with a string or Buffer as its argument');
  }

  var result = this.skip(eof)._(input, 0);

  if (result.status) {
    return {
      status: true,
      value: result.value
    };
  }

  return {
    status: false,
    index: makeLineColumnIndex(input, result.furthest),
    expected: result.expected
  };
}; // -*- Other Methods -*-


_.tryParse = function (str) {
  var result = this.parse(str);

  if (result.status) {
    return result.value;
  } else {
    var msg = formatError(str, result);
    var err = new Error(msg);
    err.type = 'ParsimmonError';
    err.result = result;
    throw err;
  }
};

_.or = function (alternative) {
  return alt(this, alternative);
};

_.trim = function (parser) {
  return this.wrap(parser, parser);
};

_.wrap = function (leftParser, rightParser) {
  return seqMap(leftParser, this, rightParser, function (left, middle) {
    return middle;
  });
};

_.thru = function (wrapper) {
  return wrapper(this);
};

_.then = function (next) {
  assertParser(next);
  return seq(this, next).map(function (results) {
    return results[1];
  });
};

_.many = function () {
  var self = this;
  return Parsimmon(function (input, i) {
    var accum = [];
    var result = undefined;

    for (;;) {
      result = mergeReplies(self._(input, i), result);

      if (result.status) {
        if (i === result.index) {
          throw new Error('infinite loop detected in .many() parser --- calling .many() on ' + 'a parser which can accept zero characters is usually the cause');
        }

        i = result.index;
        accum.push(result.value);
      } else {
        return mergeReplies(makeSuccess(i, accum), result);
      }
    }
  });
};

_.tieWith = function (separator) {
  assertString(separator);
  return this.map(function (args) {
    assertArray(args);

    if (args.length) {
      assertString(args[0]);
      var s = args[0];

      for (var i = 1; i < args.length; i++) {
        assertString(args[i]);
        s += separator + args[i];
      }

      return s;
    } else {
      return '';
    }
  });
};

_.tie = function () {
  return this.tieWith('');
};

_.times = function (min, max) {
  var self = this;

  if (arguments.length < 2) {
    max = min;
  }

  assertNumber(min);
  assertNumber(max);
  return Parsimmon(function (input, i) {
    var accum = [];
    var result = undefined;
    var prevResult = undefined;

    for (var times = 0; times < min; times += 1) {
      result = self._(input, i);
      prevResult = mergeReplies(result, prevResult);

      if (result.status) {
        i = result.index;
        accum.push(result.value);
      } else {
        return prevResult;
      }
    }

    for (; times < max; times += 1) {
      result = self._(input, i);
      prevResult = mergeReplies(result, prevResult);

      if (result.status) {
        i = result.index;
        accum.push(result.value);
      } else {
        break;
      }
    }

    return mergeReplies(makeSuccess(i, accum), prevResult);
  });
};

_.result = function (res) {
  return this.map(function () {
    return res;
  });
};

_.atMost = function (n) {
  return this.times(0, n);
};

_.atLeast = function (n) {
  return seqMap(this.times(n), this.many(), function (init, rest) {
    return init.concat(rest);
  });
};

_.map = function (fn) {
  assertFunction(fn);
  var self = this;
  return Parsimmon(function (input, i) {
    var result = self._(input, i);

    if (!result.status) {
      return result;
    }

    return mergeReplies(makeSuccess(result.index, fn(result.value)), result);
  });
};

_.contramap = function (fn) {
  assertFunction(fn);
  var self = this;
  return Parsimmon(function (input, i) {
    var result = self.parse(fn(input.slice(i)));

    if (!result.status) {
      return result;
    }

    return makeSuccess(i + input.length, result.value);
  });
};

_.promap = function (f, g) {
  assertFunction(f);
  assertFunction(g);
  return this.contramap(f).map(g);
};

_.skip = function (next) {
  return seq(this, next).map(function (results) {
    return results[0];
  });
};

_.mark = function () {
  return seqMap(index, this, index, function (start, value, end) {
    return {
      start: start,
      value: value,
      end: end
    };
  });
};

_.node = function (name) {
  return seqMap(index, this, index, function (start, value, end) {
    return {
      name: name,
      value: value,
      start: start,
      end: end
    };
  });
};

_.sepBy = function (separator) {
  return sepBy(this, separator);
};

_.sepBy1 = function (separator) {
  return sepBy1(this, separator);
};

_.lookahead = function (x) {
  return this.skip(lookahead(x));
};

_.notFollowedBy = function (x) {
  return this.skip(notFollowedBy(x));
};

_.desc = function (expected) {
  if (!isArray(expected)) {
    expected = [expected];
  }

  var self = this;
  return Parsimmon(function (input, i) {
    var reply = self._(input, i);

    if (!reply.status) {
      reply.expected = expected;
    }

    return reply;
  });
};

_.fallback = function (result) {
  return this.or(succeed(result));
};

_.ap = function (other) {
  return seqMap(other, this, function (f, x) {
    return f(x);
  });
};

_.chain = function (f) {
  var self = this;
  return Parsimmon(function (input, i) {
    var result = self._(input, i);

    if (!result.status) {
      return result;
    }

    var nextParser = f(result.value);
    return mergeReplies(nextParser._(input, result.index), result);
  });
}; // -*- Constructors -*-


function string(str) {
  assertString(str);
  var expected = "'" + str + "'";
  return Parsimmon(function (input, i) {
    var j = i + str.length;
    var head = input.slice(i, j);

    if (head === str) {
      return makeSuccess(j, head);
    } else {
      return makeFailure(i, expected);
    }
  });
}

function byte(b) {
  ensureBuffer();
  assertNumber(b);

  if (b > 0xff) {
    throw new Error('Value specified to byte constructor (' + b + '=0x' + b.toString(16) + ') is larger in value than a single byte.');
  }

  var expected = (b > 0xf ? '0x' : '0x0') + b.toString(16);
  return Parsimmon(function (input, i) {
    var head = get(input, i);

    if (head === b) {
      return makeSuccess(i + 1, head);
    } else {
      return makeFailure(i, expected);
    }
  });
}

function regexp(re, group) {
  assertRegexp(re);

  if (arguments.length >= 2) {
    assertNumber(group);
  } else {
    group = 0;
  }

  var anchored = anchoredRegexp(re);
  var expected = '' + re;
  return Parsimmon(function (input, i) {
    var match = anchored.exec(input.slice(i));

    if (match) {
      if (0 <= group && group <= match.length) {
        var fullMatch = match[0];
        var groupMatch = match[group];
        return makeSuccess(i + fullMatch.length, groupMatch);
      }

      var message = 'valid match group (0 to ' + match.length + ') in ' + expected;
      return makeFailure(i, message);
    }

    return makeFailure(i, expected);
  });
}

function succeed(value) {
  return Parsimmon(function (input, i) {
    return makeSuccess(i, value);
  });
}

function fail(expected) {
  return Parsimmon(function (input, i) {
    return makeFailure(i, expected);
  });
}

function lookahead(x) {
  if (isParser(x)) {
    return Parsimmon(function (input, i) {
      var result = x._(input, i);

      result.index = i;
      result.value = '';
      return result;
    });
  } else if (typeof x === 'string') {
    return lookahead(string(x));
  } else if (x instanceof RegExp) {
    return lookahead(regexp(x));
  }

  throw new Error('not a string, regexp, or parser: ' + x);
}

function notFollowedBy(parser) {
  assertParser(parser);
  return Parsimmon(function (input, i) {
    var result = parser._(input, i);

    var text = input.slice(i, result.index);
    return result.status ? makeFailure(i, 'not "' + text + '"') : makeSuccess(i, null);
  });
}

function test(predicate) {
  assertFunction(predicate);
  return Parsimmon(function (input, i) {
    var char = get(input, i);

    if (i < input.length && predicate(char)) {
      return makeSuccess(i + 1, char);
    } else {
      return makeFailure(i, 'a character/byte matching ' + predicate);
    }
  });
}

function oneOf(str) {
  var expected = str.split('');

  for (var idx = 0; idx < expected.length; idx++) {
    expected[idx] = "'" + expected[idx] + "'";
  }

  return test(function (ch) {
    return str.indexOf(ch) >= 0;
  }).desc(expected);
}

function noneOf(str) {
  return test(function (ch) {
    return str.indexOf(ch) < 0;
  }).desc("none of '" + str + "'");
}

function custom(parsingFunction) {
  return Parsimmon(parsingFunction(makeSuccess, makeFailure));
} // TODO[ES5]: Improve error message using JSON.stringify eventually.


function range(begin, end) {
  return test(function (ch) {
    return begin <= ch && ch <= end;
  }).desc(begin + '-' + end);
}

function takeWhile(predicate) {
  assertFunction(predicate);
  return Parsimmon(function (input, i) {
    var j = i;

    while (j < input.length && predicate(get(input, j))) {
      j++;
    }

    return makeSuccess(j, input.slice(i, j));
  });
}

function lazy(desc, f) {
  if (arguments.length < 2) {
    f = desc;
    desc = undefined;
  }

  var parser = Parsimmon(function (input, i) {
    parser._ = f()._;
    return parser._(input, i);
  });

  if (desc) {
    return parser.desc(desc);
  } else {
    return parser;
  }
} // -*- Fantasy Land Extras -*-


function empty() {
  return fail('fantasy-land/empty');
}

_.concat = _.or;
_.empty = empty;
_.of = succeed;
_['fantasy-land/ap'] = _.ap;
_['fantasy-land/chain'] = _.chain;
_['fantasy-land/concat'] = _.concat;
_['fantasy-land/empty'] = _.empty;
_['fantasy-land/of'] = _.of;
_['fantasy-land/map'] = _.map; // -*- Base Parsers -*-

var index = Parsimmon(function (input, i) {
  return makeSuccess(i, makeLineColumnIndex(input, i));
});
var any = Parsimmon(function (input, i) {
  if (i >= input.length) {
    return makeFailure(i, 'any character/byte');
  }

  return makeSuccess(i + 1, get(input, i));
});
var all = Parsimmon(function (input, i) {
  return makeSuccess(input.length, input.slice(i));
});
var eof = Parsimmon(function (input, i) {
  if (i < input.length) {
    return makeFailure(i, 'EOF');
  }

  return makeSuccess(i, null);
});
var digit = regexp(/[0-9]/).desc('a digit');
var digits = regexp(/[0-9]*/).desc('optional digits');
var letter = regexp(/[a-z]/i).desc('a letter');
var letters = regexp(/[a-z]*/i).desc('optional letters');
var optWhitespace = regexp(/\s*/).desc('optional whitespace');
var whitespace = regexp(/\s+/).desc('whitespace');
var cr = string('\r');
var lf = string('\n');
var crlf = string('\r\n');
var newline = alt(crlf, lf, cr).desc('newline');
var end = alt(newline, eof);
Parsimmon.all = all;
Parsimmon.alt = alt;
Parsimmon.any = any;
Parsimmon.cr = cr;
Parsimmon.createLanguage = createLanguage;
Parsimmon.crlf = crlf;
Parsimmon.custom = custom;
Parsimmon.digit = digit;
Parsimmon.digits = digits;
Parsimmon.empty = empty;
Parsimmon.end = end;
Parsimmon.eof = eof;
Parsimmon.fail = fail;
Parsimmon.formatError = formatError;
Parsimmon.index = index;
Parsimmon.isParser = isParser;
Parsimmon.lazy = lazy;
Parsimmon.letter = letter;
Parsimmon.letters = letters;
Parsimmon.lf = lf;
Parsimmon.lookahead = lookahead;
Parsimmon.makeFailure = makeFailure;
Parsimmon.makeSuccess = makeSuccess;
Parsimmon.newline = newline;
Parsimmon.noneOf = noneOf;
Parsimmon.notFollowedBy = notFollowedBy;
Parsimmon.of = succeed;
Parsimmon.oneOf = oneOf;
Parsimmon.optWhitespace = optWhitespace;
Parsimmon.Parser = Parsimmon;
Parsimmon.range = range;
Parsimmon.regex = regexp;
Parsimmon.regexp = regexp;
Parsimmon.sepBy = sepBy;
Parsimmon.sepBy1 = sepBy1;
Parsimmon.seq = seq;
Parsimmon.seqMap = seqMap;
Parsimmon.seqObj = seqObj;
Parsimmon.string = string;
Parsimmon.succeed = succeed;
Parsimmon.takeWhile = takeWhile;
Parsimmon.test = test;
Parsimmon.whitespace = whitespace;
Parsimmon['fantasy-land/empty'] = empty;
Parsimmon['fantasy-land/of'] = succeed;
Parsimmon.Binary = {
  bitSeq: bitSeq,
  bitSeqObj: bitSeqObj,
  byte: byte,
  buffer: parseBuffer,
  encodedString: encodedString,
  uintBE: uintBE,
  uint8BE: uintBE(1),
  uint16BE: uintBE(2),
  uint32BE: uintBE(4),
  uintLE: uintLE,
  uint8LE: uintLE(1),
  uint16LE: uintLE(2),
  uint32LE: uintLE(4),
  intBE: intBE,
  int8BE: intBE(1),
  int16BE: intBE(2),
  int32BE: intBE(4),
  intLE: intLE,
  int8LE: intLE(1),
  int16LE: intLE(2),
  int32LE: intLE(4),
  floatBE: floatBE(),
  floatLE: floatLE(),
  doubleBE: doubleBE(),
  doubleLE: doubleLE()
};
module.exports = Parsimmon;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(76).Buffer))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Fengari specific string conversion functions
 */

let luastring_from;

if (typeof Uint8Array.from === "function") {
  luastring_from = Uint8Array.from.bind(Uint8Array);
} else {
  luastring_from = function (a) {
    let i = 0;
    let len = a.length;
    let r = new Uint8Array(len);

    while (len > i) r[i] = a[i++];

    return r;
  };
}

let luastring_indexOf;

if (typeof new Uint8Array().indexOf === "function") {
  luastring_indexOf = function (s, v, i) {
    return s.indexOf(v, i);
  };
} else {
  /* Browsers that don't support Uint8Array.indexOf seem to allow using Array.indexOf on Uint8Array objects e.g. IE11 */
  let array_indexOf = [].indexOf;
  if (array_indexOf.call(new Uint8Array(1), 0) !== 0) throw Error("missing .indexOf");

  luastring_indexOf = function (s, v, i) {
    return array_indexOf.call(s, v, i);
  };
}

let luastring_of;

if (typeof Uint8Array.of === "function") {
  luastring_of = Uint8Array.of.bind(Uint8Array);
} else {
  luastring_of = function () {
    return luastring_from(arguments);
  };
}

const is_luastring = function (s) {
  return s instanceof Uint8Array;
};
/* test two lua strings for equality */


const luastring_eq = function (a, b) {
  if (a !== b) {
    let len = a.length;
    if (len !== b.length) return false;
    /* XXX: Should this be a constant time algorithm? */

    for (let i = 0; i < len; i++) if (a[i] !== b[i]) return false;
  }

  return true;
};

const unicode_error_message = "cannot convert invalid utf8 to javascript string";

const to_jsstring = function (value, from, to, replacement_char) {
  if (!is_luastring(value)) throw new TypeError("to_jsstring expects a Uint8Array");

  if (to === void 0) {
    to = value.length;
  } else {
    to = Math.min(value.length, to);
  }

  let str = "";

  for (let i = from !== void 0 ? from : 0; i < to;) {
    let u0 = value[i++];

    if (u0 < 0x80) {
      /* single byte sequence */
      str += String.fromCharCode(u0);
    } else if (u0 < 0xC2 || u0 > 0xF4) {
      if (!replacement_char) throw RangeError(unicode_error_message);
      str += "ï¿½";
    } else if (u0 <= 0xDF) {
      /* two byte sequence */
      if (i >= to) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u1 = value[i++];

      if ((u1 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      str += String.fromCharCode(((u0 & 0x1F) << 6) + (u1 & 0x3F));
    } else if (u0 <= 0xEF) {
      /* three byte sequence */
      if (i + 1 >= to) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u1 = value[i++];

      if ((u1 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u2 = value[i++];

      if ((u2 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u = ((u0 & 0x0F) << 12) + ((u1 & 0x3F) << 6) + (u2 & 0x3F);

      if (u <= 0xFFFF) {
        /* BMP codepoint */
        str += String.fromCharCode(u);
      } else {
        /* Astral codepoint */
        u -= 0x10000;
        let s1 = (u >> 10) + 0xD800;
        let s2 = u % 0x400 + 0xDC00;
        str += String.fromCharCode(s1, s2);
      }
    } else {
      /* four byte sequence */
      if (i + 2 >= to) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u1 = value[i++];

      if ((u1 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u2 = value[i++];

      if ((u2 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }

      let u3 = value[i++];

      if ((u3 & 0xC0) !== 0x80) {
        if (!replacement_char) throw RangeError(unicode_error_message);
        str += "ï¿½";
        continue;
      }
      /* Has to be astral codepoint */


      let u = ((u0 & 0x07) << 18) + ((u1 & 0x3F) << 12) + ((u2 & 0x3F) << 6) + (u3 & 0x3F);
      u -= 0x10000;
      let s1 = (u >> 10) + 0xD800;
      let s2 = u % 0x400 + 0xDC00;
      str += String.fromCharCode(s1, s2);
    }
  }

  return str;
};
/* bytes allowed unescaped in a uri */


const uri_allowed = ";,/?:@&=+$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,-_.!~*'()#".split('').reduce(function (uri_allowed, c) {
  uri_allowed[c.charCodeAt(0)] = true;
  return uri_allowed;
}, {});
/* utility function to convert a lua string to a js string with uri escaping */

const to_uristring = function (a) {
  if (!is_luastring(a)) throw new TypeError("to_uristring expects a Uint8Array");
  let s = "";

  for (let i = 0; i < a.length; i++) {
    let v = a[i];

    if (uri_allowed[v]) {
      s += String.fromCharCode(v);
    } else {
      s += "%" + (v < 0x10 ? "0" : "") + v.toString(16);
    }
  }

  return s;
};

const to_luastring_cache = {};

const to_luastring = function (str, cache) {
  if (typeof str !== "string") throw new TypeError("to_luastring expects a javascript string");

  if (cache) {
    let cached = to_luastring_cache[str];
    if (is_luastring(cached)) return cached;
  }

  let len = str.length;
  let outU8Array = Array(len);
  /* array is at *least* going to be length of string */

  let outIdx = 0;

  for (let i = 0; i < len; ++i) {
    let u = str.charCodeAt(i);

    if (u <= 0x7F) {
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      outU8Array[outIdx++] = 0xC0 | u >> 6;
      outU8Array[outIdx++] = 0x80 | u & 63;
    } else {
      /* This part is to work around possible lack of String.codePointAt */
      if (u >= 0xD800 && u <= 0xDBFF && i + 1 < len) {
        /* is first half of surrogate pair */
        let v = str.charCodeAt(i + 1);

        if (v >= 0xDC00 && v <= 0xDFFF) {
          /* is valid low surrogate */
          i++;
          u = (u - 0xD800) * 0x400 + v + 0x2400;
        }
      }

      if (u <= 0xFFFF) {
        outU8Array[outIdx++] = 0xE0 | u >> 12;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      } else {
        outU8Array[outIdx++] = 0xF0 | u >> 18;
        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;
        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;
        outU8Array[outIdx++] = 0x80 | u & 63;
      }
    }
  }

  outU8Array = luastring_from(outU8Array);
  if (cache) to_luastring_cache[str] = outU8Array;
  return outU8Array;
};

const from_userstring = function (str) {
  if (!is_luastring(str)) {
    if (typeof str === "string") {
      str = to_luastring(str);
    } else {
      throw new TypeError("expects an array of bytes or javascript string");
    }
  }

  return str;
};

module.exports.luastring_from = luastring_from;
module.exports.luastring_indexOf = luastring_indexOf;
module.exports.luastring_of = luastring_of;
module.exports.is_luastring = is_luastring;
module.exports.luastring_eq = luastring_eq;
module.exports.to_jsstring = to_jsstring;
module.exports.to_uristring = to_uristring;
module.exports.to_luastring = to_luastring;
module.exports.from_userstring = from_userstring;
/* mark for precompiled code ('<esc>Lua') */

const LUA_SIGNATURE = to_luastring("\x1bLua");
const LUA_VERSION_MAJOR = "5";
const LUA_VERSION_MINOR = "3";
const LUA_VERSION_NUM = 503;
const LUA_VERSION_RELEASE = "4";
const LUA_VERSION = "Lua " + LUA_VERSION_MAJOR + "." + LUA_VERSION_MINOR;
const LUA_RELEASE = LUA_VERSION + "." + LUA_VERSION_RELEASE;
const LUA_COPYRIGHT = LUA_RELEASE + "  Copyright (C) 1994-2017 Lua.org, PUC-Rio";
const LUA_AUTHORS = "R. Ierusalimschy, L. H. de Figueiredo, W. Celes";
module.exports.LUA_SIGNATURE = LUA_SIGNATURE;
module.exports.LUA_VERSION_MAJOR = LUA_VERSION_MAJOR;
module.exports.LUA_VERSION_MINOR = LUA_VERSION_MINOR;
module.exports.LUA_VERSION_NUM = LUA_VERSION_NUM;
module.exports.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE;
module.exports.LUA_VERSION = LUA_VERSION;
module.exports.LUA_RELEASE = LUA_RELEASE;
module.exports.LUA_COPYRIGHT = LUA_COPYRIGHT;
module.exports.LUA_AUTHORS = LUA_AUTHORS;
const thread_status = {
  LUA_OK: 0,
  LUA_YIELD: 1,
  LUA_ERRRUN: 2,
  LUA_ERRSYNTAX: 3,
  LUA_ERRMEM: 4,
  LUA_ERRGCMM: 5,
  LUA_ERRERR: 6
};
const constant_types = {
  LUA_TNONE: -1,
  LUA_TNIL: 0,
  LUA_TBOOLEAN: 1,
  LUA_TLIGHTUSERDATA: 2,
  LUA_TNUMBER: 3,
  LUA_TSTRING: 4,
  LUA_TTABLE: 5,
  LUA_TFUNCTION: 6,
  LUA_TUSERDATA: 7,
  LUA_TTHREAD: 8,
  LUA_NUMTAGS: 9
};
constant_types.LUA_TSHRSTR = constant_types.LUA_TSTRING | 0 << 4;
/* short strings */

constant_types.LUA_TLNGSTR = constant_types.LUA_TSTRING | 1 << 4;
/* long strings */

constant_types.LUA_TNUMFLT = constant_types.LUA_TNUMBER | 0 << 4;
/* float numbers */

constant_types.LUA_TNUMINT = constant_types.LUA_TNUMBER | 1 << 4;
/* integer numbers */

constant_types.LUA_TLCL = constant_types.LUA_TFUNCTION | 0 << 4;
/* Lua closure */

constant_types.LUA_TLCF = constant_types.LUA_TFUNCTION | 1 << 4;
/* light C function */

constant_types.LUA_TCCL = constant_types.LUA_TFUNCTION | 2 << 4;
/* C closure */

/*
** Comparison and arithmetic functions
*/

const LUA_OPADD = 0;
/* ORDER TM, ORDER OP */

const LUA_OPSUB = 1;
const LUA_OPMUL = 2;
const LUA_OPMOD = 3;
const LUA_OPPOW = 4;
const LUA_OPDIV = 5;
const LUA_OPIDIV = 6;
const LUA_OPBAND = 7;
const LUA_OPBOR = 8;
const LUA_OPBXOR = 9;
const LUA_OPSHL = 10;
const LUA_OPSHR = 11;
const LUA_OPUNM = 12;
const LUA_OPBNOT = 13;
const LUA_OPEQ = 0;
const LUA_OPLT = 1;
const LUA_OPLE = 2;
const LUA_MINSTACK = 20;

const {
  LUAI_MAXSTACK
} = __webpack_require__(4);

const LUA_REGISTRYINDEX = -LUAI_MAXSTACK - 1000;

const lua_upvalueindex = function (i) {
  return LUA_REGISTRYINDEX - i;
};
/* predefined values in the registry */


const LUA_RIDX_MAINTHREAD = 1;
const LUA_RIDX_GLOBALS = 2;
const LUA_RIDX_LAST = LUA_RIDX_GLOBALS;

class lua_Debug {
  constructor() {
    this.event = NaN;
    this.name = null;
    /* (n) */

    this.namewhat = null;
    /* (n) 'global', 'local', 'field', 'method' */

    this.what = null;
    /* (S) 'Lua', 'C', 'main', 'tail' */

    this.source = null;
    /* (S) */

    this.currentline = NaN;
    /* (l) */

    this.linedefined = NaN;
    /* (S) */

    this.lastlinedefined = NaN;
    /* (S) */

    this.nups = NaN;
    /* (u) number of upvalues */

    this.nparams = NaN;
    /* (u) number of parameters */

    this.isvararg = NaN;
    /* (u) */

    this.istailcall = NaN;
    /* (t) */

    this.short_src = null;
    /* (S) */

    /* private part */

    this.i_ci = null;
    /* active function */
  }

}
/*
** Event codes
*/


const LUA_HOOKCALL = 0;
const LUA_HOOKRET = 1;
const LUA_HOOKLINE = 2;
const LUA_HOOKCOUNT = 3;
const LUA_HOOKTAILCALL = 4;
/*
** Event masks
*/

const LUA_MASKCALL = 1 << LUA_HOOKCALL;
const LUA_MASKRET = 1 << LUA_HOOKRET;
const LUA_MASKLINE = 1 << LUA_HOOKLINE;
const LUA_MASKCOUNT = 1 << LUA_HOOKCOUNT;
module.exports.LUA_HOOKCALL = LUA_HOOKCALL;
module.exports.LUA_HOOKCOUNT = LUA_HOOKCOUNT;
module.exports.LUA_HOOKLINE = LUA_HOOKLINE;
module.exports.LUA_HOOKRET = LUA_HOOKRET;
module.exports.LUA_HOOKTAILCALL = LUA_HOOKTAILCALL;
module.exports.LUA_MASKCALL = LUA_MASKCALL;
module.exports.LUA_MASKCOUNT = LUA_MASKCOUNT;
module.exports.LUA_MASKLINE = LUA_MASKLINE;
module.exports.LUA_MASKRET = LUA_MASKRET;
module.exports.LUA_MINSTACK = LUA_MINSTACK;
module.exports.LUA_MULTRET = -1;
module.exports.LUA_OPADD = LUA_OPADD;
module.exports.LUA_OPBAND = LUA_OPBAND;
module.exports.LUA_OPBNOT = LUA_OPBNOT;
module.exports.LUA_OPBOR = LUA_OPBOR;
module.exports.LUA_OPBXOR = LUA_OPBXOR;
module.exports.LUA_OPDIV = LUA_OPDIV;
module.exports.LUA_OPEQ = LUA_OPEQ;
module.exports.LUA_OPIDIV = LUA_OPIDIV;
module.exports.LUA_OPLE = LUA_OPLE;
module.exports.LUA_OPLT = LUA_OPLT;
module.exports.LUA_OPMOD = LUA_OPMOD;
module.exports.LUA_OPMUL = LUA_OPMUL;
module.exports.LUA_OPPOW = LUA_OPPOW;
module.exports.LUA_OPSHL = LUA_OPSHL;
module.exports.LUA_OPSHR = LUA_OPSHR;
module.exports.LUA_OPSUB = LUA_OPSUB;
module.exports.LUA_OPUNM = LUA_OPUNM;
module.exports.LUA_REGISTRYINDEX = LUA_REGISTRYINDEX;
module.exports.LUA_RIDX_GLOBALS = LUA_RIDX_GLOBALS;
module.exports.LUA_RIDX_LAST = LUA_RIDX_LAST;
module.exports.LUA_RIDX_MAINTHREAD = LUA_RIDX_MAINTHREAD;
module.exports.constant_types = constant_types;
module.exports.lua_Debug = lua_Debug;
module.exports.lua_upvalueindex = lua_upvalueindex;
module.exports.thread_status = thread_status;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const defs = __webpack_require__(1);

const lapi = __webpack_require__(22);

const ldebug = __webpack_require__(12);

const ldo = __webpack_require__(9);

const lstate = __webpack_require__(13);

module.exports.LUA_AUTHORS = defs.LUA_AUTHORS;
module.exports.LUA_COPYRIGHT = defs.LUA_COPYRIGHT;
module.exports.LUA_ERRERR = defs.thread_status.LUA_ERRERR;
module.exports.LUA_ERRGCMM = defs.thread_status.LUA_ERRGCMM;
module.exports.LUA_ERRMEM = defs.thread_status.LUA_ERRMEM;
module.exports.LUA_ERRRUN = defs.thread_status.LUA_ERRRUN;
module.exports.LUA_ERRSYNTAX = defs.thread_status.LUA_ERRSYNTAX;
module.exports.LUA_HOOKCALL = defs.LUA_HOOKCALL;
module.exports.LUA_HOOKCOUNT = defs.LUA_HOOKCOUNT;
module.exports.LUA_HOOKLINE = defs.LUA_HOOKLINE;
module.exports.LUA_HOOKRET = defs.LUA_HOOKRET;
module.exports.LUA_HOOKTAILCALL = defs.LUA_HOOKTAILCALL;
module.exports.LUA_MASKCALL = defs.LUA_MASKCALL;
module.exports.LUA_MASKCOUNT = defs.LUA_MASKCOUNT;
module.exports.LUA_MASKLINE = defs.LUA_MASKLINE;
module.exports.LUA_MASKRET = defs.LUA_MASKRET;
module.exports.LUA_MINSTACK = defs.LUA_MINSTACK;
module.exports.LUA_MULTRET = defs.LUA_MULTRET;
module.exports.LUA_NUMTAGS = defs.constant_types.LUA_NUMTAGS;
module.exports.LUA_OK = defs.thread_status.LUA_OK;
module.exports.LUA_OPADD = defs.LUA_OPADD;
module.exports.LUA_OPBAND = defs.LUA_OPBAND;
module.exports.LUA_OPBNOT = defs.LUA_OPBNOT;
module.exports.LUA_OPBOR = defs.LUA_OPBOR;
module.exports.LUA_OPBXOR = defs.LUA_OPBXOR;
module.exports.LUA_OPDIV = defs.LUA_OPDIV;
module.exports.LUA_OPEQ = defs.LUA_OPEQ;
module.exports.LUA_OPIDIV = defs.LUA_OPIDIV;
module.exports.LUA_OPLE = defs.LUA_OPLE;
module.exports.LUA_OPLT = defs.LUA_OPLT;
module.exports.LUA_OPMOD = defs.LUA_OPMOD;
module.exports.LUA_OPMUL = defs.LUA_OPMUL;
module.exports.LUA_OPPOW = defs.LUA_OPPOW;
module.exports.LUA_OPSHL = defs.LUA_OPSHL;
module.exports.LUA_OPSHR = defs.LUA_OPSHR;
module.exports.LUA_OPSUB = defs.LUA_OPSUB;
module.exports.LUA_OPUNM = defs.LUA_OPUNM;
module.exports.LUA_REGISTRYINDEX = defs.LUA_REGISTRYINDEX;
module.exports.LUA_RELEASE = defs.LUA_RELEASE;
module.exports.LUA_RIDX_GLOBALS = defs.LUA_RIDX_GLOBALS;
module.exports.LUA_RIDX_LAST = defs.LUA_RIDX_LAST;
module.exports.LUA_RIDX_MAINTHREAD = defs.LUA_RIDX_MAINTHREAD;
module.exports.LUA_SIGNATURE = defs.LUA_SIGNATURE;
module.exports.LUA_TNONE = defs.constant_types.LUA_TNONE;
module.exports.LUA_TNIL = defs.constant_types.LUA_TNIL;
module.exports.LUA_TBOOLEAN = defs.constant_types.LUA_TBOOLEAN;
module.exports.LUA_TLIGHTUSERDATA = defs.constant_types.LUA_TLIGHTUSERDATA;
module.exports.LUA_TNUMBER = defs.constant_types.LUA_TNUMBER;
module.exports.LUA_TSTRING = defs.constant_types.LUA_TSTRING;
module.exports.LUA_TTABLE = defs.constant_types.LUA_TTABLE;
module.exports.LUA_TFUNCTION = defs.constant_types.LUA_TFUNCTION;
module.exports.LUA_TUSERDATA = defs.constant_types.LUA_TUSERDATA;
module.exports.LUA_TTHREAD = defs.constant_types.LUA_TTHREAD;
module.exports.LUA_VERSION = defs.LUA_VERSION;
module.exports.LUA_VERSION_MAJOR = defs.LUA_VERSION_MAJOR;
module.exports.LUA_VERSION_MINOR = defs.LUA_VERSION_MINOR;
module.exports.LUA_VERSION_NUM = defs.LUA_VERSION_NUM;
module.exports.LUA_VERSION_RELEASE = defs.LUA_VERSION_RELEASE;
module.exports.LUA_YIELD = defs.thread_status.LUA_YIELD;
module.exports.lua_Debug = defs.lua_Debug;
module.exports.lua_upvalueindex = defs.lua_upvalueindex;
module.exports.lua_absindex = lapi.lua_absindex;
module.exports.lua_arith = lapi.lua_arith;
module.exports.lua_atpanic = lapi.lua_atpanic;
module.exports.lua_atnativeerror = lapi.lua_atnativeerror;
module.exports.lua_call = lapi.lua_call;
module.exports.lua_callk = lapi.lua_callk;
module.exports.lua_checkstack = lapi.lua_checkstack;
module.exports.lua_close = lstate.lua_close;
module.exports.lua_compare = lapi.lua_compare;
module.exports.lua_concat = lapi.lua_concat;
module.exports.lua_copy = lapi.lua_copy;
module.exports.lua_createtable = lapi.lua_createtable;
module.exports.lua_dump = lapi.lua_dump;
module.exports.lua_error = lapi.lua_error;
module.exports.lua_gc = lapi.lua_gc;
module.exports.lua_getallocf = lapi.lua_getallocf;
module.exports.lua_getextraspace = lapi.lua_getextraspace;
module.exports.lua_getfield = lapi.lua_getfield;
module.exports.lua_getglobal = lapi.lua_getglobal;
module.exports.lua_gethook = ldebug.lua_gethook;
module.exports.lua_gethookcount = ldebug.lua_gethookcount;
module.exports.lua_gethookmask = ldebug.lua_gethookmask;
module.exports.lua_geti = lapi.lua_geti;
module.exports.lua_getinfo = ldebug.lua_getinfo;
module.exports.lua_getlocal = ldebug.lua_getlocal;
module.exports.lua_getmetatable = lapi.lua_getmetatable;
module.exports.lua_getstack = ldebug.lua_getstack;
module.exports.lua_gettable = lapi.lua_gettable;
module.exports.lua_gettop = lapi.lua_gettop;
module.exports.lua_getupvalue = lapi.lua_getupvalue;
module.exports.lua_getuservalue = lapi.lua_getuservalue;
module.exports.lua_insert = lapi.lua_insert;
module.exports.lua_isboolean = lapi.lua_isboolean;
module.exports.lua_iscfunction = lapi.lua_iscfunction;
module.exports.lua_isfunction = lapi.lua_isfunction;
module.exports.lua_isinteger = lapi.lua_isinteger;
module.exports.lua_islightuserdata = lapi.lua_islightuserdata;
module.exports.lua_isnil = lapi.lua_isnil;
module.exports.lua_isnone = lapi.lua_isnone;
module.exports.lua_isnoneornil = lapi.lua_isnoneornil;
module.exports.lua_isnumber = lapi.lua_isnumber;
module.exports.lua_isproxy = lapi.lua_isproxy;
module.exports.lua_isstring = lapi.lua_isstring;
module.exports.lua_istable = lapi.lua_istable;
module.exports.lua_isthread = lapi.lua_isthread;
module.exports.lua_isuserdata = lapi.lua_isuserdata;
module.exports.lua_isyieldable = ldo.lua_isyieldable;
module.exports.lua_len = lapi.lua_len;
module.exports.lua_load = lapi.lua_load;
module.exports.lua_newstate = lstate.lua_newstate;
module.exports.lua_newtable = lapi.lua_newtable;
module.exports.lua_newthread = lstate.lua_newthread;
module.exports.lua_newuserdata = lapi.lua_newuserdata;
module.exports.lua_next = lapi.lua_next;
module.exports.lua_pcall = lapi.lua_pcall;
module.exports.lua_pcallk = lapi.lua_pcallk;
module.exports.lua_pop = lapi.lua_pop;
module.exports.lua_pushboolean = lapi.lua_pushboolean;
module.exports.lua_pushcclosure = lapi.lua_pushcclosure;
module.exports.lua_pushcfunction = lapi.lua_pushcfunction;
module.exports.lua_pushfstring = lapi.lua_pushfstring;
module.exports.lua_pushglobaltable = lapi.lua_pushglobaltable;
module.exports.lua_pushinteger = lapi.lua_pushinteger;
module.exports.lua_pushjsclosure = lapi.lua_pushjsclosure;
module.exports.lua_pushjsfunction = lapi.lua_pushjsfunction;
module.exports.lua_pushlightuserdata = lapi.lua_pushlightuserdata;
module.exports.lua_pushliteral = lapi.lua_pushliteral;
module.exports.lua_pushlstring = lapi.lua_pushlstring;
module.exports.lua_pushnil = lapi.lua_pushnil;
module.exports.lua_pushnumber = lapi.lua_pushnumber;
module.exports.lua_pushstring = lapi.lua_pushstring;
module.exports.lua_pushthread = lapi.lua_pushthread;
module.exports.lua_pushvalue = lapi.lua_pushvalue;
module.exports.lua_pushvfstring = lapi.lua_pushvfstring;
module.exports.lua_rawequal = lapi.lua_rawequal;
module.exports.lua_rawget = lapi.lua_rawget;
module.exports.lua_rawgeti = lapi.lua_rawgeti;
module.exports.lua_rawgetp = lapi.lua_rawgetp;
module.exports.lua_rawlen = lapi.lua_rawlen;
module.exports.lua_rawset = lapi.lua_rawset;
module.exports.lua_rawseti = lapi.lua_rawseti;
module.exports.lua_rawsetp = lapi.lua_rawsetp;
module.exports.lua_register = lapi.lua_register;
module.exports.lua_remove = lapi.lua_remove;
module.exports.lua_replace = lapi.lua_replace;
module.exports.lua_resume = ldo.lua_resume;
module.exports.lua_rotate = lapi.lua_rotate;
module.exports.lua_setallof = ldo.lua_setallof;
module.exports.lua_setfield = lapi.lua_setfield;
module.exports.lua_setglobal = lapi.lua_setglobal;
module.exports.lua_sethook = ldebug.lua_sethook;
module.exports.lua_seti = lapi.lua_seti;
module.exports.lua_setlocal = ldebug.lua_setlocal;
module.exports.lua_setmetatable = lapi.lua_setmetatable;
module.exports.lua_settable = lapi.lua_settable;
module.exports.lua_settop = lapi.lua_settop;
module.exports.lua_setupvalue = lapi.lua_setupvalue;
module.exports.lua_setuservalue = lapi.lua_setuservalue;
module.exports.lua_status = lapi.lua_status;
module.exports.lua_stringtonumber = lapi.lua_stringtonumber;
module.exports.lua_toboolean = lapi.lua_toboolean;
module.exports.lua_todataview = lapi.lua_todataview;
module.exports.lua_tointeger = lapi.lua_tointeger;
module.exports.lua_tointegerx = lapi.lua_tointegerx;
module.exports.lua_tojsstring = lapi.lua_tojsstring;
module.exports.lua_tolstring = lapi.lua_tolstring;
module.exports.lua_tonumber = lapi.lua_tonumber;
module.exports.lua_tonumberx = lapi.lua_tonumberx;
module.exports.lua_topointer = lapi.lua_topointer;
module.exports.lua_toproxy = lapi.lua_toproxy;
module.exports.lua_tostring = lapi.lua_tostring;
module.exports.lua_tothread = lapi.lua_tothread;
module.exports.lua_touserdata = lapi.lua_touserdata;
module.exports.lua_type = lapi.lua_type;
module.exports.lua_typename = lapi.lua_typename;
module.exports.lua_upvalueid = lapi.lua_upvalueid;
module.exports.lua_upvaluejoin = lapi.lua_upvaluejoin;
module.exports.lua_version = lapi.lua_version;
module.exports.lua_xmove = lapi.lua_xmove;
module.exports.lua_yield = ldo.lua_yield;
module.exports.lua_yieldk = ldo.lua_yieldk;
module.exports.lua_tocfunction = lapi.lua_tocfunction;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var proto = {};
module.exports = proto;
proto.from = __webpack_require__(53);
proto.to = __webpack_require__(54);
proto.is = __webpack_require__(56);
proto.subarray = __webpack_require__(57);
proto.join = __webpack_require__(58);
proto.copy = __webpack_require__(59);
proto.create = __webpack_require__(60);
mix(__webpack_require__(61), proto);
mix(__webpack_require__(62), proto);

function mix(from, into) {
  for (var key in from) {
    into[key] = from[key];
  }
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const conf = void 0 ? JSON.parse(void 0) : {};

const {
  LUA_VERSION_MAJOR,
  LUA_VERSION_MINOR,
  to_luastring
} = __webpack_require__(1);
/*
** LUA_PATH_SEP is the character that separates templates in a path.
** LUA_PATH_MARK is the string that marks the substitution points in a
** template.
** LUA_EXEC_DIR in a Windows path is replaced by the executable's
** directory.
*/


const LUA_PATH_SEP = ";";
module.exports.LUA_PATH_SEP = LUA_PATH_SEP;
const LUA_PATH_MARK = "?";
module.exports.LUA_PATH_MARK = LUA_PATH_MARK;
const LUA_EXEC_DIR = "!";
module.exports.LUA_EXEC_DIR = LUA_EXEC_DIR;
/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_JSPATH_DEFAULT is the default path that Lua uses to look for
** JS libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/

const LUA_VDIR = LUA_VERSION_MAJOR + "." + LUA_VERSION_MINOR;
module.exports.LUA_VDIR = LUA_VDIR;

if (true) {
  const LUA_DIRSEP = "/";
  module.exports.LUA_DIRSEP = LUA_DIRSEP;
  const LUA_LDIR = "./lua/" + LUA_VDIR + "/";
  module.exports.LUA_LDIR = LUA_LDIR;
  const LUA_JSDIR = LUA_LDIR;
  module.exports.LUA_JSDIR = LUA_JSDIR;
  const LUA_PATH_DEFAULT = to_luastring(LUA_LDIR + "?.lua;" + LUA_LDIR + "?/init.lua;" +
  /* LUA_JSDIR excluded as it is equal to LUA_LDIR */
  "./?.lua;./?/init.lua");
  module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;
  const LUA_JSPATH_DEFAULT = to_luastring(LUA_JSDIR + "?.js;" + LUA_JSDIR + "loadall.js;./?.js");
  module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;
} else {}
/*
@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
@@ a float mark ('.0').
** This macro is not on by default even in compatibility mode,
** because this is not really an incompatibility.
*/


const LUA_COMPAT_FLOATSTRING = conf.LUA_COMPAT_FLOATSTRING || false;
const LUA_MAXINTEGER = 2147483647;
const LUA_MININTEGER = -2147483648;
/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
*/

const LUAI_MAXSTACK = conf.LUAI_MAXSTACK || 1000000;
/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/

const LUA_IDSIZE = conf.LUA_IDSIZE || 60 - 1;
/* fengari uses 1 less than lua as we don't embed the null byte */

const lua_integer2str = function (n) {
  return String(n);
  /* should match behaviour of LUA_INTEGER_FMT */
};

const lua_number2str = function (n) {
  return String(Number(n.toPrecision(14)));
  /* should match behaviour of LUA_NUMBER_FMT */
};

const lua_numbertointeger = function (n) {
  return n >= LUA_MININTEGER && n < -LUA_MININTEGER ? n : false;
};

const LUA_INTEGER_FRMLEN = "";
const LUA_NUMBER_FRMLEN = "";
const LUA_INTEGER_FMT = `%${LUA_INTEGER_FRMLEN}d`;
const LUA_NUMBER_FMT = "%.14g";

const lua_getlocaledecpoint = function () {
  /* we hard-code the decimal point to '.' as a user cannot change the
     locale in most JS environments, and in that you can, a multi-byte
     locale is common.
  */
  return 46
  /* '.'.charCodeAt(0) */
  ;
};

const luai_apicheck = function (l, e) {
  if (!e) throw Error(e);
};
/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
*/


const LUAL_BUFFERSIZE = conf.LUAL_BUFFERSIZE || 8192; // See: http://croquetweak.blogspot.fr/2014/08/deconstructing-floats-frexp-and-ldexp.html

const frexp = function (value) {
  if (value === 0) return [value, 0];
  var data = new DataView(new ArrayBuffer(8));
  data.setFloat64(0, value);
  var bits = data.getUint32(0) >>> 20 & 0x7FF;

  if (bits === 0) {
    // denormal
    data.setFloat64(0, value * Math.pow(2, 64)); // exp + 64

    bits = (data.getUint32(0) >>> 20 & 0x7FF) - 64;
  }

  var exponent = bits - 1022;
  var mantissa = ldexp(value, -exponent);
  return [mantissa, exponent];
};

const ldexp = function (mantissa, exponent) {
  var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));
  var result = mantissa;

  for (var i = 0; i < steps; i++) result *= Math.pow(2, Math.floor((exponent + i) / steps));

  return result;
};

module.exports.LUAI_MAXSTACK = LUAI_MAXSTACK;
module.exports.LUA_COMPAT_FLOATSTRING = LUA_COMPAT_FLOATSTRING;
module.exports.LUA_IDSIZE = LUA_IDSIZE;
module.exports.LUA_INTEGER_FMT = LUA_INTEGER_FMT;
module.exports.LUA_INTEGER_FRMLEN = LUA_INTEGER_FRMLEN;
module.exports.LUA_MAXINTEGER = LUA_MAXINTEGER;
module.exports.LUA_MININTEGER = LUA_MININTEGER;
module.exports.LUA_NUMBER_FMT = LUA_NUMBER_FMT;
module.exports.LUA_NUMBER_FRMLEN = LUA_NUMBER_FRMLEN;
module.exports.LUAL_BUFFERSIZE = LUAL_BUFFERSIZE;
module.exports.frexp = frexp;
module.exports.ldexp = ldexp;
module.exports.lua_getlocaledecpoint = lua_getlocaledecpoint;
module.exports.lua_integer2str = lua_integer2str;
module.exports.lua_number2str = lua_number2str;
module.exports.lua_numbertointeger = lua_numbertointeger;
module.exports.luai_apicheck = luai_apicheck;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  luai_apicheck
} = __webpack_require__(4);

const lua_assert = function (c) {
  if (!c) throw Error("assertion failed");
};

module.exports.lua_assert = lua_assert;

module.exports.luai_apicheck = luai_apicheck || function (l, e) {
  return lua_assert(e);
};

const api_check = function (l, e, msg) {
  return luai_apicheck(l, e && msg);
};

module.exports.api_check = api_check;
const LUAI_MAXCCALLS = 200;
module.exports.LUAI_MAXCCALLS = LUAI_MAXCCALLS;
/* minimum size for string buffer */

const LUA_MINBUFFER = 32;
module.exports.LUA_MINBUFFER = LUA_MINBUFFER;

const luai_nummod = function (L, a, b) {
  let m = a % b;
  if (m * b < 0) m += b;
  return m;
};

module.exports.luai_nummod = luai_nummod; // If later integers are more than 32bit, LUA_MAXINTEGER will then be != MAX_INT

const MAX_INT = 2147483647;
module.exports.MAX_INT = MAX_INT;
const MIN_INT = -2147483648;
module.exports.MIN_INT = MIN_INT;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* Fengari specific functions
 *
 * This file includes fengari-specific data or and functionality for users to
 * manipulate fengari's string type.
 * The fields are exposed to the user on the 'fengari' entry point; however to
 * avoid a dependency on defs.js from lauxlib.js they are defined in this file.
 */
const defs = __webpack_require__(1);

const FENGARI_VERSION_MAJOR = "0";
const FENGARI_VERSION_MINOR = "1";
const FENGARI_VERSION_NUM = 1;
const FENGARI_VERSION_RELEASE = "4";
const FENGARI_VERSION = "Fengari " + FENGARI_VERSION_MAJOR + "." + FENGARI_VERSION_MINOR;
const FENGARI_RELEASE = FENGARI_VERSION + "." + FENGARI_VERSION_RELEASE;
const FENGARI_AUTHORS = "B. Giannangeli, Daurnimator";
const FENGARI_COPYRIGHT = FENGARI_RELEASE + "  Copyright (C) 2017-2018 " + FENGARI_AUTHORS + "\nBased on: " + defs.LUA_COPYRIGHT;
module.exports.FENGARI_AUTHORS = FENGARI_AUTHORS;
module.exports.FENGARI_COPYRIGHT = FENGARI_COPYRIGHT;
module.exports.FENGARI_RELEASE = FENGARI_RELEASE;
module.exports.FENGARI_VERSION = FENGARI_VERSION;
module.exports.FENGARI_VERSION_MAJOR = FENGARI_VERSION_MAJOR;
module.exports.FENGARI_VERSION_MINOR = FENGARI_VERSION_MINOR;
module.exports.FENGARI_VERSION_NUM = FENGARI_VERSION_NUM;
module.exports.FENGARI_VERSION_RELEASE = FENGARI_VERSION_RELEASE;
module.exports.is_luastring = defs.is_luastring;
module.exports.luastring_eq = defs.luastring_eq;
module.exports.luastring_from = defs.luastring_from;
module.exports.luastring_indexOf = defs.luastring_indexOf;
module.exports.luastring_of = defs.luastring_of;
module.exports.to_jsstring = defs.to_jsstring;
module.exports.to_luastring = defs.to_luastring;
module.exports.to_uristring = defs.to_uristring;
module.exports.from_userstring = defs.from_userstring;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_OPADD,
  LUA_OPBAND,
  LUA_OPBNOT,
  LUA_OPBOR,
  LUA_OPBXOR,
  LUA_OPDIV,
  LUA_OPIDIV,
  LUA_OPMOD,
  LUA_OPMUL,
  LUA_OPPOW,
  LUA_OPSHL,
  LUA_OPSHR,
  LUA_OPSUB,
  LUA_OPUNM,
  constant_types: {
    LUA_NUMTAGS,
    LUA_TBOOLEAN,
    LUA_TCCL,
    LUA_TFUNCTION,
    LUA_TLCF,
    LUA_TLCL,
    LUA_TLIGHTUSERDATA,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMBER,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR,
    LUA_TSTRING,
    LUA_TTABLE,
    LUA_TTHREAD,
    LUA_TUSERDATA
  },
  from_userstring,
  luastring_indexOf,
  luastring_of,
  to_jsstring,
  to_luastring
} = __webpack_require__(1);

const {
  lisdigit,
  lisprint,
  lisspace,
  lisxdigit
} = __webpack_require__(33);

const ldebug = __webpack_require__(12);

const ldo = __webpack_require__(9);

const lstate = __webpack_require__(13);

const {
  luaS_bless,
  luaS_new
} = __webpack_require__(11);

const ltable = __webpack_require__(10);

const {
  LUA_COMPAT_FLOATSTRING,
  ldexp,
  lua_integer2str,
  lua_number2str
} = __webpack_require__(4);

const lvm = __webpack_require__(16);

const {
  MAX_INT,
  luai_nummod,
  lua_assert
} = __webpack_require__(5);

const ltm = __webpack_require__(15);

const LUA_TPROTO = LUA_NUMTAGS;
const LUA_TDEADKEY = LUA_NUMTAGS + 1;

class TValue {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */


  ttype() {
    return this.type & 0x3F;
  }
  /* type tag of a TValue with no variants (bits 0-3) */


  ttnov() {
    return this.type & 0x0F;
  }

  checktag(t) {
    return this.type === t;
  }

  checktype(t) {
    return this.ttnov() === t;
  }

  ttisnumber() {
    return this.checktype(LUA_TNUMBER);
  }

  ttisfloat() {
    return this.checktag(LUA_TNUMFLT);
  }

  ttisinteger() {
    return this.checktag(LUA_TNUMINT);
  }

  ttisnil() {
    return this.checktag(LUA_TNIL);
  }

  ttisboolean() {
    return this.checktag(LUA_TBOOLEAN);
  }

  ttislightuserdata() {
    return this.checktag(LUA_TLIGHTUSERDATA);
  }

  ttisstring() {
    return this.checktype(LUA_TSTRING);
  }

  ttisshrstring() {
    return this.checktag(LUA_TSHRSTR);
  }

  ttislngstring() {
    return this.checktag(LUA_TLNGSTR);
  }

  ttistable() {
    return this.checktag(LUA_TTABLE);
  }

  ttisfunction() {
    return this.checktype(LUA_TFUNCTION);
  }

  ttisclosure() {
    return (this.type & 0x1F) === LUA_TFUNCTION;
  }

  ttisCclosure() {
    return this.checktag(LUA_TCCL);
  }

  ttisLclosure() {
    return this.checktag(LUA_TLCL);
  }

  ttislcf() {
    return this.checktag(LUA_TLCF);
  }

  ttisfulluserdata() {
    return this.checktag(LUA_TUSERDATA);
  }

  ttisthread() {
    return this.checktag(LUA_TTHREAD);
  }

  ttisdeadkey() {
    return this.checktag(LUA_TDEADKEY);
  }

  l_isfalse() {
    return this.ttisnil() || this.ttisboolean() && this.value === false;
  }

  setfltvalue(x) {
    this.type = LUA_TNUMFLT;
    this.value = x;
  }

  chgfltvalue(x) {
    lua_assert(this.type == LUA_TNUMFLT);
    this.value = x;
  }

  setivalue(x) {
    this.type = LUA_TNUMINT;
    this.value = x;
  }

  chgivalue(x) {
    lua_assert(this.type == LUA_TNUMINT);
    this.value = x;
  }

  setnilvalue() {
    this.type = LUA_TNIL;
    this.value = null;
  }

  setfvalue(x) {
    this.type = LUA_TLCF;
    this.value = x;
  }

  setpvalue(x) {
    this.type = LUA_TLIGHTUSERDATA;
    this.value = x;
  }

  setbvalue(x) {
    this.type = LUA_TBOOLEAN;
    this.value = x;
  }

  setsvalue(x) {
    this.type = LUA_TLNGSTR;
    /* LUA_TSHRSTR? */

    this.value = x;
  }

  setuvalue(x) {
    this.type = LUA_TUSERDATA;
    this.value = x;
  }

  setthvalue(x) {
    this.type = LUA_TTHREAD;
    this.value = x;
  }

  setclLvalue(x) {
    this.type = LUA_TLCL;
    this.value = x;
  }

  setclCvalue(x) {
    this.type = LUA_TCCL;
    this.value = x;
  }

  sethvalue(x) {
    this.type = LUA_TTABLE;
    this.value = x;
  }

  setdeadvalue() {
    this.type = LUA_TDEADKEY;
    this.value = null;
  }

  setfrom(tv) {
    /* in lua C source setobj2t is often used for this */
    this.type = tv.type;
    this.value = tv.value;
  }

  tsvalue() {
    lua_assert(this.ttisstring());
    return this.value;
  }

  svalue() {
    return this.tsvalue().getstr();
  }

  vslen() {
    return this.tsvalue().tsslen();
  }

  jsstring(from, to) {
    return to_jsstring(this.svalue(), from, to, true);
  }

}

const pushobj2s = function (L, tv) {
  L.stack[L.top++] = new TValue(tv.type, tv.value);
};

const pushsvalue2s = function (L, ts) {
  L.stack[L.top++] = new TValue(LUA_TLNGSTR, ts);
};
/* from stack to (same) stack */


const setobjs2s = function (L, newidx, oldidx) {
  L.stack[newidx].setfrom(L.stack[oldidx]);
};
/* to stack (not from same stack) */


const setobj2s = function (L, newidx, oldtv) {
  L.stack[newidx].setfrom(oldtv);
};

const setsvalue2s = function (L, newidx, ts) {
  L.stack[newidx].setsvalue(ts);
};

const luaO_nilobject = new TValue(LUA_TNIL, null);
Object.freeze(luaO_nilobject);
module.exports.luaO_nilobject = luaO_nilobject;

class LClosure {
  constructor(L, n) {
    this.id = L.l_G.id_counter++;
    this.p = null;
    this.nupvalues = n;
    this.upvals = new Array(n);
    /* list of upvalues. initialised in luaF_initupvals */
  }

}

class CClosure {
  constructor(L, f, n) {
    this.id = L.l_G.id_counter++;
    this.f = f;
    this.nupvalues = n;
    this.upvalue = new Array(n);
    /* list of upvalues as TValues */

    while (n--) {
      this.upvalue[n] = new TValue(LUA_TNIL, null);
    }
  }

}

class Udata {
  constructor(L, size) {
    this.id = L.l_G.id_counter++;
    this.metatable = null;
    this.uservalue = new TValue(LUA_TNIL, null);
    this.len = size;
    this.data = Object.create(null); // ignores size argument
  }

}
/*
** Description of a local variable for function prototypes
** (used for debug information)
*/


class LocVar {
  constructor() {
    this.varname = null;
    this.startpc = NaN;
    /* first point where variable is active */

    this.endpc = NaN;
    /* first point where variable is dead */
  }

}

const RETS = to_luastring("...");
const PRE = to_luastring("[string \"");
const POS = to_luastring("\"]");

const luaO_chunkid = function (source, bufflen) {
  let l = source.length;
  let out;

  if (source[0] === 61
  /* ('=').charCodeAt(0) */
  ) {
      /* 'literal' source */
      if (l < bufflen) {
        /* small enough? */
        out = new Uint8Array(l - 1);
        out.set(source.subarray(1));
      } else {
        /* truncate it */
        out = new Uint8Array(bufflen);
        out.set(source.subarray(1, bufflen + 1));
      }
    } else if (source[0] === 64
  /* ('@').charCodeAt(0) */
  ) {
      /* file name */
      if (l <= bufflen) {
        /* small enough? */
        out = new Uint8Array(l - 1);
        out.set(source.subarray(1));
      } else {
        /* add '...' before rest of name */
        out = new Uint8Array(bufflen);
        out.set(RETS);
        bufflen -= RETS.length;
        out.set(source.subarray(l - bufflen), RETS.length);
      }
    } else {
    /* string; format as [string "source"] */
    out = new Uint8Array(bufflen);
    let nli = luastring_indexOf(source, 10
    /* ('\n').charCodeAt(0) */
    );
    /* find first new line (if any) */

    out.set(PRE);
    /* add prefix */

    let out_i = PRE.length;
    bufflen -= PRE.length + RETS.length + POS.length;
    /* save space for prefix+suffix */

    if (l < bufflen && nli === -1) {
      /* small one-line source? */
      out.set(source, out_i);
      /* keep it */

      out_i += source.length;
    } else {
      if (nli !== -1) l = nli;
      /* stop at first newline */

      if (l > bufflen) l = bufflen;
      out.set(source.subarray(0, l), out_i);
      out_i += l;
      out.set(RETS, out_i);
      out_i += RETS.length;
    }

    out.set(POS, out_i);
    out_i += POS.length;
    out = out.subarray(0, out_i);
  }

  return out;
};

const luaO_hexavalue = function (c) {
  if (lisdigit(c)) return c - 48;else return (c & 0xdf) - 55;
};

const UTF8BUFFSZ = 8;

const luaO_utf8esc = function (buff, x) {
  let n = 1;
  /* number of bytes put in buffer (backwards) */

  lua_assert(x <= 0x10FFFF);
  if (x < 0x80)
    /* ascii? */
    buff[UTF8BUFFSZ - 1] = x;else {
    /* need continuation bytes */
    let mfb = 0x3f;
    /* maximum that fits in first byte */

    do {
      buff[UTF8BUFFSZ - n++] = 0x80 | x & 0x3f;
      x >>= 6;
      /* remove added bits */

      mfb >>= 1;
      /* now there is one less bit available in first byte */
    } while (x > mfb);
    /* still needs continuation byte? */


    buff[UTF8BUFFSZ - n] = ~mfb << 1 | x;
    /* add first byte */
  }
  return n;
};
/* maximum number of significant digits to read (to avoid overflows
   even with single floats) */


const MAXSIGDIG = 30;
/*
** convert an hexadecimal numeric string to a number, following
** C99 specification for 'strtod'
*/

const lua_strx2number = function (s) {
  let i = 0;
  let r = 0.0;
  /* result (accumulator) */

  let sigdig = 0;
  /* number of significant digits */

  let nosigdig = 0;
  /* number of non-significant digits */

  let e = 0;
  /* exponent correction */

  let neg;
  /* 1 if number is negative */

  let hasdot = false;
  /* true after seen a dot */

  while (lisspace(s[i])) i++;
  /* skip initial spaces */


  if (neg = s[i] === 45
  /* ('-').charCodeAt(0) */
  ) i++;
  /* check signal */
  else if (s[i] === 43
    /* ('+').charCodeAt(0) */
    ) i++;
  if (!(s[i] === 48
  /* ('0').charCodeAt(0) */
  && (s[i + 1] === 120
  /* ('x').charCodeAt(0) */
  || s[i + 1] === 88
  /* ('X').charCodeAt(0) */
  )))
    /* check '0x' */
    return null;
  /* invalid format (no '0x') */

  for (i += 2;; i++) {
    /* skip '0x' and read numeral */
    if (s[i] === 46
    /* ('.').charCodeAt(0) i.e. dot/lua_getlocaledecpoint(); */
    ) {
        if (hasdot) break;
        /* second dot? stop loop */
        else hasdot = true;
      } else if (lisxdigit(s[i])) {
      if (sigdig === 0 && s[i] === 48
      /* ('0').charCodeAt(0) */
      )
        /* non-significant digit (zero)? */
        nosigdig++;else if (++sigdig <= MAXSIGDIG)
        /* can read it without overflow? */
        r = r * 16 + luaO_hexavalue(s[i]);else e++;
      /* too many digits; ignore, but still count for exponent */

      if (hasdot) e--;
      /* decimal digit? correct exponent */
    } else break;
    /* neither a dot nor a digit */

  }

  if (nosigdig + sigdig === 0)
    /* no digits? */
    return null;
  /* invalid format */

  e *= 4;
  /* each digit multiplies/divides value by 2^4 */

  if (s[i] === 112
  /* ('p').charCodeAt(0) */
  || s[i] === 80
  /* ('P').charCodeAt(0) */
  ) {
      /* exponent part? */
      let exp1 = 0;
      /* exponent value */

      let neg1;
      /* exponent signal */

      i++;
      /* skip 'p' */

      if (neg1 = s[i] === 45
      /* ('-').charCodeAt(0) */
      ) i++;
      /* signal */
      else if (s[i] === 43
        /* ('+').charCodeAt(0) */
        ) i++;
      if (!lisdigit(s[i])) return null;
      /* invalid; must have at least one digit */

      while (lisdigit(s[i]))
      /* read exponent */
      exp1 = exp1 * 10 + s[i++] - 48
      /* ('0').charCodeAt(0) */
      ;

      if (neg1) exp1 = -exp1;
      e += exp1;
    }

  if (neg) r = -r;
  return {
    n: ldexp(r, e),
    i: i
  };
};

const lua_str2number = function (s) {
  try {
    s = to_jsstring(s);
  } catch (e) {
    return null;
  }
  /* use a regex to validate number and also to get length
     parseFloat ignores trailing junk */


  let r = /^[\t\v\f \n\r]*[+-]?(?:[0-9]+\.?[0-9]*|\.[0-9]*)(?:[eE][+-]?[0-9]+)?/.exec(s);
  if (!r) return null;
  let flt = parseFloat(r[0]);
  return !isNaN(flt) ? {
    n: flt,
    i: r[0].length
  } : null;
};

const l_str2dloc = function (s, mode) {
  let result = mode === 'x' ? lua_strx2number(s) : lua_str2number(s);
  /* try to convert */

  if (result === null) return null;

  while (lisspace(s[result.i])) result.i++;
  /* skip trailing spaces */


  return result.i === s.length || s[result.i] === 0 ? result : null;
  /* OK if no trailing characters */
};

const SIGILS = [46
/* (".").charCodeAt(0) */
, 120
/* ("x").charCodeAt(0) */
, 88
/* ("X").charCodeAt(0) */
, 110
/* ("n").charCodeAt(0) */
, 78
/* ("N").charCodeAt(0) */
];
const modes = {
  [46]: ".",
  [120]: "x",
  [88]: "x",
  [110]: "n",
  [78]: "n"
};

const l_str2d = function (s) {
  let l = s.length;
  let pmode = 0;

  for (let i = 0; i < l; i++) {
    let v = s[i];

    if (SIGILS.indexOf(v) !== -1) {
      pmode = v;
      break;
    }
  }

  let mode = modes[pmode];
  if (mode === 'n')
    /* reject 'inf' and 'nan' */
    return null;
  let end = l_str2dloc(s, mode);
  /* try to convert */
  // if (end === null) {   /* failed? may be a different locale */
  //     throw new Error("Locale not available to handle number"); // TODO
  // }

  return end;
};

const MAXBY10 = Math.floor(MAX_INT / 10);
const MAXLASTD = MAX_INT % 10;

const l_str2int = function (s) {
  let i = 0;
  let a = 0;
  let empty = true;
  let neg;

  while (lisspace(s[i])) i++;
  /* skip initial spaces */


  if (neg = s[i] === 45
  /* ('-').charCodeAt(0) */
  ) i++;else if (s[i] === 43
  /* ('+').charCodeAt(0) */
  ) i++;

  if (s[i] === 48
  /* ('0').charCodeAt(0) */
  && (s[i + 1] === 120
  /* ('x').charCodeAt(0) */
  || s[i + 1] === 88
  /* ('X').charCodeAt(0) */
  )) {
    /* hex? */
    i += 2;
    /* skip '0x' */

    for (; i < s.length && lisxdigit(s[i]); i++) {
      a = a * 16 + luaO_hexavalue(s[i]) | 0;
      empty = false;
    }
  } else {
    /* decimal */
    for (; i < s.length && lisdigit(s[i]); i++) {
      let d = s[i] - 48
      /* ('0').charCodeAt(0) */
      ;
      if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))
        /* overflow? */
        return null;
      /* do not accept it (as integer) */

      a = a * 10 + d | 0;
      empty = false;
    }
  }

  while (i < s.length && lisspace(s[i])) i++;
  /* skip trailing spaces */


  if (empty || i !== s.length && s[i] !== 0) return null;
  /* something wrong in the numeral */
  else {
      return {
        n: (neg ? -a : a) | 0,
        i: i
      };
    }
};

const luaO_str2num = function (s, o) {
  let s2i = l_str2int(s);

  if (s2i !== null) {
    /* try as an integer */
    o.setivalue(s2i.n);
    return s2i.i + 1;
  } else {
    /* else try as a float */
    s2i = l_str2d(s);

    if (s2i !== null) {
      o.setfltvalue(s2i.n);
      return s2i.i + 1;
    } else return 0;
    /* conversion failed */

  }
};

const luaO_tostring = function (L, obj) {
  let buff;
  if (obj.ttisinteger()) buff = to_luastring(lua_integer2str(obj.value));else {
    let str = lua_number2str(obj.value);

    if (!LUA_COMPAT_FLOATSTRING && /^[-0123456789]+$/.test(str)) {
      /* looks like an int? */
      str += '.0';
      /* adds '.0' to result: lua_getlocaledecpoint removed as optimisation */
    }

    buff = to_luastring(str);
  }
  obj.setsvalue(luaS_bless(L, buff));
};

const pushstr = function (L, str) {
  ldo.luaD_inctop(L);
  setsvalue2s(L, L.top - 1, luaS_new(L, str));
};

const luaO_pushvfstring = function (L, fmt, argp) {
  let n = 0;
  let i = 0;
  let a = 0;
  let e;

  for (;;) {
    e = luastring_indexOf(fmt, 37
    /* ('%').charCodeAt(0) */
    , i);
    if (e == -1) break;
    pushstr(L, fmt.subarray(i, e));

    switch (fmt[e + 1]) {
      case 115
      /* ('s').charCodeAt(0) */
      :
        {
          let s = argp[a++];
          if (s === null) s = to_luastring("(null)", true);else {
            s = from_userstring(s);
            /* respect null terminator */

            let i = luastring_indexOf(s, 0);
            if (i !== -1) s = s.subarray(0, i);
          }
          pushstr(L, s);
          break;
        }

      case 99
      /* ('c').charCodeAt(0) */
      :
        {
          let buff = argp[a++];
          if (lisprint(buff)) pushstr(L, luastring_of(buff));else luaO_pushfstring(L, to_luastring("<\\%d>", true), buff);
          break;
        }

      case 100
      /* ('d').charCodeAt(0) */
      :
      case 73
      /* ('I').charCodeAt(0) */
      :
        ldo.luaD_inctop(L);
        L.stack[L.top - 1].setivalue(argp[a++]);
        luaO_tostring(L, L.stack[L.top - 1]);
        break;

      case 102
      /* ('f').charCodeAt(0) */
      :
        ldo.luaD_inctop(L);
        L.stack[L.top - 1].setfltvalue(argp[a++]);
        luaO_tostring(L, L.stack[L.top - 1]);
        break;

      case 112
      /* ('p').charCodeAt(0) */
      :
        {
          let v = argp[a++];

          if (v instanceof lstate.lua_State || v instanceof ltable.Table || v instanceof Udata || v instanceof LClosure || v instanceof CClosure) {
            pushstr(L, to_luastring("0x" + v.id.toString(16)));
          } else {
            switch (typeof v) {
              case "undefined":
                pushstr(L, to_luastring("undefined"));
                break;

              case "number":
                /* before check object as null is an object */
                pushstr(L, to_luastring("Number(" + v + ")"));
                break;

              case "string":
                /* before check object as null is an object */
                pushstr(L, to_luastring("String(" + JSON.stringify(v) + ")"));
                break;

              case "boolean":
                /* before check object as null is an object */
                pushstr(L, to_luastring(v ? "Boolean(true)" : "Boolean(false)"));
                break;

              case "object":
                if (v === null) {
                  /* null is special */
                  pushstr(L, to_luastring("null"));
                  break;
                }

              /* fall through */

              case "function":
                {
                  let id = L.l_G.ids.get(v);

                  if (!id) {
                    id = L.l_G.id_counter++;
                    L.l_G.ids.set(v, id);
                  }

                  pushstr(L, to_luastring("0x" + id.toString(16)));
                  break;
                }

              default:
                /* user provided object. no id available */
                pushstr(L, to_luastring("<id NYI>"));
            }
          }

          break;
        }

      case 85
      /* ('U').charCodeAt(0) */
      :
        {
          let buff = new Uint8Array(UTF8BUFFSZ);
          let l = luaO_utf8esc(buff, argp[a++]);
          pushstr(L, buff.subarray(UTF8BUFFSZ - l));
          break;
        }

      case 37
      /* ('%').charCodeAt(0) */
      :
        pushstr(L, to_luastring("%", true));
        break;

      default:
        ldebug.luaG_runerror(L, to_luastring("invalid option '%%%c' to 'lua_pushfstring'"), fmt[e + 1]);
    }

    n += 2;
    i = e + 2;
  }

  ldo.luaD_checkstack(L, 1);
  pushstr(L, fmt.subarray(i));
  if (n > 0) lvm.luaV_concat(L, n + 1);
  return L.stack[L.top - 1].svalue();
};

const luaO_pushfstring = function (L, fmt, ...argp) {
  return luaO_pushvfstring(L, fmt, argp);
};
/*
** converts an integer to a "floating point byte", represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee !== 0 and (xxx) otherwise.
*/


const luaO_int2fb = function (x) {
  let e = 0;
  /* exponent */

  if (x < 8) return x;

  while (x >= 8 << 4) {
    /* coarse steps */
    x = x + 0xf >> 4;
    /* x = ceil(x / 16) */

    e += 4;
  }

  while (x >= 8 << 1) {
    /* fine steps */
    x = x + 1 >> 1;
    /* x = ceil(x / 2) */

    e++;
  }

  return e + 1 << 3 | x - 8;
};

const intarith = function (L, op, v1, v2) {
  switch (op) {
    case LUA_OPADD:
      return v1 + v2 | 0;

    case LUA_OPSUB:
      return v1 - v2 | 0;

    case LUA_OPMUL:
      return lvm.luaV_imul(v1, v2);

    case LUA_OPMOD:
      return lvm.luaV_mod(L, v1, v2);

    case LUA_OPIDIV:
      return lvm.luaV_div(L, v1, v2);

    case LUA_OPBAND:
      return v1 & v2;

    case LUA_OPBOR:
      return v1 | v2;

    case LUA_OPBXOR:
      return v1 ^ v2;

    case LUA_OPSHL:
      return lvm.luaV_shiftl(v1, v2);

    case LUA_OPSHR:
      return lvm.luaV_shiftl(v1, -v2);

    case LUA_OPUNM:
      return 0 - v1 | 0;

    case LUA_OPBNOT:
      return ~0 ^ v1;

    default:
      lua_assert(0);
  }
};

const numarith = function (L, op, v1, v2) {
  switch (op) {
    case LUA_OPADD:
      return v1 + v2;

    case LUA_OPSUB:
      return v1 - v2;

    case LUA_OPMUL:
      return v1 * v2;

    case LUA_OPDIV:
      return v1 / v2;

    case LUA_OPPOW:
      return Math.pow(v1, v2);

    case LUA_OPIDIV:
      return Math.floor(v1 / v2);

    case LUA_OPUNM:
      return -v1;

    case LUA_OPMOD:
      return luai_nummod(L, v1, v2);

    default:
      lua_assert(0);
  }
};

const luaO_arith = function (L, op, p1, p2, p3) {
  let res = typeof p3 === "number" ? L.stack[p3] : p3;
  /* FIXME */

  switch (op) {
    case LUA_OPBAND:
    case LUA_OPBOR:
    case LUA_OPBXOR:
    case LUA_OPSHL:
    case LUA_OPSHR:
    case LUA_OPBNOT:
      {
        /* operate only on integers */
        let i1, i2;

        if ((i1 = lvm.tointeger(p1)) !== false && (i2 = lvm.tointeger(p2)) !== false) {
          res.setivalue(intarith(L, op, i1, i2));
          return;
        } else break;
        /* go to the end */

      }

    case LUA_OPDIV:
    case LUA_OPPOW:
      {
        /* operate only on floats */
        let n1, n2;

        if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {
          res.setfltvalue(numarith(L, op, n1, n2));
          return;
        } else break;
        /* go to the end */

      }

    default:
      {
        /* other operations */
        let n1, n2;

        if (p1.ttisinteger() && p2.ttisinteger()) {
          res.setivalue(intarith(L, op, p1.value, p2.value));
          return;
        } else if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {
          res.setfltvalue(numarith(L, op, n1, n2));
          return;
        } else break;
        /* go to the end */

      }
  }
  /* could not perform raw operation; try metamethod */


  lua_assert(L !== null);
  /* should not fail when folding (compile time) */

  ltm.luaT_trybinTM(L, p1, p2, p3, op - LUA_OPADD + ltm.TMS.TM_ADD);
};

module.exports.CClosure = CClosure;
module.exports.LClosure = LClosure;
module.exports.LUA_TDEADKEY = LUA_TDEADKEY;
module.exports.LUA_TPROTO = LUA_TPROTO;
module.exports.LocVar = LocVar;
module.exports.TValue = TValue;
module.exports.Udata = Udata;
module.exports.UTF8BUFFSZ = UTF8BUFFSZ;
module.exports.luaO_arith = luaO_arith;
module.exports.luaO_chunkid = luaO_chunkid;
module.exports.luaO_hexavalue = luaO_hexavalue;
module.exports.luaO_int2fb = luaO_int2fb;
module.exports.luaO_pushfstring = luaO_pushfstring;
module.exports.luaO_pushvfstring = luaO_pushvfstring;
module.exports.luaO_str2num = luaO_str2num;
module.exports.luaO_tostring = luaO_tostring;
module.exports.luaO_utf8esc = luaO_utf8esc;
module.exports.numarith = numarith;
module.exports.pushobj2s = pushobj2s;
module.exports.pushsvalue2s = pushsvalue2s;
module.exports.setobjs2s = setobjs2s;
module.exports.setobj2s = setobj2s;
module.exports.setsvalue2s = setsvalue2s;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUAL_BUFFERSIZE
} = __webpack_require__(4);

const {
  LUA_ERRERR,
  LUA_MULTRET,
  LUA_REGISTRYINDEX,
  LUA_SIGNATURE,
  LUA_TBOOLEAN,
  LUA_TLIGHTUSERDATA,
  LUA_TNIL,
  LUA_TNONE,
  LUA_TNUMBER,
  LUA_TSTRING,
  LUA_TTABLE,
  LUA_VERSION_NUM,
  lua_Debug,
  lua_absindex,
  lua_atpanic,
  lua_call,
  lua_checkstack,
  lua_concat,
  lua_copy,
  lua_createtable,
  lua_error,
  lua_getfield,
  lua_getinfo,
  lua_getmetatable,
  lua_getstack,
  lua_gettop,
  lua_insert,
  lua_isinteger,
  lua_isnil,
  lua_isnumber,
  lua_isstring,
  lua_istable,
  lua_len,
  lua_load,
  lua_newstate,
  lua_newtable,
  lua_next,
  lua_pcall,
  lua_pop,
  lua_pushboolean,
  lua_pushcclosure,
  lua_pushcfunction,
  lua_pushfstring,
  lua_pushinteger,
  lua_pushliteral,
  lua_pushlstring,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_pushvfstring,
  lua_rawequal,
  lua_rawget,
  lua_rawgeti,
  lua_rawlen,
  lua_rawseti,
  lua_remove,
  lua_setfield,
  lua_setglobal,
  lua_setmetatable,
  lua_settop,
  lua_toboolean,
  lua_tointeger,
  lua_tointegerx,
  lua_tojsstring,
  lua_tolstring,
  lua_tonumber,
  lua_tonumberx,
  lua_topointer,
  lua_tostring,
  lua_touserdata,
  lua_type,
  lua_typename,
  lua_version
} = __webpack_require__(2);

const {
  from_userstring,
  luastring_eq,
  to_luastring,
  to_uristring
} = __webpack_require__(6);
/* extra error code for 'luaL_loadfilex' */


const LUA_ERRFILE = LUA_ERRERR + 1;
/* key, in the registry, for table of loaded modules */

const LUA_LOADED_TABLE = to_luastring("_LOADED");
/* key, in the registry, for table of preloaded loaders */

const LUA_PRELOAD_TABLE = to_luastring("_PRELOAD");
const LUA_FILEHANDLE = to_luastring("FILE*");
const LUAL_NUMSIZES = 4 * 16 + 8;

const __name = to_luastring("__name");

const __tostring = to_luastring("__tostring");

const empty = new Uint8Array(0);

class luaL_Buffer {
  constructor() {
    this.L = null;
    this.b = empty;
    this.n = 0;
  }

}

const LEVELS1 = 10;
/* size of the first part of the stack */

const LEVELS2 = 11;
/* size of the second part of the stack */

/*
** search for 'objidx' in table at index -1.
** return 1 + string at top if find a good name.
*/

const findfield = function (L, objidx, level) {
  if (level === 0 || !lua_istable(L, -1)) return 0;
  /* not found */

  lua_pushnil(L);
  /* start 'next' loop */

  while (lua_next(L, -2)) {
    /* for each pair in table */
    if (lua_type(L, -2) === LUA_TSTRING) {
      /* ignore non-string keys */
      if (lua_rawequal(L, objidx, -1)) {
        /* found object? */
        lua_pop(L, 1);
        /* remove value (but keep name) */

        return 1;
      } else if (findfield(L, objidx, level - 1)) {
        /* try recursively */
        lua_remove(L, -2);
        /* remove table (but keep name) */

        lua_pushliteral(L, ".");
        lua_insert(L, -2);
        /* place '.' between the two names */

        lua_concat(L, 3);
        return 1;
      }
    }

    lua_pop(L, 1);
    /* remove value */
  }

  return 0;
  /* not found */
};
/*
** Search for a name for a function in all loaded modules
*/


const pushglobalfuncname = function (L, ar) {
  let top = lua_gettop(L);
  lua_getinfo(L, to_luastring("f"), ar);
  /* push function */

  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);

  if (findfield(L, top + 1, 2)) {
    let name = lua_tostring(L, -1);

    if (name[0] === 95
    /* '_'.charCodeAt(0) */
    && name[1] === 71
    /* 'G'.charCodeAt(0) */
    && name[2] === 46
    /* '.'.charCodeAt(0) */
    ) {
        /* name start with '_G.'? */
        lua_pushstring(L, name.subarray(3));
        /* push name without prefix */

        lua_remove(L, -2);
        /* remove original name */
      }

    lua_copy(L, -1, top + 1);
    /* move name to proper place */

    lua_pop(L, 2);
    /* remove pushed values */

    return 1;
  } else {
    lua_settop(L, top);
    /* remove function and global table */

    return 0;
  }
};

const pushfuncname = function (L, ar) {
  if (pushglobalfuncname(L, ar)) {
    /* try first a global name */
    lua_pushfstring(L, to_luastring("function '%s'"), lua_tostring(L, -1));
    lua_remove(L, -2);
    /* remove name */
  } else if (ar.namewhat.length !== 0)
    /* is there a name from code? */
    lua_pushfstring(L, to_luastring("%s '%s'"), ar.namewhat, ar.name);
    /* use it */
  else if (ar.what && ar.what[0] === 109
    /* 'm'.charCodeAt(0) */
    )
      /* main? */
      lua_pushliteral(L, "main chunk");else if (ar.what && ar.what[0] === 76
    /* 'L'.charCodeAt(0) */
    )
      /* for Lua functions, use <file:line> */
      lua_pushfstring(L, to_luastring("function <%s:%d>"), ar.short_src, ar.linedefined);else
      /* nothing left... */
      lua_pushliteral(L, "?");
};

const lastlevel = function (L) {
  let ar = new lua_Debug();
  let li = 1;
  let le = 1;
  /* find an upper bound */

  while (lua_getstack(L, le, ar)) {
    li = le;
    le *= 2;
  }
  /* do a binary search */


  while (li < le) {
    let m = Math.floor((li + le) / 2);
    if (lua_getstack(L, m, ar)) li = m + 1;else le = m;
  }

  return le - 1;
};

const luaL_traceback = function (L, L1, msg, level) {
  let ar = new lua_Debug();
  let top = lua_gettop(L);
  let last = lastlevel(L1);
  let n1 = last - level > LEVELS1 + LEVELS2 ? LEVELS1 : -1;
  if (msg) lua_pushfstring(L, to_luastring("%s\n"), msg);
  luaL_checkstack(L, 10, null);
  lua_pushliteral(L, "stack traceback:");

  while (lua_getstack(L1, level++, ar)) {
    if (n1-- === 0) {
      /* too many levels? */
      lua_pushliteral(L, "\n\t...");
      /* add a '...' */

      level = last - LEVELS2 + 1;
      /* and skip to last ones */
    } else {
      lua_getinfo(L1, to_luastring("Slnt", true), ar);
      lua_pushfstring(L, to_luastring("\n\t%s:"), ar.short_src);
      if (ar.currentline > 0) lua_pushliteral(L, `${ar.currentline}:`);
      lua_pushliteral(L, " in ");
      pushfuncname(L, ar);
      if (ar.istailcall) lua_pushliteral(L, "\n\t(...tail calls..)");
      lua_concat(L, lua_gettop(L) - top);
    }
  }

  lua_concat(L, lua_gettop(L) - top);
};

const panic = function (L) {
  let msg = "PANIC: unprotected error in call to Lua API (" + lua_tojsstring(L, -1) + ")";
  throw new Error(msg);
};

const luaL_argerror = function (L, arg, extramsg) {
  let ar = new lua_Debug();
  if (!lua_getstack(L, 0, ar))
    /* no stack frame? */
    return luaL_error(L, to_luastring("bad argument #%d (%s)"), arg, extramsg);
  lua_getinfo(L, to_luastring("n"), ar);

  if (luastring_eq(ar.namewhat, to_luastring("method"))) {
    arg--;
    /* do not count 'self' */

    if (arg === 0)
      /* error is in the self argument itself? */
      return luaL_error(L, to_luastring("calling '%s' on bad self (%s)"), ar.name, extramsg);
  }

  if (ar.name === null) ar.name = pushglobalfuncname(L, ar) ? lua_tostring(L, -1) : to_luastring("?");
  return luaL_error(L, to_luastring("bad argument #%d to '%s' (%s)"), arg, ar.name, extramsg);
};

const typeerror = function (L, arg, tname) {
  let typearg;
  if (luaL_getmetafield(L, arg, __name) === LUA_TSTRING) typearg = lua_tostring(L, -1);else if (lua_type(L, arg) === LUA_TLIGHTUSERDATA) typearg = to_luastring("light userdata", true);else typearg = luaL_typename(L, arg);
  let msg = lua_pushfstring(L, to_luastring("%s expected, got %s"), tname, typearg);
  return luaL_argerror(L, arg, msg);
};

const luaL_where = function (L, level) {
  let ar = new lua_Debug();

  if (lua_getstack(L, level, ar)) {
    lua_getinfo(L, to_luastring("Sl", true), ar);

    if (ar.currentline > 0) {
      lua_pushfstring(L, to_luastring("%s:%d: "), ar.short_src, ar.currentline);
      return;
    }
  }

  lua_pushstring(L, to_luastring(""));
};

const luaL_error = function (L, fmt, ...argp) {
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  lua_concat(L, 2);
  return lua_error(L);
};
/* Unlike normal lua, we pass in an error object */


const luaL_fileresult = function (L, stat, fname, e) {
  if (stat) {
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lua_pushnil(L);
    let message, errno;

    if (e) {
      message = e.message;
      errno = -e.errno;
    } else {
      message = "Success";
      /* what strerror(0) returns */

      errno = 0;
    }

    if (fname) lua_pushfstring(L, to_luastring("%s: %s"), fname, to_luastring(message));else lua_pushstring(L, to_luastring(message));
    lua_pushinteger(L, errno);
    return 3;
  }
};
/* Unlike normal lua, we pass in an error object */


const luaL_execresult = function (L, e) {
  let what, stat;

  if (e === null) {
    lua_pushboolean(L, 1);
    lua_pushliteral(L, "exit");
    lua_pushinteger(L, 0);
    return 3;
  } else if (e.status) {
    what = "exit";
    stat = e.status;
  } else if (e.signal) {
    what = "signal";
    stat = e.signal;
  } else {
    /* XXX: node seems to have e.errno as a string instead of a number */
    return luaL_fileresult(L, 0, null, e);
  }

  lua_pushnil(L);
  lua_pushliteral(L, what);
  lua_pushinteger(L, stat);
  return 3;
};

const luaL_getmetatable = function (L, n) {
  return lua_getfield(L, LUA_REGISTRYINDEX, n);
};

const luaL_newmetatable = function (L, tname) {
  if (luaL_getmetatable(L, tname) !== LUA_TNIL)
    /* name already in use? */
    return 0;
  /* leave previous value on top, but return 0 */

  lua_pop(L, 1);
  lua_createtable(L, 0, 2);
  /* create metatable */

  lua_pushstring(L, tname);
  lua_setfield(L, -2, __name);
  /* metatable.__name = tname */

  lua_pushvalue(L, -1);
  lua_setfield(L, LUA_REGISTRYINDEX, tname);
  /* registry.name = metatable */

  return 1;
};

const luaL_setmetatable = function (L, tname) {
  luaL_getmetatable(L, tname);
  lua_setmetatable(L, -2);
};

const luaL_testudata = function (L, ud, tname) {
  let p = lua_touserdata(L, ud);

  if (p !== null) {
    /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {
      /* does it have a metatable? */
      luaL_getmetatable(L, tname);
      /* get correct metatable */

      if (!lua_rawequal(L, -1, -2))
        /* not the same? */
        p = null;
      /* value is a userdata with wrong metatable */

      lua_pop(L, 2);
      /* remove both metatables */

      return p;
    }
  }

  return null;
  /* value is not a userdata with a metatable */
};

const luaL_checkudata = function (L, ud, tname) {
  let p = luaL_testudata(L, ud, tname);
  if (p === null) typeerror(L, ud, tname);
  return p;
};

const luaL_checkoption = function (L, arg, def, lst) {
  let name = def !== null ? luaL_optstring(L, arg, def) : luaL_checkstring(L, arg);

  for (let i = 0; lst[i]; i++) if (luastring_eq(lst[i], name)) return i;

  return luaL_argerror(L, arg, lua_pushfstring(L, to_luastring("invalid option '%s'"), name));
};

const tag_error = function (L, arg, tag) {
  typeerror(L, arg, lua_typename(L, tag));
};

const luaL_newstate = function () {
  let L = lua_newstate();
  if (L) lua_atpanic(L, panic);
  return L;
};

const luaL_typename = function (L, i) {
  return lua_typename(L, lua_type(L, i));
};

const luaL_argcheck = function (L, cond, arg, extramsg) {
  if (!cond) luaL_argerror(L, arg, extramsg);
};

const luaL_checkany = function (L, arg) {
  if (lua_type(L, arg) === LUA_TNONE) luaL_argerror(L, arg, to_luastring("value expected", true));
};

const luaL_checktype = function (L, arg, t) {
  if (lua_type(L, arg) !== t) tag_error(L, arg, t);
};

const luaL_checklstring = function (L, arg) {
  let s = lua_tolstring(L, arg);
  if (s === null || s === undefined) tag_error(L, arg, LUA_TSTRING);
  return s;
};

const luaL_checkstring = luaL_checklstring;

const luaL_optlstring = function (L, arg, def) {
  if (lua_type(L, arg) <= 0) {
    return def === null ? null : from_userstring(def);
  } else return luaL_checklstring(L, arg);
};

const luaL_optstring = luaL_optlstring;

const interror = function (L, arg) {
  if (lua_isnumber(L, arg)) luaL_argerror(L, arg, to_luastring("number has no integer representation", true));else tag_error(L, arg, LUA_TNUMBER);
};

const luaL_checknumber = function (L, arg) {
  let d = lua_tonumberx(L, arg);
  if (d === false) tag_error(L, arg, LUA_TNUMBER);
  return d;
};

const luaL_optnumber = function (L, arg, def) {
  return luaL_opt(L, luaL_checknumber, arg, def);
};

const luaL_checkinteger = function (L, arg) {
  let d = lua_tointegerx(L, arg);
  if (d === false) interror(L, arg);
  return d;
};

const luaL_optinteger = function (L, arg, def) {
  return luaL_opt(L, luaL_checkinteger, arg, def);
};

const luaL_prepbuffsize = function (B, sz) {
  let newend = B.n + sz;

  if (B.b.length < newend) {
    let newsize = Math.max(B.b.length * 2, newend);
    /* double buffer size */

    let newbuff = new Uint8Array(newsize);
    /* create larger buffer */

    newbuff.set(B.b);
    /* copy original content */

    B.b = newbuff;
  }

  return B.b.subarray(B.n, newend);
};

const luaL_buffinit = function (L, B) {
  B.L = L;
  B.b = empty;
};

const luaL_buffinitsize = function (L, B, sz) {
  luaL_buffinit(L, B);
  return luaL_prepbuffsize(B, sz);
};

const luaL_prepbuffer = function (B) {
  return luaL_prepbuffsize(B, LUAL_BUFFERSIZE);
};

const luaL_addlstring = function (B, s, l) {
  if (l > 0) {
    s = from_userstring(s);
    let b = luaL_prepbuffsize(B, l);
    b.set(s.subarray(0, l));
    luaL_addsize(B, l);
  }
};

const luaL_addstring = function (B, s) {
  s = from_userstring(s);
  luaL_addlstring(B, s, s.length);
};

const luaL_pushresult = function (B) {
  lua_pushlstring(B.L, B.b, B.n);
  /* delete old buffer */

  B.n = 0;
  B.b = empty;
};

const luaL_addchar = function (B, c) {
  luaL_prepbuffsize(B, 1);
  B.b[B.n++] = c;
};

const luaL_addsize = function (B, s) {
  B.n += s;
};

const luaL_pushresultsize = function (B, sz) {
  luaL_addsize(B, sz);
  luaL_pushresult(B);
};

const luaL_addvalue = function (B) {
  let L = B.L;
  let s = lua_tostring(L, -1);
  luaL_addlstring(B, s, s.length);
  lua_pop(L, 1);
  /* remove value */
};

const luaL_opt = function (L, f, n, d) {
  return lua_type(L, n) <= 0 ? d : f(L, n);
};

const getS = function (L, ud) {
  let s = ud.string;
  ud.string = null;
  return s;
};

const luaL_loadbufferx = function (L, buff, size, name, mode) {
  return lua_load(L, getS, {
    string: buff
  }, name, mode);
};

const luaL_loadbuffer = function (L, s, sz, n) {
  return luaL_loadbufferx(L, s, sz, n, null);
};

const luaL_loadstring = function (L, s) {
  return luaL_loadbuffer(L, s, s.length, s);
};

const luaL_dostring = function (L, s) {
  return luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0);
};

const luaL_getmetafield = function (L, obj, event) {
  if (!lua_getmetatable(L, obj))
    /* no metatable? */
    return LUA_TNIL;else {
    lua_pushstring(L, event);
    let tt = lua_rawget(L, -2);
    if (tt === LUA_TNIL)
      /* is metafield nil? */
      lua_pop(L, 2);
      /* remove metatable and metafield */
    else lua_remove(L, -2);
    /* remove only metatable */

    return tt;
    /* return metafield type */
  }
};

const luaL_callmeta = function (L, obj, event) {
  obj = lua_absindex(L, obj);
  if (luaL_getmetafield(L, obj, event) === LUA_TNIL) return false;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return true;
};

const luaL_len = function (L, idx) {
  lua_len(L, idx);
  let l = lua_tointegerx(L, -1);
  if (l === false) luaL_error(L, to_luastring("object length is not an integer", true));
  lua_pop(L, 1);
  /* remove object */

  return l;
};

const p_I = to_luastring("%I");
const p_f = to_luastring("%f");

const luaL_tolstring = function (L, idx) {
  if (luaL_callmeta(L, idx, __tostring)) {
    if (!lua_isstring(L, -1)) luaL_error(L, to_luastring("'__tostring' must return a string"));
  } else {
    let t = lua_type(L, idx);

    switch (t) {
      case LUA_TNUMBER:
        {
          if (lua_isinteger(L, idx)) lua_pushfstring(L, p_I, lua_tointeger(L, idx));else lua_pushfstring(L, p_f, lua_tonumber(L, idx));
          break;
        }

      case LUA_TSTRING:
        lua_pushvalue(L, idx);
        break;

      case LUA_TBOOLEAN:
        lua_pushliteral(L, lua_toboolean(L, idx) ? "true" : "false");
        break;

      case LUA_TNIL:
        lua_pushliteral(L, "nil");
        break;

      default:
        {
          let tt = luaL_getmetafield(L, idx, __name);
          let kind = tt === LUA_TSTRING ? lua_tostring(L, -1) : luaL_typename(L, idx);
          lua_pushfstring(L, to_luastring("%s: %p"), kind, lua_topointer(L, idx));
          if (tt !== LUA_TNIL) lua_remove(L, -2);
          break;
        }
    }
  }

  return lua_tolstring(L, -1);
};
/*
** Stripped-down 'require': After checking "loaded" table, calls 'openf'
** to open a module, registers the result in 'package.loaded' table and,
** if 'glb' is true, also registers the result in the global table.
** Leaves resulting module on the top.
*/


const luaL_requiref = function (L, modname, openf, glb) {
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_getfield(L, -1, modname);
  /* LOADED[modname] */

  if (!lua_toboolean(L, -1)) {
    /* package not already loaded? */
    lua_pop(L, 1);
    /* remove field */

    lua_pushcfunction(L, openf);
    lua_pushstring(L, modname);
    /* argument to open function */

    lua_call(L, 1, 1);
    /* call 'openf' to open module */

    lua_pushvalue(L, -1);
    /* make copy of module (call result) */

    lua_setfield(L, -3, modname);
    /* LOADED[modname] = module */
  }

  lua_remove(L, -2);
  /* remove LOADED table */

  if (glb) {
    lua_pushvalue(L, -1);
    /* copy of module */

    lua_setglobal(L, modname);
    /* _G[modname] = module */
  }
};

const find_subarray = function (arr, subarr, from_index) {
  var i = from_index >>> 0,
      sl = subarr.length,
      l = arr.length + 1 - sl;

  loop: for (; i < l; i++) {
    for (let j = 0; j < sl; j++) if (arr[i + j] !== subarr[j]) continue loop;

    return i;
  }

  return -1;
};

const luaL_gsub = function (L, s, p, r) {
  let wild;
  let b = new luaL_Buffer();
  luaL_buffinit(L, b);

  while ((wild = find_subarray(s, p)) >= 0) {
    luaL_addlstring(b, s, wild);
    /* push prefix */

    luaL_addstring(b, r);
    /* push replacement in place of pattern */

    s = s.subarray(wild + p.length);
    /* continue after 'p' */
  }

  luaL_addstring(b, s);
  /* push last suffix */

  luaL_pushresult(b);
  return lua_tostring(L, -1);
};
/*
** ensure that stack[idx][fname] has a table and push that table
** into the stack
*/


const luaL_getsubtable = function (L, idx, fname) {
  if (lua_getfield(L, idx, fname) === LUA_TTABLE) return true;
  /* table already there */
  else {
      lua_pop(L, 1);
      /* remove previous result */

      idx = lua_absindex(L, idx);
      lua_newtable(L);
      lua_pushvalue(L, -1);
      /* copy to be left at top */

      lua_setfield(L, idx, fname);
      /* assign new table to field */

      return false;
      /* false, because did not find table there */
    }
};
/*
** set functions from list 'l' into table at top - 'nup'; each
** function gets the 'nup' elements at the top as upvalues.
** Returns with only the table at the stack.
*/


const luaL_setfuncs = function (L, l, nup) {
  luaL_checkstack(L, nup, to_luastring("too many upvalues", true));

  for (let lib in l) {
    /* fill the table with given functions */
    for (let i = 0; i < nup; i++)
    /* copy upvalues to the top */
    lua_pushvalue(L, -nup);

    lua_pushcclosure(L, l[lib], nup);
    /* closure with those upvalues */

    lua_setfield(L, -(nup + 2), to_luastring(lib));
  }

  lua_pop(L, nup);
  /* remove upvalues */
};
/*
** Ensures the stack has at least 'space' extra slots, raising an error
** if it cannot fulfill the request. (The error handling needs a few
** extra slots to format the error message. In case of an error without
** this extra space, Lua will generate the same 'stack overflow' error,
** but without 'msg'.)
*/


const luaL_checkstack = function (L, space, msg) {
  if (!lua_checkstack(L, space)) {
    if (msg) luaL_error(L, to_luastring("stack overflow (%s)"), msg);else luaL_error(L, to_luastring('stack overflow', true));
  }
};

const luaL_newlibtable = function (L) {
  lua_createtable(L);
};

const luaL_newlib = function (L, l) {
  lua_createtable(L);
  luaL_setfuncs(L, l, 0);
};
/* predefined references */


const LUA_NOREF = -2;
const LUA_REFNIL = -1;

const luaL_ref = function (L, t) {
  let ref;

  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);
    /* remove from stack */

    return LUA_REFNIL;
    /* 'nil' has a unique fixed reference */
  }

  t = lua_absindex(L, t);
  lua_rawgeti(L, t, 0);
  /* get first free element */

  ref = lua_tointeger(L, -1);
  /* ref = t[freelist] */

  lua_pop(L, 1);
  /* remove it from stack */

  if (ref !== 0) {
    /* any free element? */
    lua_rawgeti(L, t, ref);
    /* remove it from list */

    lua_rawseti(L, t, 0);
    /* (t[freelist] = t[ref]) */
  } else
    /* no free elements */
    ref = lua_rawlen(L, t) + 1;
  /* get a new reference */


  lua_rawseti(L, t, ref);
  return ref;
};

const luaL_unref = function (L, t, ref) {
  if (ref >= 0) {
    t = lua_absindex(L, t);
    lua_rawgeti(L, t, 0);
    lua_rawseti(L, t, ref);
    /* t[ref] = t[freelist] */

    lua_pushinteger(L, ref);
    lua_rawseti(L, t, 0);
    /* t[freelist] = ref */
  }
};

const errfile = function (L, what, fnameindex, error) {
  let serr = error.message;
  let filename = lua_tostring(L, fnameindex).subarray(1);
  lua_pushfstring(L, to_luastring("cannot %s %s: %s"), to_luastring(what), filename, to_luastring(serr));
  lua_remove(L, fnameindex);
  return LUA_ERRFILE;
};

let getc;
const utf8_bom = [0XEF, 0XBB, 0XBF];
/* UTF-8 BOM mark */

const skipBOM = function (lf) {
  lf.n = 0;
  let c;
  let p = 0;

  do {
    c = getc(lf);
    if (c === null || c !== utf8_bom[p]) return c;
    p++;
    lf.buff[lf.n++] = c;
    /* to be read by the parser */
  } while (p < utf8_bom.length);

  lf.n = 0;
  /* prefix matched; discard it */

  return getc(lf);
  /* return next character */
};
/*
** reads the first character of file 'f' and skips an optional BOM mark
** in its beginning plus its first line if it starts with '#'. Returns
** true if it skipped the first line.  In any case, '*cp' has the
** first "valid" character of the file (after the optional BOM and
** a first-line comment).
*/


const skipcomment = function (lf) {
  let c = skipBOM(lf);

  if (c === 35
  /* '#'.charCodeAt(0) */
  ) {
      /* first line is a comment (Unix exec. file)? */
      do {
        /* skip first line */
        c = getc(lf);
      } while (c && c !== 10
      /* '\n'.charCodeAt(0) */
      );

      return {
        skipped: true,
        c: getc(lf)
        /* skip end-of-line, if present */

      };
    } else {
    return {
      skipped: false,
      c: c
    };
  }
};

let luaL_loadfilex;

if (true) {
  class LoadF {
    constructor() {
      this.n = NaN;
      /* number of pre-read characters */

      this.f = null;
      /* file being read */

      this.buff = new Uint8Array(1024);
      /* area for reading file */

      this.pos = 0;
      /* current position in file */

      this.err = void 0;
    }

  }

  const getF = function (L, ud) {
    let lf = ud;

    if (lf.f !== null && lf.n > 0) {
      /* are there pre-read characters to be read? */
      let bytes = lf.n;
      /* return them (chars already in buffer) */

      lf.n = 0;
      /* no more pre-read characters */

      lf.f = lf.f.subarray(lf.pos);
      /* we won't use lf.buff anymore */

      return lf.buff.subarray(0, bytes);
    }

    let f = lf.f;
    lf.f = null;
    return f;
  };

  getc = function (lf) {
    return lf.pos < lf.f.length ? lf.f[lf.pos++] : null;
  };

  luaL_loadfilex = function (L, filename, mode) {
    let lf = new LoadF();
    let fnameindex = lua_gettop(L) + 1;
    /* index of filename on the stack */

    if (filename === null) {
      throw new Error("Can't read stdin in the browser");
    } else {
      lua_pushfstring(L, to_luastring("@%s"), filename);
      let path = to_uristring(filename);
      let xhr = new XMLHttpRequest();
      xhr.open("GET", path, false);
      /*
      Synchronous xhr in main thread always returns a js string.
      Some browsers make console noise if you even attempt to set responseType
      */

      if (typeof window === "undefined") {
        xhr.responseType = "arraybuffer";
      }

      xhr.send();

      if (xhr.status >= 200 && xhr.status <= 299) {
        if (typeof xhr.response === "string") {
          lf.f = to_luastring(xhr.response);
        } else {
          lf.f = new Uint8Array(xhr.response);
        }
      } else {
        lf.err = xhr.status;
        return errfile(L, "open", fnameindex, {
          message: `${xhr.status}: ${xhr.statusText}`
        });
      }
    }

    let com = skipcomment(lf);
    /* check for signature first, as we don't want to add line number corrections in binary case */

    if (com.c === LUA_SIGNATURE[0] && filename) {
      /* binary file? */

      /* no need to re-open */
    } else if (com.skipped) {
      /* read initial portion */
      lf.buff[lf.n++] = 10
      /* '\n'.charCodeAt(0) */
      ;
      /* add line to correct line numbers */
    }

    if (com.c !== null) lf.buff[lf.n++] = com.c;
    /* 'c' is the first character of the stream */

    let status = lua_load(L, getF, lf, lua_tostring(L, -1), mode);
    let readstatus = lf.err;

    if (readstatus) {
      lua_settop(L, fnameindex);
      /* ignore results from 'lua_load' */

      return errfile(L, "read", fnameindex, readstatus);
    }

    lua_remove(L, fnameindex);
    return status;
  };
} else {}

const luaL_loadfile = function (L, filename) {
  return luaL_loadfilex(L, filename, null);
};

const luaL_dofile = function (L, filename) {
  return luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0);
};

const lua_writestringerror = function () {
  for (let i = 0; i < arguments.length; i++) {
    let a = arguments[i];

    if (true) {
      /* split along new lines for separate console.error invocations */
      do {
        /* regexp uses [\d\D] to work around matching new lines
           the 's' flag is non-standard */
        let r = /([^\n]*)\n?([\d\D]*)/.exec(a);
        console.error(r[1]);
        a = r[2];
      } while (a !== "");
    } else {}
  }
};

const luaL_checkversion_ = function (L, ver, sz) {
  let v = lua_version(L);
  if (sz != LUAL_NUMSIZES)
    /* check numeric types */
    luaL_error(L, to_luastring("core and library have incompatible numeric types"));
  if (v != lua_version(null)) luaL_error(L, to_luastring("multiple Lua VMs detected"));else if (v !== ver) luaL_error(L, to_luastring("version mismatch: app. needs %f, Lua core provides %f"), ver, v);
};
/* There is no point in providing this function... */


const luaL_checkversion = function (L) {
  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES);
};

module.exports.LUA_ERRFILE = LUA_ERRFILE;
module.exports.LUA_FILEHANDLE = LUA_FILEHANDLE;
module.exports.LUA_LOADED_TABLE = LUA_LOADED_TABLE;
module.exports.LUA_NOREF = LUA_NOREF;
module.exports.LUA_PRELOAD_TABLE = LUA_PRELOAD_TABLE;
module.exports.LUA_REFNIL = LUA_REFNIL;
module.exports.luaL_Buffer = luaL_Buffer;
module.exports.luaL_addchar = luaL_addchar;
module.exports.luaL_addlstring = luaL_addlstring;
module.exports.luaL_addsize = luaL_addsize;
module.exports.luaL_addstring = luaL_addstring;
module.exports.luaL_addvalue = luaL_addvalue;
module.exports.luaL_argcheck = luaL_argcheck;
module.exports.luaL_argerror = luaL_argerror;
module.exports.luaL_buffinit = luaL_buffinit;
module.exports.luaL_buffinitsize = luaL_buffinitsize;
module.exports.luaL_callmeta = luaL_callmeta;
module.exports.luaL_checkany = luaL_checkany;
module.exports.luaL_checkinteger = luaL_checkinteger;
module.exports.luaL_checklstring = luaL_checklstring;
module.exports.luaL_checknumber = luaL_checknumber;
module.exports.luaL_checkoption = luaL_checkoption;
module.exports.luaL_checkstack = luaL_checkstack;
module.exports.luaL_checkstring = luaL_checkstring;
module.exports.luaL_checktype = luaL_checktype;
module.exports.luaL_checkudata = luaL_checkudata;
module.exports.luaL_checkversion = luaL_checkversion;
module.exports.luaL_checkversion_ = luaL_checkversion_;
module.exports.luaL_dofile = luaL_dofile;
module.exports.luaL_dostring = luaL_dostring;
module.exports.luaL_error = luaL_error;
module.exports.luaL_execresult = luaL_execresult;
module.exports.luaL_fileresult = luaL_fileresult;
module.exports.luaL_getmetafield = luaL_getmetafield;
module.exports.luaL_getmetatable = luaL_getmetatable;
module.exports.luaL_getsubtable = luaL_getsubtable;
module.exports.luaL_gsub = luaL_gsub;
module.exports.luaL_len = luaL_len;
module.exports.luaL_loadbuffer = luaL_loadbuffer;
module.exports.luaL_loadbufferx = luaL_loadbufferx;
module.exports.luaL_loadfile = luaL_loadfile;
module.exports.luaL_loadfilex = luaL_loadfilex;
module.exports.luaL_loadstring = luaL_loadstring;
module.exports.luaL_newlib = luaL_newlib;
module.exports.luaL_newlibtable = luaL_newlibtable;
module.exports.luaL_newmetatable = luaL_newmetatable;
module.exports.luaL_newstate = luaL_newstate;
module.exports.luaL_opt = luaL_opt;
module.exports.luaL_optinteger = luaL_optinteger;
module.exports.luaL_optlstring = luaL_optlstring;
module.exports.luaL_optnumber = luaL_optnumber;
module.exports.luaL_optstring = luaL_optstring;
module.exports.luaL_prepbuffer = luaL_prepbuffer;
module.exports.luaL_prepbuffsize = luaL_prepbuffsize;
module.exports.luaL_pushresult = luaL_pushresult;
module.exports.luaL_pushresultsize = luaL_pushresultsize;
module.exports.luaL_ref = luaL_ref;
module.exports.luaL_requiref = luaL_requiref;
module.exports.luaL_setfuncs = luaL_setfuncs;
module.exports.luaL_setmetatable = luaL_setmetatable;
module.exports.luaL_testudata = luaL_testudata;
module.exports.luaL_tolstring = luaL_tolstring;
module.exports.luaL_traceback = luaL_traceback;
module.exports.luaL_typename = luaL_typename;
module.exports.luaL_unref = luaL_unref;
module.exports.luaL_where = luaL_where;
module.exports.lua_writestringerror = lua_writestringerror;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_HOOKCALL,
  LUA_HOOKRET,
  LUA_HOOKTAILCALL,
  LUA_MASKCALL,
  LUA_MASKLINE,
  LUA_MASKRET,
  LUA_MINSTACK,
  LUA_MULTRET,
  LUA_SIGNATURE,
  constant_types: {
    LUA_TCCL,
    LUA_TLCF,
    LUA_TLCL,
    LUA_TNIL
  },
  thread_status: {
    LUA_ERRMEM,
    LUA_ERRERR,
    LUA_ERRRUN,
    LUA_ERRSYNTAX,
    LUA_OK,
    LUA_YIELD
  },
  lua_Debug,
  luastring_indexOf,
  to_luastring
} = __webpack_require__(1);

const lapi = __webpack_require__(22);

const ldebug = __webpack_require__(12);

const lfunc = __webpack_require__(14);

const {
  api_check,
  lua_assert,
  LUAI_MAXCCALLS
} = __webpack_require__(5);

const lobject = __webpack_require__(7);

const lopcodes = __webpack_require__(17);

const lparser = __webpack_require__(34);

const lstate = __webpack_require__(13);

const {
  luaS_newliteral
} = __webpack_require__(11);

const ltm = __webpack_require__(15);

const {
  LUAI_MAXSTACK
} = __webpack_require__(4);

const lundump = __webpack_require__(65);

const lvm = __webpack_require__(16);

const {
  MBuffer
} = __webpack_require__(23);

const adjust_top = function (L, newtop) {
  if (L.top < newtop) {
    while (L.top < newtop) L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);
  } else {
    while (L.top > newtop) delete L.stack[--L.top];
  }
};

const seterrorobj = function (L, errcode, oldtop) {
  let current_top = L.top;
  /* extend stack so that L.stack[oldtop] is sure to exist */

  while (L.top < oldtop + 1) L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);

  switch (errcode) {
    case LUA_ERRMEM:
      {
        lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, "not enough memory"));
        break;
      }

    case LUA_ERRERR:
      {
        lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
        break;
      }

    default:
      {
        lobject.setobjs2s(L, oldtop, current_top - 1);
      }
  }

  while (L.top > oldtop + 1) delete L.stack[--L.top];
};

const ERRORSTACKSIZE = LUAI_MAXSTACK + 200;

const luaD_reallocstack = function (L, newsize) {
  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
  lua_assert(L.stack_last == L.stack.length - lstate.EXTRA_STACK);
  L.stack.length = newsize;
  L.stack_last = newsize - lstate.EXTRA_STACK;
};

const luaD_growstack = function (L, n) {
  let size = L.stack.length;
  if (size > LUAI_MAXSTACK) luaD_throw(L, LUA_ERRERR);else {
    let needed = L.top + n + lstate.EXTRA_STACK;
    let newsize = 2 * size;
    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
    if (newsize < needed) newsize = needed;

    if (newsize > LUAI_MAXSTACK) {
      /* stack overflow? */
      luaD_reallocstack(L, ERRORSTACKSIZE);
      ldebug.luaG_runerror(L, to_luastring("stack overflow", true));
    } else luaD_reallocstack(L, newsize);
  }
};

const luaD_checkstack = function (L, n) {
  if (L.stack_last - L.top <= n) luaD_growstack(L, n);
};

const stackinuse = function (L) {
  let lim = L.top;

  for (let ci = L.ci; ci !== null; ci = ci.previous) {
    if (lim < ci.top) lim = ci.top;
  }

  lua_assert(lim <= L.stack_last);
  return lim + 1;
  /* part of stack in use */
};

const luaD_shrinkstack = function (L) {
  let inuse = stackinuse(L);
  let goodsize = inuse + Math.floor(inuse / 8) + 2 * lstate.EXTRA_STACK;
  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
  /* respect stack limit */

  if (L.stack.length > LUAI_MAXSTACK)
    /* had been handling stack overflow? */
    lstate.luaE_freeCI(L);
  /* free all CIs (list grew because of an error) */

  /* if thread is currently not handling a stack overflow and its
   good size is smaller than current size, shrink its stack */

  if (inuse <= LUAI_MAXSTACK - lstate.EXTRA_STACK && goodsize < L.stack.length) luaD_reallocstack(L, goodsize);
};

const luaD_inctop = function (L) {
  luaD_checkstack(L, 1);
  L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);
};
/*
** Prepares a function call: checks the stack, creates a new CallInfo
** entry, fills in the relevant information, calls hook if needed.
** If function is a JS function, does the call, too. (Otherwise, leave
** the execution ('luaV_execute') to the caller, to allow stackless
** calls.) Returns true iff function has been executed (JS function).
*/


const luaD_precall = function (L, off, nresults) {
  let func = L.stack[off];

  switch (func.type) {
    case LUA_TCCL:
    case LUA_TLCF:
      {
        let f = func.type === LUA_TCCL ? func.value.f : func.value;
        luaD_checkstack(L, LUA_MINSTACK);
        let ci = lstate.luaE_extendCI(L);
        ci.funcOff = off;
        ci.nresults = nresults;
        ci.func = func;
        ci.top = L.top + LUA_MINSTACK;
        lua_assert(ci.top <= L.stack_last);
        ci.callstatus = 0;
        if (L.hookmask & LUA_MASKCALL) luaD_hook(L, LUA_HOOKCALL, -1);
        let n = f(L);
        /* do the actual call */

        if (typeof n !== "number" || n < 0 || (n | 0) !== n) throw Error("invalid return value from JS function (expected integer)");
        lapi.api_checknelems(L, n);
        luaD_poscall(L, ci, L.top - n, n);
        return true;
      }

    case LUA_TLCL:
      {
        let base;
        let p = func.value.p;
        let n = L.top - off - 1;
        let fsize = p.maxstacksize;
        luaD_checkstack(L, fsize);

        if (p.is_vararg) {
          base = adjust_varargs(L, p, n);
        } else {
          for (; n < p.numparams; n++) L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null); // complete missing arguments


          base = off + 1;
        }

        let ci = lstate.luaE_extendCI(L);
        ci.funcOff = off;
        ci.nresults = nresults;
        ci.func = func;
        ci.l_base = base;
        ci.top = base + fsize;
        adjust_top(L, ci.top);
        ci.l_code = p.code;
        ci.l_savedpc = 0;
        ci.callstatus = lstate.CIST_LUA;
        if (L.hookmask & LUA_MASKCALL) callhook(L, ci);
        return false;
      }

    default:
      luaD_checkstack(L, 1);
      tryfuncTM(L, off, func);
      return luaD_precall(L, off, nresults);
  }
};

const luaD_poscall = function (L, ci, firstResult, nres) {
  let wanted = ci.nresults;

  if (L.hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
    if (L.hookmask & LUA_MASKRET) luaD_hook(L, LUA_HOOKRET, -1);
    L.oldpc = ci.previous.l_savedpc;
    /* 'oldpc' for caller function */
  }

  let res = ci.funcOff;
  L.ci = ci.previous;
  L.ci.next = null;
  return moveresults(L, firstResult, res, nres, wanted);
};

const moveresults = function (L, firstResult, res, nres, wanted) {
  switch (wanted) {
    case 0:
      break;

    case 1:
      {
        if (nres === 0) L.stack[res].setnilvalue();else {
          lobject.setobjs2s(L, res, firstResult);
          /* move it to proper place */
        }
        break;
      }

    case LUA_MULTRET:
      {
        for (let i = 0; i < nres; i++) lobject.setobjs2s(L, res + i, firstResult + i);

        for (let i = L.top; i >= res + nres; i--) delete L.stack[i];

        L.top = res + nres;
        return false;
      }

    default:
      {
        let i;

        if (wanted <= nres) {
          for (i = 0; i < wanted; i++) lobject.setobjs2s(L, res + i, firstResult + i);
        } else {
          for (i = 0; i < nres; i++) lobject.setobjs2s(L, res + i, firstResult + i);

          for (; i < wanted; i++) {
            if (res + i >= L.top) L.stack[res + i] = new lobject.TValue(LUA_TNIL, null);else L.stack[res + i].setnilvalue();
          }
        }

        break;
      }
  }

  let newtop = res + wanted;
  /* top points after the last result */

  for (let i = L.top; i >= newtop; i--) delete L.stack[i];

  L.top = newtop;
  return true;
};
/*
** Call a hook for the given event. Make sure there is a hook to be
** called. (Both 'L->hook' and 'L->hookmask', which triggers this
** function, can be changed asynchronously by signals.)
*/


const luaD_hook = function (L, event, line) {
  let hook = L.hook;

  if (hook && L.allowhook) {
    /* make sure there is a hook */
    let ci = L.ci;
    let top = L.top;
    let ci_top = ci.top;
    let ar = new lua_Debug();
    ar.event = event;
    ar.currentline = line;
    ar.i_ci = ci;
    luaD_checkstack(L, LUA_MINSTACK);
    /* ensure minimum stack size */

    ci.top = L.top + LUA_MINSTACK;
    lua_assert(ci.top <= L.stack_last);
    L.allowhook = 0;
    /* cannot call hooks inside a hook */

    ci.callstatus |= lstate.CIST_HOOKED;
    hook(L, ar);
    lua_assert(!L.allowhook);
    L.allowhook = 1;
    ci.top = ci_top;
    adjust_top(L, top);
    ci.callstatus &= ~lstate.CIST_HOOKED;
  }
};

const callhook = function (L, ci) {
  let hook = LUA_HOOKCALL;
  ci.l_savedpc++;
  /* hooks assume 'pc' is already incremented */

  if (ci.previous.callstatus & lstate.CIST_LUA && ci.previous.l_code[ci.previous.l_savedpc - 1].opcode == lopcodes.OpCodesI.OP_TAILCALL) {
    ci.callstatus |= lstate.CIST_TAIL;
    hook = LUA_HOOKTAILCALL;
  }

  luaD_hook(L, hook, -1);
  ci.l_savedpc--;
  /* correct 'pc' */
};

const adjust_varargs = function (L, p, actual) {
  let nfixargs = p.numparams;
  /* move fixed parameters to final position */

  let fixed = L.top - actual;
  /* first fixed argument */

  let base = L.top;
  /* final position of first argument */

  let i;

  for (i = 0; i < nfixargs && i < actual; i++) {
    lobject.pushobj2s(L, L.stack[fixed + i]);
    L.stack[fixed + i].setnilvalue();
  }

  for (; i < nfixargs; i++) L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);

  return base;
};

const tryfuncTM = function (L, off, func) {
  let tm = ltm.luaT_gettmbyobj(L, func, ltm.TMS.TM_CALL);
  if (!tm.ttisfunction(tm)) ldebug.luaG_typeerror(L, func, to_luastring("call", true));
  /* Open a hole inside the stack at 'func' */

  lobject.pushobj2s(L, L.stack[L.top - 1]);
  /* push top of stack again */

  for (let p = L.top - 2; p > off; p--) lobject.setobjs2s(L, p, p - 1);
  /* move other items up one */


  lobject.setobj2s(L, off, tm);
  /* tag method is the new function to be called */
};
/*
** Check appropriate error for stack overflow ("regular" overflow or
** overflow while handling stack overflow). If 'nCalls' is larger than
** LUAI_MAXCCALLS (which means it is handling a "regular" overflow) but
** smaller than 9/8 of LUAI_MAXCCALLS, does not report an error (to
** allow overflow handling to work)
*/


const stackerror = function (L) {
  if (L.nCcalls === LUAI_MAXCCALLS) ldebug.luaG_runerror(L, to_luastring("JS stack overflow", true));else if (L.nCcalls >= LUAI_MAXCCALLS + (LUAI_MAXCCALLS >> 3)) luaD_throw(L, LUA_ERRERR);
  /* error while handing stack error */
};
/*
** Call a function (JS or Lua). The function to be called is at func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/


const luaD_call = function (L, off, nResults) {
  if (++L.nCcalls >= LUAI_MAXCCALLS) stackerror(L);
  if (!luaD_precall(L, off, nResults)) lvm.luaV_execute(L);
  L.nCcalls--;
};

const luaD_throw = function (L, errcode) {
  if (L.errorJmp) {
    /* thread has an error handler? */
    L.errorJmp.status = errcode;
    /* set status */

    throw L.errorJmp;
  } else {
    /* thread has no error handler */
    let g = L.l_G;
    L.status = errcode;
    /* mark it as dead */

    if (g.mainthread.errorJmp) {
      /* main thread has a handler? */
      g.mainthread.stack[g.mainthread.top++] = L.stack[L.top - 1];
      /* copy error obj. */

      luaD_throw(g.mainthread, errcode);
      /* re-throw in main thread */
    } else {
      /* no handler at all; abort */
      let panic = g.panic;

      if (panic) {
        /* panic function? */
        seterrorobj(L, errcode, L.top);
        /* assume EXTRA_STACK */

        if (L.ci.top < L.top) L.ci.top = L.top;
        /* pushing msg. can break this invariant */

        panic(L);
        /* call panic function (last chance to jump out) */
      }

      throw new Error(`Aborted ${errcode}`);
    }
  }
};

const luaD_rawrunprotected = function (L, f, ud) {
  let oldnCcalls = L.nCcalls;
  let lj = {
    status: LUA_OK,
    previous: L.errorJmp
    /* chain new error handler */

  };
  L.errorJmp = lj;

  try {
    f(L, ud);
  } catch (e) {
    if (lj.status === LUA_OK) {
      /* error was not thrown via luaD_throw, i.e. it is a JS error */

      /* run user error handler (if it exists) */
      let atnativeerror = L.l_G.atnativeerror;

      if (atnativeerror) {
        try {
          lj.status = LUA_OK;
          lapi.lua_pushcfunction(L, atnativeerror);
          lapi.lua_pushlightuserdata(L, e);
          luaD_callnoyield(L, L.top - 2, 1);
          /* Now run the message handler (if it exists) */

          /* copy of luaG_errormsg without the throw */

          if (L.errfunc !== 0) {
            /* is there an error handling function? */
            let errfunc = L.errfunc;
            lobject.pushobj2s(L, L.stack[L.top - 1]);
            /* move argument */

            lobject.setobjs2s(L, L.top - 2, errfunc);
            /* push function */

            luaD_callnoyield(L, L.top - 2, 1);
          }

          lj.status = LUA_ERRRUN;
        } catch (e2) {
          if (lj.status === LUA_OK) {
            /* also failed */
            lj.status = -1;
          }
        }
      } else {
        lj.status = -1;
      }
    }
  }

  L.errorJmp = lj.previous;
  L.nCcalls = oldnCcalls;
  return lj.status;
};
/*
** Completes the execution of an interrupted C function, calling its
** continuation function.
*/


const finishCcall = function (L, status) {
  let ci = L.ci;
  /* must have a continuation and must be able to call it */

  lua_assert(ci.c_k !== null && L.nny === 0);
  /* error status can only happen in a protected call */

  lua_assert(ci.callstatus & lstate.CIST_YPCALL || status === LUA_YIELD);

  if (ci.callstatus & lstate.CIST_YPCALL) {
    /* was inside a pcall? */
    ci.callstatus &= ~lstate.CIST_YPCALL;
    /* continuation is also inside it */

    L.errfunc = ci.c_old_errfunc;
    /* with the same error function */
  }
  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
     handled */


  if (ci.nresults === LUA_MULTRET && L.ci.top < L.top) L.ci.top = L.top;
  let c_k = ci.c_k;
  /* don't want to call as method */

  let n = c_k(L, status, ci.c_ctx);
  /* call continuation function */

  lapi.api_checknelems(L, n);
  luaD_poscall(L, ci, L.top - n, n);
  /* finish 'luaD_precall' */
};
/*
** Executes "full continuation" (everything in the stack) of a
** previously interrupted coroutine until the stack is empty (or another
** interruption long-jumps out of the loop). If the coroutine is
** recovering from an error, 'ud' points to the error status, which must
** be passed to the first continuation function (otherwise the default
** status is LUA_YIELD).
*/


const unroll = function (L, ud) {
  if (ud !== null)
    /* error status? */
    finishCcall(L, ud);
  /* finish 'lua_pcallk' callee */

  while (L.ci !== L.base_ci) {
    /* something in the stack */
    if (!(L.ci.callstatus & lstate.CIST_LUA))
      /* C function? */
      finishCcall(L, LUA_YIELD);
      /* complete its execution */
    else {
        /* Lua function */
        lvm.luaV_finishOp(L);
        /* finish interrupted instruction */

        lvm.luaV_execute(L);
        /* execute down to higher C 'boundary' */
      }
  }
};
/*
** Try to find a suspended protected call (a "recover point") for the
** given thread.
*/


const findpcall = function (L) {
  for (let ci = L.ci; ci !== null; ci = ci.previous) {
    /* search for a pcall */
    if (ci.callstatus & lstate.CIST_YPCALL) return ci;
  }

  return null;
  /* no pending pcall */
};
/*
** Recovers from an error in a coroutine. Finds a recover point (if
** there is one) and completes the execution of the interrupted
** 'luaD_pcall'. If there is no recover point, returns zero.
*/


const recover = function (L, status) {
  let ci = findpcall(L);
  if (ci === null) return 0;
  /* no recovery point */

  /* "finish" luaD_pcall */

  let oldtop = ci.extra;
  lfunc.luaF_close(L, oldtop);
  seterrorobj(L, status, oldtop);
  L.ci = ci;
  L.allowhook = ci.callstatus & lstate.CIST_OAH;
  /* restore original 'allowhook' */

  L.nny = 0;
  /* should be zero to be yieldable */

  luaD_shrinkstack(L);
  L.errfunc = ci.c_old_errfunc;
  return 1;
  /* continue running the coroutine */
};
/*
** Signal an error in the call to 'lua_resume', not in the execution
** of the coroutine itself. (Such errors should not be handled by any
** coroutine error handler and should not kill the coroutine.)
*/


const resume_error = function (L, msg, narg) {
  let ts = luaS_newliteral(L, msg);

  if (narg === 0) {
    lobject.pushsvalue2s(L, ts);
    api_check(L, L.top <= L.ci.top, "stack overflow");
  } else {
    /* remove args from the stack */
    for (let i = 1; i < narg; i++) delete L.stack[--L.top];

    lobject.setsvalue2s(L, L.top - 1, ts);
    /* push error message */
  }

  return LUA_ERRRUN;
};
/*
** Do the work for 'lua_resume' in protected mode. Most of the work
** depends on the status of the coroutine: initial state, suspended
** inside a hook, or regularly suspended (optionally with a continuation
** function), plus erroneous cases: non-suspended coroutine or dead
** coroutine.
*/


const resume = function (L, n) {
  let firstArg = L.top - n;
  /* first argument */

  let ci = L.ci;

  if (L.status === LUA_OK) {
    /* starting a coroutine? */
    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))
      /* Lua function? */
      lvm.luaV_execute(L);
    /* call it */
  } else {
    /* resuming from previous yield */
    lua_assert(L.status === LUA_YIELD);
    L.status = LUA_OK;
    /* mark that it is running (again) */

    ci.funcOff = ci.extra;
    ci.func = L.stack[ci.funcOff];
    if (ci.callstatus & lstate.CIST_LUA)
      /* yielded inside a hook? */
      lvm.luaV_execute(L);
      /* just continue running Lua code */
    else {
        /* 'common' yield */
        if (ci.c_k !== null) {
          /* does it have a continuation function? */
          n = ci.c_k(L, LUA_YIELD, ci.c_ctx);
          /* call continuation */

          lapi.api_checknelems(L, n);
          firstArg = L.top - n;
          /* yield results come from continuation */
        }

        luaD_poscall(L, ci, firstArg, n);
        /* finish 'luaD_precall' */
      }
    unroll(L, null);
    /* run continuation */
  }
};

const lua_resume = function (L, from, nargs) {
  let oldnny = L.nny;
  /* save "number of non-yieldable" calls */

  if (L.status === LUA_OK) {
    /* may be starting a coroutine */
    if (L.ci !== L.base_ci)
      /* not in base level? */
      return resume_error(L, "cannot resume non-suspended coroutine", nargs);
  } else if (L.status !== LUA_YIELD) return resume_error(L, "cannot resume dead coroutine", nargs);

  L.nCcalls = from ? from.nCcalls + 1 : 1;
  if (L.nCcalls >= LUAI_MAXCCALLS) return resume_error(L, "JS stack overflow", nargs);
  L.nny = 0;
  /* allow yields */

  lapi.api_checknelems(L, L.status === LUA_OK ? nargs + 1 : nargs);
  let status = luaD_rawrunprotected(L, resume, nargs);
  if (status === -1)
    /* error calling 'lua_resume'? */
    status = LUA_ERRRUN;else {
    /* continue running after recoverable errors */
    while (status > LUA_YIELD && recover(L, status)) {
      /* unroll continuation */
      status = luaD_rawrunprotected(L, unroll, status);
    }

    if (status > LUA_YIELD) {
      /* unrecoverable error? */
      L.status = status;
      /* mark thread as 'dead' */

      seterrorobj(L, status, L.top);
      /* push error message */

      L.ci.top = L.top;
    } else lua_assert(status === L.status);
    /* normal end or yield */

  }
  L.nny = oldnny;
  /* restore 'nny' */

  L.nCcalls--;
  lua_assert(L.nCcalls === (from ? from.nCcalls : 0));
  return status;
};

const lua_isyieldable = function (L) {
  return L.nny === 0;
};

const lua_yieldk = function (L, nresults, ctx, k) {
  let ci = L.ci;
  lapi.api_checknelems(L, nresults);

  if (L.nny > 0) {
    if (L !== L.l_G.mainthread) ldebug.luaG_runerror(L, to_luastring("attempt to yield across a JS-call boundary", true));else ldebug.luaG_runerror(L, to_luastring("attempt to yield from outside a coroutine", true));
  }

  L.status = LUA_YIELD;
  ci.extra = ci.funcOff;
  /* save current 'func' */

  if (ci.callstatus & lstate.CIST_LUA)
    /* inside a hook? */
    api_check(L, k === null, "hooks cannot continue after yielding");else {
    ci.c_k = k;
    if (k !== null)
      /* is there a continuation? */
      ci.c_ctx = ctx;
    /* save context */

    ci.funcOff = L.top - nresults - 1;
    /* protect stack below results */

    ci.func = L.stack[ci.funcOff];
    luaD_throw(L, LUA_YIELD);
  }
  lua_assert(ci.callstatus & lstate.CIST_HOOKED);
  /* must be inside a hook */

  return 0;
  /* return to 'luaD_hook' */
};

const lua_yield = function (L, n) {
  lua_yieldk(L, n, 0, null);
};

const luaD_pcall = function (L, func, u, old_top, ef) {
  let old_ci = L.ci;
  let old_allowhooks = L.allowhook;
  let old_nny = L.nny;
  let old_errfunc = L.errfunc;
  L.errfunc = ef;
  let status = luaD_rawrunprotected(L, func, u);

  if (status !== LUA_OK) {
    lfunc.luaF_close(L, old_top);
    seterrorobj(L, status, old_top);
    L.ci = old_ci;
    L.allowhook = old_allowhooks;
    L.nny = old_nny;
    luaD_shrinkstack(L);
  }

  L.errfunc = old_errfunc;
  return status;
};
/*
** Similar to 'luaD_call', but does not allow yields during the call
*/


const luaD_callnoyield = function (L, off, nResults) {
  L.nny++;
  luaD_call(L, off, nResults);
  L.nny--;
};
/*
** Execute a protected parser.
*/


class SParser {
  constructor(z, name, mode) {
    /* data to 'f_parser' */
    this.z = z;
    this.buff = new MBuffer();
    /* dynamic structure used by the scanner */

    this.dyd = new lparser.Dyndata();
    /* dynamic structures used by the parser */

    this.mode = mode;
    this.name = name;
  }

}

const checkmode = function (L, mode, x) {
  if (mode && luastring_indexOf(mode, x[0]) === -1) {
    lobject.luaO_pushfstring(L, to_luastring("attempt to load a %s chunk (mode is '%s')"), x, mode);
    luaD_throw(L, LUA_ERRSYNTAX);
  }
};

const f_parser = function (L, p) {
  let cl;
  let c = p.z.zgetc();
  /* read first character */

  if (c === LUA_SIGNATURE[0]) {
    checkmode(L, p.mode, to_luastring("binary", true));
    cl = lundump.luaU_undump(L, p.z, p.name);
  } else {
    checkmode(L, p.mode, to_luastring("text", true));
    cl = lparser.luaY_parser(L, p.z, p.buff, p.dyd, p.name, c);
  }

  lua_assert(cl.nupvalues === cl.p.upvalues.length);
  lfunc.luaF_initupvals(L, cl);
};

const luaD_protectedparser = function (L, z, name, mode) {
  let p = new SParser(z, name, mode);
  L.nny++;
  /* cannot yield during parsing */

  let status = luaD_pcall(L, f_parser, p, L.top, L.errfunc);
  L.nny--;
  return status;
};

module.exports.adjust_top = adjust_top;
module.exports.luaD_call = luaD_call;
module.exports.luaD_callnoyield = luaD_callnoyield;
module.exports.luaD_checkstack = luaD_checkstack;
module.exports.luaD_growstack = luaD_growstack;
module.exports.luaD_hook = luaD_hook;
module.exports.luaD_inctop = luaD_inctop;
module.exports.luaD_pcall = luaD_pcall;
module.exports.luaD_poscall = luaD_poscall;
module.exports.luaD_precall = luaD_precall;
module.exports.luaD_protectedparser = luaD_protectedparser;
module.exports.luaD_rawrunprotected = luaD_rawrunprotected;
module.exports.luaD_reallocstack = luaD_reallocstack;
module.exports.luaD_throw = luaD_throw;
module.exports.lua_isyieldable = lua_isyieldable;
module.exports.lua_resume = lua_resume;
module.exports.lua_yield = lua_yield;
module.exports.lua_yieldk = lua_yieldk;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TCCL,
    LUA_TLCF,
    LUA_TLCL,
    LUA_TLIGHTUSERDATA,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR,
    LUA_TTABLE,
    LUA_TTHREAD,
    LUA_TUSERDATA
  },
  to_luastring
} = __webpack_require__(1);

const {
  lua_assert
} = __webpack_require__(5);

const ldebug = __webpack_require__(12);

const lobject = __webpack_require__(7);

const {
  luaS_hashlongstr,
  TString
} = __webpack_require__(11);

const lstate = __webpack_require__(13);
/* used to prevent conflicts with lightuserdata keys */


let lightuserdata_hashes = new WeakMap();

const get_lightuserdata_hash = function (v) {
  let hash = lightuserdata_hashes.get(v);

  if (!hash) {
    /* Hash should be something unique that is a valid WeakMap key
       so that it ends up in dead_weak when removed from a table */
    hash = {};
    lightuserdata_hashes.set(v, hash);
  }

  return hash;
};

const table_hash = function (L, key) {
  switch (key.type) {
    case LUA_TNIL:
      return ldebug.luaG_runerror(L, to_luastring("table index is nil", true));

    case LUA_TNUMFLT:
      if (isNaN(key.value)) return ldebug.luaG_runerror(L, to_luastring("table index is NaN", true));

    /* fall through */

    case LUA_TNUMINT:
    /* takes advantage of floats and integers being same in JS */

    case LUA_TBOOLEAN:
    case LUA_TTABLE:
    case LUA_TLCL:
    case LUA_TLCF:
    case LUA_TCCL:
    case LUA_TUSERDATA:
    case LUA_TTHREAD:
      return key.value;

    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      return luaS_hashlongstr(key.tsvalue());

    case LUA_TLIGHTUSERDATA:
      {
        let v = key.value;

        switch (typeof v) {
          case "string":
            /* possible conflict with LUA_TSTRING.
               prefix this string with "*" so they don't clash */
            return "*" + v;

          case "number":
            /* possible conflict with LUA_TNUMBER.
               turn into string and prefix with "#" to avoid clash with other strings */
            return "#" + v;

          case "boolean":
            /* possible conflict with LUA_TBOOLEAN. use strings ?true and ?false instead */
            return v ? "?true" : "?false";

          case "function":
            /* possible conflict with LUA_TLCF.
               indirect via a weakmap */
            return get_lightuserdata_hash(v);

          case "object":
            /* v could be a lua_State, CClosure, LClosure, Table or Userdata from this state as returned by lua_topointer */
            if (v instanceof lstate.lua_State && v.l_G === L.l_G || v instanceof Table || v instanceof lobject.Udata || v instanceof lobject.LClosure || v instanceof lobject.CClosure) {
              /* indirect via a weakmap */
              return get_lightuserdata_hash(v);
            }

          /* fall through */

          default:
            return v;
        }
      }

    default:
      throw new Error("unknown key type: " + key.type);
  }
};

class Table {
  constructor(L) {
    this.id = L.l_G.id_counter++;
    this.strong = new Map();
    this.dead_strong = new Map();
    this.dead_weak = void 0;
    /* initialised when needed */

    this.f = void 0;
    /* first entry */

    this.l = void 0;
    /* last entry */

    this.metatable = null;
    this.flags = ~0;
  }

}

const invalidateTMcache = function (t) {
  t.flags = 0;
};

const add = function (t, hash, key, value) {
  t.dead_strong.clear();
  t.dead_weak = void 0;
  let prev = null;
  let entry = {
    key: key,
    value: value,
    p: prev = t.l,
    n: void 0
  };
  if (!t.f) t.f = entry;
  if (prev) prev.n = entry;
  t.strong.set(hash, entry);
  t.l = entry;
};

const is_valid_weakmap_key = function (k) {
  return typeof k === 'object' ? k !== null : typeof k === 'function';
};
/* Move out of 'strong' part and into 'dead' part. */


const mark_dead = function (t, hash) {
  let e = t.strong.get(hash);

  if (e) {
    e.key.setdeadvalue();
    e.value = void 0;
    let next = e.n;
    let prev = e.p;
    e.p = void 0;
    /* no need to know previous item any more */

    if (prev) prev.n = next;
    if (next) next.p = prev;
    if (t.f === e) t.f = next;
    if (t.l === e) t.l = prev;
    t.strong.delete(hash);

    if (is_valid_weakmap_key(hash)) {
      if (!t.dead_weak) t.dead_weak = new WeakMap();
      t.dead_weak.set(hash, e);
    } else {
      /* can't be used as key in weakmap */
      t.dead_strong.set(hash, e);
    }
  }
};

const luaH_new = function (L) {
  return new Table(L);
};

const getgeneric = function (t, hash) {
  let v = t.strong.get(hash);
  return v ? v.value : lobject.luaO_nilobject;
};

const luaH_getint = function (t, key) {
  lua_assert(typeof key == "number" && (key | 0) === key);
  return getgeneric(t, key);
};

const luaH_getstr = function (t, key) {
  lua_assert(key instanceof TString);
  return getgeneric(t, luaS_hashlongstr(key));
};

const luaH_get = function (L, t, key) {
  lua_assert(key instanceof lobject.TValue);
  if (key.ttisnil() || key.ttisfloat() && isNaN(key.value)) return lobject.luaO_nilobject;
  return getgeneric(t, table_hash(L, key));
};

const luaH_setint = function (t, key, value) {
  lua_assert(typeof key == "number" && (key | 0) === key && value instanceof lobject.TValue);
  let hash = key;
  /* table_hash known result */

  if (value.ttisnil()) {
    mark_dead(t, hash);
    return;
  }

  let e = t.strong.get(hash);

  if (e) {
    let tv = e.value;
    tv.setfrom(value);
  } else {
    let k = new lobject.TValue(LUA_TNUMINT, key);
    let v = new lobject.TValue(value.type, value.value);
    add(t, hash, k, v);
  }
};

const luaH_setfrom = function (L, t, key, value) {
  lua_assert(key instanceof lobject.TValue);
  let hash = table_hash(L, key);

  if (value.ttisnil()) {
    /* delete */
    mark_dead(t, hash);
    return;
  }

  let e = t.strong.get(hash);

  if (e) {
    e.value.setfrom(value);
  } else {
    let k;
    let kv = key.value;

    if (key.ttisfloat() && (kv | 0) === kv) {
      /* does index fit in an integer? */

      /* insert it as an integer */
      k = new lobject.TValue(LUA_TNUMINT, kv);
    } else {
      k = new lobject.TValue(key.type, kv);
    }

    let v = new lobject.TValue(value.type, value.value);
    add(t, hash, k, v);
  }
};
/*
** Try to find a boundary in table 't'. A 'boundary' is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/


const luaH_getn = function (t) {
  let i = 0;
  let j = t.strong.size + 1;
  /* use known size of Map to bound search */

  /* now do a binary search between them */

  while (j - i > 1) {
    let m = Math.floor((i + j) / 2);
    if (luaH_getint(t, m).ttisnil()) j = m;else i = m;
  }

  return i;
};

const luaH_next = function (L, table, keyI) {
  let keyO = L.stack[keyI];
  let entry;

  if (keyO.type === LUA_TNIL) {
    entry = table.f;
    if (!entry) return false;
  } else {
    /* First find current key */
    let hash = table_hash(L, keyO);
    /* Look in main part of table */

    entry = table.strong.get(hash);

    if (entry) {
      entry = entry.n;
      if (!entry) return false;
    } else {
      /* Try dead keys */
      entry = table.dead_weak && table.dead_weak.get(hash) || table.dead_strong.get(hash);
      if (!entry)
        /* item not in table */
        return ldebug.luaG_runerror(L, to_luastring("invalid key to 'next'"));
      /* Iterate until either out of keys, or until finding a non-dead key */

      do {
        entry = entry.n;
        if (!entry) return false;
      } while (entry.key.ttisdeadkey());
    }
  }

  lobject.setobj2s(L, keyI, entry.key);
  lobject.setobj2s(L, keyI + 1, entry.value);
  return true;
};

module.exports.invalidateTMcache = invalidateTMcache;
module.exports.luaH_get = luaH_get;
module.exports.luaH_getint = luaH_getint;
module.exports.luaH_getn = luaH_getn;
module.exports.luaH_getstr = luaH_getstr;
module.exports.luaH_setfrom = luaH_setfrom;
module.exports.luaH_setint = luaH_setint;
module.exports.luaH_new = luaH_new;
module.exports.luaH_next = luaH_next;
module.exports.Table = Table;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  is_luastring,
  luastring_eq,
  luastring_from,
  to_luastring
} = __webpack_require__(1);

const {
  lua_assert
} = __webpack_require__(5);

class TString {
  constructor(L, str) {
    this.hash = null;
    this.realstring = str;
  }

  getstr() {
    return this.realstring;
  }

  tsslen() {
    return this.realstring.length;
  }

}

const luaS_eqlngstr = function (a, b) {
  lua_assert(a instanceof TString);
  lua_assert(b instanceof TString);
  return a == b || luastring_eq(a.realstring, b.realstring);
};
/* converts strings (arrays) to a consistent map key
   make sure this doesn't conflict with any of the anti-collision strategies in ltable */


const luaS_hash = function (str) {
  lua_assert(is_luastring(str));
  let len = str.length;
  let s = "|";

  for (let i = 0; i < len; i++) s += str[i].toString(16);

  return s;
};

const luaS_hashlongstr = function (ts) {
  lua_assert(ts instanceof TString);

  if (ts.hash === null) {
    ts.hash = luaS_hash(ts.getstr());
  }

  return ts.hash;
};
/* variant that takes ownership of array */


const luaS_bless = function (L, str) {
  lua_assert(str instanceof Uint8Array);
  return new TString(L, str);
};
/* makes a copy */


const luaS_new = function (L, str) {
  return luaS_bless(L, luastring_from(str));
};
/* takes a js string */


const luaS_newliteral = function (L, str) {
  return luaS_bless(L, to_luastring(str));
};

module.exports.luaS_eqlngstr = luaS_eqlngstr;
module.exports.luaS_hash = luaS_hash;
module.exports.luaS_hashlongstr = luaS_hashlongstr;
module.exports.luaS_bless = luaS_bless;
module.exports.luaS_new = luaS_new;
module.exports.luaS_newliteral = luaS_newliteral;
module.exports.TString = TString;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_HOOKCOUNT,
  LUA_HOOKLINE,
  LUA_MASKCOUNT,
  LUA_MASKLINE,
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TNIL,
    LUA_TTABLE
  },
  thread_status: {
    LUA_ERRRUN,
    LUA_YIELD
  },
  from_userstring,
  luastring_eq,
  luastring_indexOf,
  to_luastring
} = __webpack_require__(1);

const {
  api_check,
  lua_assert
} = __webpack_require__(5);

const {
  LUA_IDSIZE
} = __webpack_require__(4);

const lapi = __webpack_require__(22);

const ldo = __webpack_require__(9);

const lfunc = __webpack_require__(14);

const llex = __webpack_require__(30);

const lobject = __webpack_require__(7);

const lopcodes = __webpack_require__(17);

const lstate = __webpack_require__(13);

const ltable = __webpack_require__(10);

const ltm = __webpack_require__(15);

const lvm = __webpack_require__(16);

const currentpc = function (ci) {
  lua_assert(ci.callstatus & lstate.CIST_LUA);
  return ci.l_savedpc - 1;
};

const currentline = function (ci) {
  return ci.func.value.p.lineinfo.length !== 0 ? ci.func.value.p.lineinfo[currentpc(ci)] : -1;
};
/*
** If function yielded, its 'func' can be in the 'extra' field. The
** next function restores 'func' to its correct value for debugging
** purposes. (It exchanges 'func' and 'extra'; so, when called again,
** after debugging, it also "re-restores" ** 'func' to its altered value.
*/


const swapextra = function (L) {
  if (L.status === LUA_YIELD) {
    let ci = L.ci;
    /* get function that yielded */

    let temp = ci.funcOff;
    /* exchange its 'func' and 'extra' values */

    ci.func = L.stack[ci.extra];
    ci.funcOff = ci.extra;
    ci.extra = temp;
  }
};

const lua_sethook = function (L, func, mask, count) {
  if (func === null || mask === 0) {
    /* turn off hooks? */
    mask = 0;
    func = null;
  }

  if (L.ci.callstatus & lstate.CIST_LUA) L.oldpc = L.ci.l_savedpc;
  L.hook = func;
  L.basehookcount = count;
  L.hookcount = L.basehookcount;
  L.hookmask = mask;
};

const lua_gethook = function (L) {
  return L.hook;
};

const lua_gethookmask = function (L) {
  return L.hookmask;
};

const lua_gethookcount = function (L) {
  return L.basehookcount;
};

const lua_getstack = function (L, level, ar) {
  let ci;
  let status;
  if (level < 0) return 0;
  /* invalid (negative) level */

  for (ci = L.ci; level > 0 && ci !== L.base_ci; ci = ci.previous) level--;

  if (level === 0 && ci !== L.base_ci) {
    /* level found? */
    status = 1;
    ar.i_ci = ci;
  } else status = 0;
  /* no such level */


  return status;
};

const upvalname = function (p, uv) {
  lua_assert(uv < p.upvalues.length);
  let s = p.upvalues[uv].name;
  if (s === null) return to_luastring("?", true);
  return s.getstr();
};

const findvararg = function (ci, n) {
  let nparams = ci.func.value.p.numparams;
  if (n >= ci.l_base - ci.funcOff - nparams) return null;
  /* no such vararg */
  else {
      return {
        pos: ci.funcOff + nparams + n,
        name: to_luastring("(*vararg)", true)
        /* generic name for any vararg */

      };
    }
};

const findlocal = function (L, ci, n) {
  let base,
      name = null;

  if (ci.callstatus & lstate.CIST_LUA) {
    if (n < 0)
      /* access to vararg values? */
      return findvararg(ci, -n);else {
      base = ci.l_base;
      name = lfunc.luaF_getlocalname(ci.func.value.p, n, currentpc(ci));
    }
  } else base = ci.funcOff + 1;

  if (name === null) {
    /* no 'standard' name? */
    let limit = ci === L.ci ? L.top : ci.next.funcOff;
    if (limit - base >= n && n > 0)
      /* is 'n' inside 'ci' stack? */
      name = to_luastring("(*temporary)", true);
      /* generic name for any valid slot */
    else return null;
    /* no name */
  }

  return {
    pos: base + (n - 1),
    name: name
  };
};

const lua_getlocal = function (L, ar, n) {
  let name;
  swapextra(L);

  if (ar === null) {
    /* information about non-active function? */
    if (!L.stack[L.top - 1].ttisLclosure())
      /* not a Lua function? */
      name = null;else
      /* consider live variables at function start (parameters) */
      name = lfunc.luaF_getlocalname(L.stack[L.top - 1].value.p, n, 0);
  } else {
    /* active function; get information through 'ar' */
    let local = findlocal(L, ar.i_ci, n);

    if (local) {
      name = local.name;
      lobject.pushobj2s(L, L.stack[local.pos]);
      api_check(L, L.top <= L.ci.top, "stack overflow");
    } else {
      name = null;
    }
  }

  swapextra(L);
  return name;
};

const lua_setlocal = function (L, ar, n) {
  let name;
  swapextra(L);
  let local = findlocal(L, ar.i_ci, n);

  if (local) {
    name = local.name;
    lobject.setobjs2s(L, local.pos, L.top - 1);
    delete L.stack[--L.top];
    /* pop value */
  } else {
    name = null;
  }

  swapextra(L);
  return name;
};

const funcinfo = function (ar, cl) {
  if (cl === null || cl instanceof lobject.CClosure) {
    ar.source = to_luastring("=[JS]", true);
    ar.linedefined = -1;
    ar.lastlinedefined = -1;
    ar.what = to_luastring("J", true);
  } else {
    let p = cl.p;
    ar.source = p.source ? p.source.getstr() : to_luastring("=?", true);
    ar.linedefined = p.linedefined;
    ar.lastlinedefined = p.lastlinedefined;
    ar.what = ar.linedefined === 0 ? to_luastring("main", true) : to_luastring("Lua", true);
  }

  ar.short_src = lobject.luaO_chunkid(ar.source, LUA_IDSIZE);
};

const collectvalidlines = function (L, f) {
  if (f === null || f instanceof lobject.CClosure) {
    L.stack[L.top] = new lobject.TValue(LUA_TNIL, null);
    lapi.api_incr_top(L);
  } else {
    let lineinfo = f.p.lineinfo;
    let t = ltable.luaH_new(L);
    L.stack[L.top] = new lobject.TValue(LUA_TTABLE, t);
    lapi.api_incr_top(L);
    let v = new lobject.TValue(LUA_TBOOLEAN, true);

    for (let i = 0; i < lineinfo.length; i++) ltable.luaH_setint(t, lineinfo[i], v);
  }
};

const getfuncname = function (L, ci) {
  let r = {
    name: null,
    funcname: null
  };
  if (ci === null) return null;else if (ci.callstatus & lstate.CIST_FIN) {
    /* is this a finalizer? */
    r.name = to_luastring("__gc", true);
    r.funcname = to_luastring("metamethod", true);
    /* report it as such */

    return r;
  }
  /* calling function is a known Lua function? */
  else if (!(ci.callstatus & lstate.CIST_TAIL) && ci.previous.callstatus & lstate.CIST_LUA) return funcnamefromcode(L, ci.previous);else return null;
  /* no way to find a name */
};

const auxgetinfo = function (L, what, ar, f, ci) {
  let status = 1;

  for (; what.length > 0; what = what.subarray(1)) {
    switch (what[0]) {
      case 83
      /* ('S').charCodeAt(0) */
      :
        {
          funcinfo(ar, f);
          break;
        }

      case 108
      /* ('l').charCodeAt(0) */
      :
        {
          ar.currentline = ci && ci.callstatus & lstate.CIST_LUA ? currentline(ci) : -1;
          break;
        }

      case 117
      /* ('u').charCodeAt(0) */
      :
        {
          ar.nups = f === null ? 0 : f.nupvalues;

          if (f === null || f instanceof lobject.CClosure) {
            ar.isvararg = true;
            ar.nparams = 0;
          } else {
            ar.isvararg = f.p.is_vararg;
            ar.nparams = f.p.numparams;
          }

          break;
        }

      case 116
      /* ('t').charCodeAt(0) */
      :
        {
          ar.istailcall = ci ? ci.callstatus & lstate.CIST_TAIL : 0;
          break;
        }

      case 110
      /* ('n').charCodeAt(0) */
      :
        {
          let r = getfuncname(L, ci);

          if (r === null) {
            ar.namewhat = to_luastring("", true);
            ar.name = null;
          } else {
            ar.namewhat = r.funcname;
            ar.name = r.name;
          }

          break;
        }

      case 76
      /* ('L').charCodeAt(0) */
      :
      case 102
      /* ('f').charCodeAt(0) */
      :
        /* handled by lua_getinfo */
        break;

      default:
        status = 0;

      /* invalid option */
    }
  }

  return status;
};

const lua_getinfo = function (L, what, ar) {
  what = from_userstring(what);
  let status, cl, ci, func;
  swapextra(L);

  if (what[0] === 62
  /* ('>').charCodeAt(0) */
  ) {
      ci = null;
      func = L.stack[L.top - 1];
      api_check(L, func.ttisfunction(), "function expected");
      what = what.subarray(1);
      /* skip the '>' */

      L.top--;
      /* pop function */
    } else {
    ci = ar.i_ci;
    func = ci.func;
    lua_assert(ci.func.ttisfunction());
  }

  cl = func.ttisclosure() ? func.value : null;
  status = auxgetinfo(L, what, ar, cl, ci);

  if (luastring_indexOf(what, 102
  /* ('f').charCodeAt(0) */
  ) >= 0) {
    lobject.pushobj2s(L, func);
    api_check(L, L.top <= L.ci.top, "stack overflow");
  }

  swapextra(L);
  if (luastring_indexOf(what, 76
  /* ('L').charCodeAt(0) */
  ) >= 0) collectvalidlines(L, cl);
  return status;
};

const kname = function (p, pc, c) {
  let r = {
    name: null,
    funcname: null
  };

  if (lopcodes.ISK(c)) {
    /* is 'c' a constant? */
    let kvalue = p.k[lopcodes.INDEXK(c)];

    if (kvalue.ttisstring()) {
      /* literal constant? */
      r.name = kvalue.svalue();
      /* it is its own name */

      return r;
    }
    /* else no reasonable name found */

  } else {
    /* 'c' is a register */
    let what = getobjname(p, pc, c);
    /* search for 'c' */

    if (what && what.funcname[0] === 99
    /* ('c').charCodeAt(0) */
    ) {
        /* found a constant name? */
        return what;
        /* 'name' already filled */
      }
    /* else no reasonable name found */

  }

  r.name = to_luastring("?", true);
  return r;
  /* no reasonable name found */
};

const filterpc = function (pc, jmptarget) {
  if (pc < jmptarget)
    /* is code conditional (inside a jump)? */
    return -1;
    /* cannot know who sets that register */
  else return pc;
  /* current position sets that register */
};
/*
** try to find last instruction before 'lastpc' that modified register 'reg'
*/


const findsetreg = function (p, lastpc, reg) {
  let setreg = -1;
  /* keep last instruction that changed 'reg' */

  let jmptarget = 0;
  /* any code before this address is conditional */

  let OCi = lopcodes.OpCodesI;

  for (let pc = 0; pc < lastpc; pc++) {
    let i = p.code[pc];
    let a = i.A;

    switch (i.opcode) {
      case OCi.OP_LOADNIL:
        {
          let b = i.B;
          if (a <= reg && reg <= a + b)
            /* set registers from 'a' to 'a+b' */
            setreg = filterpc(pc, jmptarget);
          break;
        }

      case OCi.OP_TFORCALL:
        {
          if (reg >= a + 2)
            /* affect all regs above its base */
            setreg = filterpc(pc, jmptarget);
          break;
        }

      case OCi.OP_CALL:
      case OCi.OP_TAILCALL:
        {
          if (reg >= a)
            /* affect all registers above base */
            setreg = filterpc(pc, jmptarget);
          break;
        }

      case OCi.OP_JMP:
        {
          let b = i.sBx;
          let dest = pc + 1 + b;
          /* jump is forward and do not skip 'lastpc'? */

          if (pc < dest && dest <= lastpc) {
            if (dest > jmptarget) jmptarget = dest;
            /* update 'jmptarget' */
          }

          break;
        }

      default:
        if (lopcodes.testAMode(i.opcode) && reg === a) setreg = filterpc(pc, jmptarget);
        break;
    }
  }

  return setreg;
};

const getobjname = function (p, lastpc, reg) {
  let r = {
    name: lfunc.luaF_getlocalname(p, reg + 1, lastpc),
    funcname: null
  };

  if (r.name) {
    /* is a local? */
    r.funcname = to_luastring("local", true);
    return r;
  }
  /* else try symbolic execution */


  let pc = findsetreg(p, lastpc, reg);
  let OCi = lopcodes.OpCodesI;

  if (pc !== -1) {
    /* could find instruction? */
    let i = p.code[pc];

    switch (i.opcode) {
      case OCi.OP_MOVE:
        {
          let b = i.B;
          /* move from 'b' to 'a' */

          if (b < i.A) return getobjname(p, pc, b);
          /* get name for 'b' */

          break;
        }

      case OCi.OP_GETTABUP:
      case OCi.OP_GETTABLE:
        {
          let k = i.C;
          /* key index */

          let t = i.B;
          /* table index */

          let vn = i.opcode === OCi.OP_GETTABLE ? lfunc.luaF_getlocalname(p, t + 1, pc) : upvalname(p, t);
          r.name = kname(p, pc, k).name;
          r.funcname = vn && luastring_eq(vn, llex.LUA_ENV) ? to_luastring("global", true) : to_luastring("field", true);
          return r;
        }

      case OCi.OP_GETUPVAL:
        {
          r.name = upvalname(p, i.B);
          r.funcname = to_luastring("upvalue", true);
          return r;
        }

      case OCi.OP_LOADK:
      case OCi.OP_LOADKX:
        {
          let b = i.opcode === OCi.OP_LOADK ? i.Bx : p.code[pc + 1].Ax;

          if (p.k[b].ttisstring()) {
            r.name = p.k[b].svalue();
            r.funcname = to_luastring("constant", true);
            return r;
          }

          break;
        }

      case OCi.OP_SELF:
        {
          let k = i.C;
          r.name = kname(p, pc, k).name;
          r.funcname = to_luastring("method", true);
          return r;
        }

      default:
        break;
    }
  }

  return null;
};
/*
** Try to find a name for a function based on the code that called it.
** (Only works when function was called by a Lua function.)
** Returns what the name is (e.g., "for iterator", "method",
** "metamethod") and sets '*name' to point to the name.
*/


const funcnamefromcode = function (L, ci) {
  let r = {
    name: null,
    funcname: null
  };
  let tm = 0;
  /* (initial value avoids warnings) */

  let p = ci.func.value.p;
  /* calling function */

  let pc = currentpc(ci);
  /* calling instruction index */

  let i = p.code[pc];
  /* calling instruction */

  let OCi = lopcodes.OpCodesI;

  if (ci.callstatus & lstate.CIST_HOOKED) {
    r.name = to_luastring("?", true);
    r.funcname = to_luastring("hook", true);
    return r;
  }

  switch (i.opcode) {
    case OCi.OP_CALL:
    case OCi.OP_TAILCALL:
      return getobjname(p, pc, i.A);

    /* get function name */

    case OCi.OP_TFORCALL:
      r.name = to_luastring("for iterator", true);
      r.funcname = to_luastring("for iterator", true);
      return r;

    /* other instructions can do calls through metamethods */

    case OCi.OP_SELF:
    case OCi.OP_GETTABUP:
    case OCi.OP_GETTABLE:
      tm = ltm.TMS.TM_INDEX;
      break;

    case OCi.OP_SETTABUP:
    case OCi.OP_SETTABLE:
      tm = ltm.TMS.TM_NEWINDEX;
      break;

    case OCi.OP_ADD:
      tm = ltm.TMS.TM_ADD;
      break;

    case OCi.OP_SUB:
      tm = ltm.TMS.TM_SUB;
      break;

    case OCi.OP_MUL:
      tm = ltm.TMS.TM_MUL;
      break;

    case OCi.OP_MOD:
      tm = ltm.TMS.TM_MOD;
      break;

    case OCi.OP_POW:
      tm = ltm.TMS.TM_POW;
      break;

    case OCi.OP_DIV:
      tm = ltm.TMS.TM_DIV;
      break;

    case OCi.OP_IDIV:
      tm = ltm.TMS.TM_IDIV;
      break;

    case OCi.OP_BAND:
      tm = ltm.TMS.TM_BAND;
      break;

    case OCi.OP_BOR:
      tm = ltm.TMS.TM_BOR;
      break;

    case OCi.OP_BXOR:
      tm = ltm.TMS.TM_BXOR;
      break;

    case OCi.OP_SHL:
      tm = ltm.TMS.TM_SHL;
      break;

    case OCi.OP_SHR:
      tm = ltm.TMS.TM_SHR;
      break;

    case OCi.OP_UNM:
      tm = ltm.TMS.TM_UNM;
      break;

    case OCi.OP_BNOT:
      tm = ltm.TMS.TM_BNOT;
      break;

    case OCi.OP_LEN:
      tm = ltm.TMS.TM_LEN;
      break;

    case OCi.OP_CONCAT:
      tm = ltm.TMS.TM_CONCAT;
      break;

    case OCi.OP_EQ:
      tm = ltm.TMS.TM_EQ;
      break;

    case OCi.OP_LT:
      tm = ltm.TMS.TM_LT;
      break;

    case OCi.OP_LE:
      tm = ltm.TMS.TM_LE;
      break;

    default:
      return null;

    /* cannot find a reasonable name */
  }

  r.name = L.l_G.tmname[tm].getstr();
  r.funcname = to_luastring("metamethod", true);
  return r;
};

const isinstack = function (L, ci, o) {
  for (let i = ci.l_base; i < ci.top; i++) {
    if (L.stack[i] === o) return i;
  }

  return false;
};
/*
** Checks whether value 'o' came from an upvalue. (That can only happen
** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on
** upvalues.)
*/


const getupvalname = function (L, ci, o) {
  let c = ci.func.value;

  for (let i = 0; i < c.nupvalues; i++) {
    if (c.upvals[i] === o) {
      return {
        name: upvalname(c.p, i),
        funcname: to_luastring('upvalue', true)
      };
    }
  }

  return null;
};

const varinfo = function (L, o) {
  let ci = L.ci;
  let kind = null;

  if (ci.callstatus & lstate.CIST_LUA) {
    kind = getupvalname(L, ci, o);
    /* check whether 'o' is an upvalue */

    let stkid = isinstack(L, ci, o);
    if (!kind && stkid)
      /* no? try a register */
      kind = getobjname(ci.func.value.p, currentpc(ci), stkid - ci.l_base);
  }

  return kind ? lobject.luaO_pushfstring(L, to_luastring(" (%s '%s')", true), kind.funcname, kind.name) : to_luastring("", true);
};

const luaG_typeerror = function (L, o, op) {
  let t = ltm.luaT_objtypename(L, o);
  luaG_runerror(L, to_luastring("attempt to %s a %s value%s", true), op, t, varinfo(L, o));
};

const luaG_concaterror = function (L, p1, p2) {
  if (p1.ttisstring() || lvm.cvt2str(p1)) p1 = p2;
  luaG_typeerror(L, p1, to_luastring('concatenate', true));
};
/*
** Error when both values are convertible to numbers, but not to integers
*/


const luaG_opinterror = function (L, p1, p2, msg) {
  if (lvm.tonumber(p1) === false) p2 = p1;
  luaG_typeerror(L, p2, msg);
};

const luaG_ordererror = function (L, p1, p2) {
  let t1 = ltm.luaT_objtypename(L, p1);
  let t2 = ltm.luaT_objtypename(L, p2);
  if (luastring_eq(t1, t2)) luaG_runerror(L, to_luastring("attempt to compare two %s values", true), t1);else luaG_runerror(L, to_luastring("attempt to compare %s with %s", true), t1, t2);
};
/* add src:line information to 'msg' */


const luaG_addinfo = function (L, msg, src, line) {
  let buff;
  if (src) buff = lobject.luaO_chunkid(src.getstr(), LUA_IDSIZE);else buff = to_luastring("?", true);
  return lobject.luaO_pushfstring(L, to_luastring("%s:%d: %s", true), buff, line, msg);
};

const luaG_runerror = function (L, fmt, ...argp) {
  let ci = L.ci;
  let msg = lobject.luaO_pushvfstring(L, fmt, argp);
  if (ci.callstatus & lstate.CIST_LUA)
    /* if Lua function, add source:line information */
    luaG_addinfo(L, msg, ci.func.value.p.source, currentline(ci));
  luaG_errormsg(L);
};

const luaG_errormsg = function (L) {
  if (L.errfunc !== 0) {
    /* is there an error handling function? */
    let errfunc = L.errfunc;
    lobject.pushobj2s(L, L.stack[L.top - 1]);
    /* move argument */

    lobject.setobjs2s(L, L.top - 2, errfunc);
    /* push function */

    ldo.luaD_callnoyield(L, L.top - 2, 1);
  }

  ldo.luaD_throw(L, LUA_ERRRUN);
};
/*
** Error when both values are convertible to numbers, but not to integers
*/


const luaG_tointerror = function (L, p1, p2) {
  let temp = lvm.tointeger(p1);
  if (temp === false) p2 = p1;
  luaG_runerror(L, to_luastring("number%s has no integer representation", true), varinfo(L, p2));
};

const luaG_traceexec = function (L) {
  let ci = L.ci;
  let mask = L.hookmask;
  let counthook = --L.hookcount === 0 && mask & LUA_MASKCOUNT;
  if (counthook) L.hookcount = L.basehookcount;
  /* reset count */
  else if (!(mask & LUA_MASKLINE)) return;
  /* no line hook and count != 0; nothing to be done */

  if (ci.callstatus & lstate.CIST_HOOKYIELD) {
    /* called hook last time? */
    ci.callstatus &= ~lstate.CIST_HOOKYIELD;
    /* erase mark */

    return;
    /* do not call hook again (VM yielded, so it did not move) */
  }

  if (counthook) ldo.luaD_hook(L, LUA_HOOKCOUNT, -1);
  /* call count hook */

  if (mask & LUA_MASKLINE) {
    let p = ci.func.value.p;
    let npc = ci.l_savedpc - 1; // pcRel(ci.u.l.savedpc, p);

    let newline = p.lineinfo.length !== 0 ? p.lineinfo[npc] : -1;
    if (npc === 0 ||
    /* call linehook when enter a new function, */
    ci.l_savedpc <= L.oldpc ||
    /* when jump back (loop), or when */
    newline !== (p.lineinfo.length !== 0 ? p.lineinfo[L.oldpc - 1] : -1))
      /* enter a new line */
      ldo.luaD_hook(L, LUA_HOOKLINE, newline);
    /* call line hook */
  }

  L.oldpc = ci.l_savedpc;

  if (L.status === LUA_YIELD) {
    /* did hook yield? */
    if (counthook) L.hookcount = 1;
    /* undo decrement to zero */

    ci.l_savedpc--;
    /* undo increment (resume will increment it again) */

    ci.callstatus |= lstate.CIST_HOOKYIELD;
    /* mark that it yielded */

    ci.funcOff = L.top - 1;
    /* protect stack below results */

    ci.func = L.stack[ci.funcOff];
    ldo.luaD_throw(L, LUA_YIELD);
  }
};

module.exports.luaG_addinfo = luaG_addinfo;
module.exports.luaG_concaterror = luaG_concaterror;
module.exports.luaG_errormsg = luaG_errormsg;
module.exports.luaG_opinterror = luaG_opinterror;
module.exports.luaG_ordererror = luaG_ordererror;
module.exports.luaG_runerror = luaG_runerror;
module.exports.luaG_tointerror = luaG_tointerror;
module.exports.luaG_traceexec = luaG_traceexec;
module.exports.luaG_typeerror = luaG_typeerror;
module.exports.lua_gethook = lua_gethook;
module.exports.lua_gethookcount = lua_gethookcount;
module.exports.lua_gethookmask = lua_gethookmask;
module.exports.lua_getinfo = lua_getinfo;
module.exports.lua_getlocal = lua_getlocal;
module.exports.lua_getstack = lua_getstack;
module.exports.lua_sethook = lua_sethook;
module.exports.lua_setlocal = lua_setlocal;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MINSTACK,
  LUA_RIDX_GLOBALS,
  LUA_RIDX_MAINTHREAD,
  constant_types: {
    LUA_NUMTAGS,
    LUA_TNIL,
    LUA_TTABLE,
    LUA_TTHREAD
  },
  thread_status: {
    LUA_OK
  }
} = __webpack_require__(1);

const lobject = __webpack_require__(7);

const ldo = __webpack_require__(9);

const lapi = __webpack_require__(22);

const ltable = __webpack_require__(10);

const ltm = __webpack_require__(15);

const EXTRA_STACK = 5;
const BASIC_STACK_SIZE = 2 * LUA_MINSTACK;

class CallInfo {
  constructor() {
    this.func = null;
    this.funcOff = NaN;
    this.top = NaN;
    this.previous = null;
    this.next = null;
    /* only for Lua functions */

    this.l_base = NaN;
    /* base for this function */

    this.l_code = null;
    /* reference to this.func.p.code */

    this.l_savedpc = NaN;
    /* offset into l_code */

    /* only for JS functions */

    this.c_k = null;
    /* continuation in case of yields */

    this.c_old_errfunc = null;
    this.c_ctx = null;
    /* context info. in case of yields */

    this.nresults = NaN;
    this.callstatus = NaN;
  }

}

class lua_State {
  constructor(g) {
    this.id = g.id_counter++;
    this.base_ci = new CallInfo();
    /* CallInfo for first level (C calling Lua) */

    this.top = NaN;
    /* first free slot in the stack */

    this.stack_last = NaN;
    /* last free slot in the stack */

    this.oldpc = NaN;
    /* last pc traced */

    /* preinit_thread */

    this.l_G = g;
    this.stack = null;
    this.ci = null;
    this.errorJmp = null;
    this.nCcalls = 0;
    this.hook = null;
    this.hookmask = 0;
    this.basehookcount = 0;
    this.allowhook = 1;
    this.hookcount = this.basehookcount;
    this.nny = 1;
    this.status = LUA_OK;
    this.errfunc = 0;
  }

}

class global_State {
  constructor() {
    this.id_counter = 1;
    /* used to give objects unique ids */

    this.ids = new WeakMap();
    this.mainthread = null;
    this.l_registry = new lobject.TValue(LUA_TNIL, null);
    this.panic = null;
    this.atnativeerror = null;
    this.version = null;
    this.tmname = new Array(ltm.TMS.TM_N);
    this.mt = new Array(LUA_NUMTAGS);
  }

}

const luaE_extendCI = function (L) {
  let ci = new CallInfo();
  L.ci.next = ci;
  ci.previous = L.ci;
  ci.next = null;
  L.ci = ci;
  return ci;
};

const luaE_freeCI = function (L) {
  let ci = L.ci;
  ci.next = null;
};

const stack_init = function (L1, L) {
  L1.stack = new Array(BASIC_STACK_SIZE);
  L1.top = 0;
  L1.stack_last = BASIC_STACK_SIZE - EXTRA_STACK;
  /* initialize first ci */

  let ci = L1.base_ci;
  ci.next = ci.previous = null;
  ci.callstatus = 0;
  ci.funcOff = L1.top;
  ci.func = L1.stack[L1.top];
  L1.stack[L1.top++] = new lobject.TValue(LUA_TNIL, null);
  ci.top = L1.top + LUA_MINSTACK;
  L1.ci = ci;
};

const freestack = function (L) {
  L.ci = L.base_ci;
  luaE_freeCI(L);
  L.stack = null;
};
/*
** Create registry table and its predefined values
*/


const init_registry = function (L, g) {
  let registry = ltable.luaH_new(L);
  g.l_registry.sethvalue(registry);
  ltable.luaH_setint(registry, LUA_RIDX_MAINTHREAD, new lobject.TValue(LUA_TTHREAD, L));
  ltable.luaH_setint(registry, LUA_RIDX_GLOBALS, new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L)));
};
/*
** open parts of the state that may cause memory-allocation errors.
** ('g->version' !== NULL flags that the state was completely build)
*/


const f_luaopen = function (L) {
  let g = L.l_G;
  stack_init(L, L);
  init_registry(L, g);
  ltm.luaT_init(L);
  g.version = lapi.lua_version(null);
};

const lua_newthread = function (L) {
  let g = L.l_G;
  let L1 = new lua_State(g);
  L.stack[L.top] = new lobject.TValue(LUA_TTHREAD, L1);
  lapi.api_incr_top(L);
  L1.hookmask = L.hookmask;
  L1.basehookcount = L.basehookcount;
  L1.hook = L.hook;
  L1.hookcount = L1.basehookcount;
  stack_init(L1, L);
  return L1;
};

const luaE_freethread = function (L, L1) {
  freestack(L1);
};

const lua_newstate = function () {
  let g = new global_State();
  let L = new lua_State(g);
  g.mainthread = L;

  if (ldo.luaD_rawrunprotected(L, f_luaopen, null) !== LUA_OK) {
    L = null;
  }

  return L;
};

const close_state = function (L) {
  freestack(L);
};

const lua_close = function (L) {
  L = L.l_G.mainthread;
  /* only the main thread can be closed */

  close_state(L);
};

module.exports.lua_State = lua_State;
module.exports.CallInfo = CallInfo;
module.exports.CIST_OAH = 1 << 0;
/* original value of 'allowhook' */

module.exports.CIST_LUA = 1 << 1;
/* call is running a Lua function */

module.exports.CIST_HOOKED = 1 << 2;
/* call is running a debug hook */

module.exports.CIST_FRESH = 1 << 3;
/* call is running on a fresh invocation of luaV_execute */

module.exports.CIST_YPCALL = 1 << 4;
/* call is a yieldable protected call */

module.exports.CIST_TAIL = 1 << 5;
/* call was tail called */

module.exports.CIST_HOOKYIELD = 1 << 6;
/* last hook called yielded */

module.exports.CIST_LEQ = 1 << 7;
/* using __lt for __le */

module.exports.CIST_FIN = 1 << 8;
/* call is running a finalizer */

module.exports.EXTRA_STACK = EXTRA_STACK;
module.exports.lua_close = lua_close;
module.exports.lua_newstate = lua_newstate;
module.exports.lua_newthread = lua_newthread;
module.exports.luaE_extendCI = luaE_extendCI;
module.exports.luaE_freeCI = luaE_freeCI;
module.exports.luaE_freethread = luaE_freethread;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  constant_types: {
    LUA_TNIL
  }
} = __webpack_require__(1);

const lobject = __webpack_require__(7);

class Proto {
  constructor(L) {
    this.id = L.l_G.id_counter++;
    this.k = []; // constants used by the function

    this.p = []; // functions defined inside the function

    this.code = []; // opcodes

    this.cache = null; // last-created closure with this prototype

    this.lineinfo = []; // map from opcodes to source lines (debug information)

    this.upvalues = []; // upvalue information

    this.numparams = 0; // number of fixed parameters

    this.is_vararg = false;
    this.maxstacksize = 0; // number of registers needed by this function

    this.locvars = []; // information about local variables (debug information)

    this.linedefined = 0; // debug information

    this.lastlinedefined = 0; // debug information

    this.source = null; // used for debug information
  }

}

const luaF_newLclosure = function (L, n) {
  return new lobject.LClosure(L, n);
};

const luaF_findupval = function (L, level) {
  return L.stack[level];
};

const luaF_close = function (L, level) {
  /* Create new TValues on stack;
   * any closures will keep referencing old TValues */
  for (let i = level; i < L.top; i++) {
    let old = L.stack[i];
    L.stack[i] = new lobject.TValue(old.type, old.value);
  }
};
/*
** fill a closure with new upvalues
*/


const luaF_initupvals = function (L, cl) {
  for (let i = 0; i < cl.nupvalues; i++) cl.upvals[i] = new lobject.TValue(LUA_TNIL, null);
};
/*
** Look for n-th local variable at line 'line' in function 'func'.
** Returns null if not found.
*/


const luaF_getlocalname = function (f, local_number, pc) {
  for (let i = 0; i < f.locvars.length && f.locvars[i].startpc <= pc; i++) {
    if (pc < f.locvars[i].endpc) {
      /* is variable active? */
      local_number--;
      if (local_number === 0) return f.locvars[i].varname.getstr();
    }
  }

  return null;
  /* not found */
};

module.exports.MAXUPVAL = 255;
module.exports.Proto = Proto;
module.exports.luaF_findupval = luaF_findupval;
module.exports.luaF_close = luaF_close;
module.exports.luaF_getlocalname = luaF_getlocalname;
module.exports.luaF_initupvals = luaF_initupvals;
module.exports.luaF_newLclosure = luaF_newLclosure;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  constant_types: {
    LUA_TTABLE,
    LUA_TUSERDATA
  },
  to_luastring
} = __webpack_require__(1);

const {
  lua_assert
} = __webpack_require__(5);

const lobject = __webpack_require__(7);

const ldo = __webpack_require__(9);

const lstate = __webpack_require__(13);

const {
  luaS_bless,
  luaS_new
} = __webpack_require__(11);

const ltable = __webpack_require__(10);

const ldebug = __webpack_require__(12);

const lvm = __webpack_require__(16);

const luaT_typenames_ = ["no value", "nil", "boolean", "userdata", "number", "string", "table", "function", "userdata", "thread", "proto"
/* this last case is used for tests only */
].map(e => to_luastring(e));

const ttypename = function (t) {
  return luaT_typenames_[t + 1];
};
/*
* WARNING: if you change the order of this enumeration,
* grep "ORDER TM" and "ORDER OP"
*/


const TMS = {
  TM_INDEX: 0,
  TM_NEWINDEX: 1,
  TM_GC: 2,
  TM_MODE: 3,
  TM_LEN: 4,
  TM_EQ: 5,

  /* last tag method with fast access */
  TM_ADD: 6,
  TM_SUB: 7,
  TM_MUL: 8,
  TM_MOD: 9,
  TM_POW: 10,
  TM_DIV: 11,
  TM_IDIV: 12,
  TM_BAND: 13,
  TM_BOR: 14,
  TM_BXOR: 15,
  TM_SHL: 16,
  TM_SHR: 17,
  TM_UNM: 18,
  TM_BNOT: 19,
  TM_LT: 20,
  TM_LE: 21,
  TM_CONCAT: 22,
  TM_CALL: 23,
  TM_N: 24
  /* number of elements in the enum */

};

const luaT_init = function (L) {
  L.l_G.tmname[TMS.TM_INDEX] = new luaS_new(L, to_luastring("__index", true));
  L.l_G.tmname[TMS.TM_NEWINDEX] = new luaS_new(L, to_luastring("__newindex", true));
  L.l_G.tmname[TMS.TM_GC] = new luaS_new(L, to_luastring("__gc", true));
  L.l_G.tmname[TMS.TM_MODE] = new luaS_new(L, to_luastring("__mode", true));
  L.l_G.tmname[TMS.TM_LEN] = new luaS_new(L, to_luastring("__len", true));
  L.l_G.tmname[TMS.TM_EQ] = new luaS_new(L, to_luastring("__eq", true));
  L.l_G.tmname[TMS.TM_ADD] = new luaS_new(L, to_luastring("__add", true));
  L.l_G.tmname[TMS.TM_SUB] = new luaS_new(L, to_luastring("__sub", true));
  L.l_G.tmname[TMS.TM_MUL] = new luaS_new(L, to_luastring("__mul", true));
  L.l_G.tmname[TMS.TM_MOD] = new luaS_new(L, to_luastring("__mod", true));
  L.l_G.tmname[TMS.TM_POW] = new luaS_new(L, to_luastring("__pow", true));
  L.l_G.tmname[TMS.TM_DIV] = new luaS_new(L, to_luastring("__div", true));
  L.l_G.tmname[TMS.TM_IDIV] = new luaS_new(L, to_luastring("__idiv", true));
  L.l_G.tmname[TMS.TM_BAND] = new luaS_new(L, to_luastring("__band", true));
  L.l_G.tmname[TMS.TM_BOR] = new luaS_new(L, to_luastring("__bor", true));
  L.l_G.tmname[TMS.TM_BXOR] = new luaS_new(L, to_luastring("__bxor", true));
  L.l_G.tmname[TMS.TM_SHL] = new luaS_new(L, to_luastring("__shl", true));
  L.l_G.tmname[TMS.TM_SHR] = new luaS_new(L, to_luastring("__shr", true));
  L.l_G.tmname[TMS.TM_UNM] = new luaS_new(L, to_luastring("__unm", true));
  L.l_G.tmname[TMS.TM_BNOT] = new luaS_new(L, to_luastring("__bnot", true));
  L.l_G.tmname[TMS.TM_LT] = new luaS_new(L, to_luastring("__lt", true));
  L.l_G.tmname[TMS.TM_LE] = new luaS_new(L, to_luastring("__le", true));
  L.l_G.tmname[TMS.TM_CONCAT] = new luaS_new(L, to_luastring("__concat", true));
  L.l_G.tmname[TMS.TM_CALL] = new luaS_new(L, to_luastring("__call", true));
};
/*
** Return the name of the type of an object. For tables and userdata
** with metatable, use their '__name' metafield, if present.
*/


const __name = to_luastring('__name', true);

const luaT_objtypename = function (L, o) {
  let mt;

  if (o.ttistable() && (mt = o.value.metatable) !== null || o.ttisfulluserdata() && (mt = o.value.metatable) !== null) {
    let name = ltable.luaH_getstr(mt, luaS_bless(L, __name));
    if (name.ttisstring()) return name.svalue();
  }

  return ttypename(o.ttnov());
};

const luaT_callTM = function (L, f, p1, p2, p3, hasres) {
  let func = L.top;
  lobject.pushobj2s(L, f);
  /* push function (assume EXTRA_STACK) */

  lobject.pushobj2s(L, p1);
  /* 1st argument */

  lobject.pushobj2s(L, p2);
  /* 2nd argument */

  if (!hasres)
    /* no result? 'p3' is third argument */
    lobject.pushobj2s(L, p3);
  /* 3rd argument */

  if (L.ci.callstatus & lstate.CIST_LUA) ldo.luaD_call(L, func, hasres);else ldo.luaD_callnoyield(L, func, hasres);

  if (hasres) {
    /* if has result, move it to its place */
    let tv = L.stack[L.top - 1];
    delete L.stack[--L.top];
    p3.setfrom(tv);
  }
};

const luaT_callbinTM = function (L, p1, p2, res, event) {
  let tm = luaT_gettmbyobj(L, p1, event);
  if (tm.ttisnil()) tm = luaT_gettmbyobj(L, p2, event);
  if (tm.ttisnil()) return false;
  luaT_callTM(L, tm, p1, p2, res, 1);
  return true;
};

const luaT_trybinTM = function (L, p1, p2, res, event) {
  if (!luaT_callbinTM(L, p1, p2, res, event)) {
    switch (event) {
      case TMS.TM_CONCAT:
        return ldebug.luaG_concaterror(L, p1, p2);

      case TMS.TM_BAND:
      case TMS.TM_BOR:
      case TMS.TM_BXOR:
      case TMS.TM_SHL:
      case TMS.TM_SHR:
      case TMS.TM_BNOT:
        {
          let n1 = lvm.tonumber(p1);
          let n2 = lvm.tonumber(p2);
          if (n1 !== false && n2 !== false) return ldebug.luaG_tointerror(L, p1, p2);else return ldebug.luaG_opinterror(L, p1, p2, to_luastring("perform bitwise operation on", true));
        }

      default:
        return ldebug.luaG_opinterror(L, p1, p2, to_luastring("perform arithmetic on", true));
    }
  }
};

const luaT_callorderTM = function (L, p1, p2, event) {
  let res = new lobject.TValue();
  if (!luaT_callbinTM(L, p1, p2, res, event)) return null;else return !res.l_isfalse();
};

const fasttm = function (l, et, e) {
  return et === null ? null : et.flags & 1 << e ? null : luaT_gettm(et, e, l.l_G.tmname[e]);
};

const luaT_gettm = function (events, event, ename) {
  const tm = ltable.luaH_getstr(events, ename);
  lua_assert(event <= TMS.TM_EQ);

  if (tm.ttisnil()) {
    /* no tag method? */
    events.flags |= 1 << event;
    /* cache this fact */

    return null;
  } else return tm;
};

const luaT_gettmbyobj = function (L, o, event) {
  let mt;

  switch (o.ttnov()) {
    case LUA_TTABLE:
    case LUA_TUSERDATA:
      mt = o.value.metatable;
      break;

    default:
      mt = L.l_G.mt[o.ttnov()];
  }

  return mt ? ltable.luaH_getstr(mt, L.l_G.tmname[event]) : lobject.luaO_nilobject;
};

module.exports.fasttm = fasttm;
module.exports.TMS = TMS;
module.exports.luaT_callTM = luaT_callTM;
module.exports.luaT_callbinTM = luaT_callbinTM;
module.exports.luaT_trybinTM = luaT_trybinTM;
module.exports.luaT_callorderTM = luaT_callorderTM;
module.exports.luaT_gettm = luaT_gettm;
module.exports.luaT_gettmbyobj = luaT_gettmbyobj;
module.exports.luaT_init = luaT_init;
module.exports.luaT_objtypename = luaT_objtypename;
module.exports.ttypename = ttypename;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MASKLINE,
  LUA_MASKCOUNT,
  LUA_MULTRET,
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TLCF,
    LUA_TLIGHTUSERDATA,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMBER,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR,
    LUA_TTABLE,
    LUA_TUSERDATA
  },
  to_luastring
} = __webpack_require__(1);

const {
  INDEXK,
  ISK,
  LFIELDS_PER_FLUSH,
  OpCodesI: {
    OP_ADD,
    OP_BAND,
    OP_BNOT,
    OP_BOR,
    OP_BXOR,
    OP_CALL,
    OP_CLOSURE,
    OP_CONCAT,
    OP_DIV,
    OP_EQ,
    OP_EXTRAARG,
    OP_FORLOOP,
    OP_FORPREP,
    OP_GETTABLE,
    OP_GETTABUP,
    OP_GETUPVAL,
    OP_IDIV,
    OP_JMP,
    OP_LE,
    OP_LEN,
    OP_LOADBOOL,
    OP_LOADK,
    OP_LOADKX,
    OP_LOADNIL,
    OP_LT,
    OP_MOD,
    OP_MOVE,
    OP_MUL,
    OP_NEWTABLE,
    OP_NOT,
    OP_POW,
    OP_RETURN,
    OP_SELF,
    OP_SETLIST,
    OP_SETTABLE,
    OP_SETTABUP,
    OP_SETUPVAL,
    OP_SHL,
    OP_SHR,
    OP_SUB,
    OP_TAILCALL,
    OP_TEST,
    OP_TESTSET,
    OP_TFORCALL,
    OP_TFORLOOP,
    OP_UNM,
    OP_VARARG
  }
} = __webpack_require__(17);

const {
  LUA_MAXINTEGER,
  LUA_MININTEGER,
  lua_numbertointeger
} = __webpack_require__(4);

const {
  lua_assert,
  luai_nummod
} = __webpack_require__(5);

const lobject = __webpack_require__(7);

const lfunc = __webpack_require__(14);

const lstate = __webpack_require__(13);

const {
  luaS_bless,
  luaS_eqlngstr,
  luaS_hashlongstr
} = __webpack_require__(11);

const ldo = __webpack_require__(9);

const ltm = __webpack_require__(15);

const ltable = __webpack_require__(10);

const ldebug = __webpack_require__(12);
/*
** finish execution of an opcode interrupted by an yield
*/


const luaV_finishOp = function (L) {
  let ci = L.ci;
  let base = ci.l_base;
  let inst = ci.l_code[ci.l_savedpc - 1];
  /* interrupted instruction */

  let op = inst.opcode;

  switch (op) {
    /* finish its execution */
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
    case OP_DIV:
    case OP_IDIV:
    case OP_BAND:
    case OP_BOR:
    case OP_BXOR:
    case OP_SHL:
    case OP_SHR:
    case OP_MOD:
    case OP_POW:
    case OP_UNM:
    case OP_BNOT:
    case OP_LEN:
    case OP_GETTABUP:
    case OP_GETTABLE:
    case OP_SELF:
      {
        lobject.setobjs2s(L, base + inst.A, L.top - 1);
        delete L.stack[--L.top];
        break;
      }

    case OP_LE:
    case OP_LT:
    case OP_EQ:
      {
        let res = !L.stack[L.top - 1].l_isfalse();
        delete L.stack[--L.top];

        if (ci.callstatus & lstate.CIST_LEQ) {
          /* "<=" using "<" instead? */
          lua_assert(op === OP_LE);
          ci.callstatus ^= lstate.CIST_LEQ;
          /* clear mark */

          res = !res;
          /* negate result */
        }

        lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_JMP);
        if (res !== (inst.A ? true : false))
          /* condition failed? */
          ci.l_savedpc++;
        /* skip jump instruction */

        break;
      }

    case OP_CONCAT:
      {
        let top = L.top - 1;
        /* top when 'luaT_trybinTM' was called */

        let b = inst.B;
        /* first element to concatenate */

        let total = top - 1 - (base + b);
        /* yet to concatenate */

        lobject.setobjs2s(L, top - 2, top);
        /* put TM result in proper position */

        if (total > 1) {
          /* are there elements to concat? */
          L.top = top - 1;
          /* top is one after last element (at top-2) */

          luaV_concat(L, total);
          /* concat them (may yield again) */
        }
        /* move final result to final position */


        lobject.setobjs2s(L, ci.l_base + inst.A, L.top - 1);
        ldo.adjust_top(L, ci.top);
        /* restore top */

        break;
      }

    case OP_TFORCALL:
      {
        lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_TFORLOOP);
        ldo.adjust_top(L, ci.top);
        /* correct top */

        break;
      }

    case OP_CALL:
      {
        if (inst.C - 1 >= 0)
          /* nresults >= 0? */
          ldo.adjust_top(L, ci.top);
        /* adjust results */

        break;
      }
  }
};

const RA = function (L, base, i) {
  return base + i.A;
};

const RB = function (L, base, i) {
  return base + i.B;
}; // const RC = function(L, base, i) {
//     return base + i.C;
// };


const RKB = function (L, base, k, i) {
  return ISK(i.B) ? k[INDEXK(i.B)] : L.stack[base + i.B];
};

const RKC = function (L, base, k, i) {
  return ISK(i.C) ? k[INDEXK(i.C)] : L.stack[base + i.C];
};

const luaV_execute = function (L) {
  let ci = L.ci;
  ci.callstatus |= lstate.CIST_FRESH;

  newframe: for (;;) {
    lua_assert(ci === L.ci);
    let cl = ci.func.value;
    let k = cl.p.k;
    let base = ci.l_base;
    let i = ci.l_code[ci.l_savedpc++];

    if (L.hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) {
      ldebug.luaG_traceexec(L);
    }

    let ra = RA(L, base, i);
    let opcode = i.opcode;

    switch (opcode) {
      case OP_MOVE:
        {
          lobject.setobjs2s(L, ra, RB(L, base, i));
          break;
        }

      case OP_LOADK:
        {
          let konst = k[i.Bx];
          lobject.setobj2s(L, ra, konst);
          break;
        }

      case OP_LOADKX:
        {
          lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);
          let konst = k[ci.l_code[ci.l_savedpc++].Ax];
          lobject.setobj2s(L, ra, konst);
          break;
        }

      case OP_LOADBOOL:
        {
          L.stack[ra].setbvalue(i.B !== 0);
          if (i.C !== 0) ci.l_savedpc++;
          /* skip next instruction (if C) */

          break;
        }

      case OP_LOADNIL:
        {
          for (let j = 0; j <= i.B; j++) L.stack[ra + j].setnilvalue();

          break;
        }

      case OP_GETUPVAL:
        {
          let b = i.B;
          lobject.setobj2s(L, ra, cl.upvals[b]);
          break;
        }

      case OP_GETTABUP:
        {
          let upval = cl.upvals[i.B];
          let rc = RKC(L, base, k, i);
          luaV_gettable(L, upval, rc, ra);
          break;
        }

      case OP_GETTABLE:
        {
          let rb = L.stack[RB(L, base, i)];
          let rc = RKC(L, base, k, i);
          luaV_gettable(L, rb, rc, ra);
          break;
        }

      case OP_SETTABUP:
        {
          let upval = cl.upvals[i.A];
          let rb = RKB(L, base, k, i);
          let rc = RKC(L, base, k, i);
          settable(L, upval, rb, rc);
          break;
        }

      case OP_SETUPVAL:
        {
          let uv = cl.upvals[i.B];
          uv.setfrom(L.stack[ra]);
          break;
        }

      case OP_SETTABLE:
        {
          let table = L.stack[ra];
          let key = RKB(L, base, k, i);
          let v = RKC(L, base, k, i);
          settable(L, table, key, v);
          break;
        }

      case OP_NEWTABLE:
        {
          L.stack[ra].sethvalue(ltable.luaH_new(L));
          break;
        }

      case OP_SELF:
        {
          let rb = RB(L, base, i);
          let rc = RKC(L, base, k, i);
          lobject.setobjs2s(L, ra + 1, rb);
          luaV_gettable(L, L.stack[rb], rc, ra);
          break;
        }

      case OP_ADD:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if (op1.ttisinteger() && op2.ttisinteger()) {
            L.stack[ra].setivalue(op1.value + op2.value | 0);
          } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(numberop1 + numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_ADD);
          }

          break;
        }

      case OP_SUB:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if (op1.ttisinteger() && op2.ttisinteger()) {
            L.stack[ra].setivalue(op1.value - op2.value | 0);
          } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(numberop1 - numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SUB);
          }

          break;
        }

      case OP_MUL:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if (op1.ttisinteger() && op2.ttisinteger()) {
            L.stack[ra].setivalue(luaV_imul(op1.value, op2.value));
          } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(numberop1 * numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MUL);
          }

          break;
        }

      case OP_MOD:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if (op1.ttisinteger() && op2.ttisinteger()) {
            L.stack[ra].setivalue(luaV_mod(L, op1.value, op2.value));
          } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(luai_nummod(L, numberop1, numberop2));
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MOD);
          }

          break;
        }

      case OP_POW:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(Math.pow(numberop1, numberop2));
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_POW);
          }

          break;
        }

      case OP_DIV:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(numberop1 / numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_DIV);
          }

          break;
        }

      case OP_IDIV:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if (op1.ttisinteger() && op2.ttisinteger()) {
            L.stack[ra].setivalue(luaV_div(L, op1.value, op2.value));
          } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {
            L.stack[ra].setfltvalue(Math.floor(numberop1 / numberop2));
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_IDIV);
          }

          break;
        }

      case OP_BAND:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {
            L.stack[ra].setivalue(numberop1 & numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BAND);
          }

          break;
        }

      case OP_BOR:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {
            L.stack[ra].setivalue(numberop1 | numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BOR);
          }

          break;
        }

      case OP_BXOR:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {
            L.stack[ra].setivalue(numberop1 ^ numberop2);
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BXOR);
          }

          break;
        }

      case OP_SHL:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {
            L.stack[ra].setivalue(luaV_shiftl(numberop1, numberop2));
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHL);
          }

          break;
        }

      case OP_SHR:
        {
          let op1 = RKB(L, base, k, i);
          let op2 = RKC(L, base, k, i);
          let numberop1, numberop2;

          if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {
            L.stack[ra].setivalue(luaV_shiftl(numberop1, -numberop2));
          } else {
            ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHR);
          }

          break;
        }

      case OP_UNM:
        {
          let op = L.stack[RB(L, base, i)];
          let numberop;

          if (op.ttisinteger()) {
            L.stack[ra].setivalue(-op.value | 0);
          } else if ((numberop = tonumber(op)) !== false) {
            L.stack[ra].setfltvalue(-numberop);
          } else {
            ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_UNM);
          }

          break;
        }

      case OP_BNOT:
        {
          let op = L.stack[RB(L, base, i)];

          if (op.ttisinteger()) {
            L.stack[ra].setivalue(~op.value);
          } else {
            ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_BNOT);
          }

          break;
        }

      case OP_NOT:
        {
          let op = L.stack[RB(L, base, i)];
          L.stack[ra].setbvalue(op.l_isfalse());
          break;
        }

      case OP_LEN:
        {
          luaV_objlen(L, L.stack[ra], L.stack[RB(L, base, i)]);
          break;
        }

      case OP_CONCAT:
        {
          let b = i.B;
          let c = i.C;
          L.top = base + c + 1;
          /* mark the end of concat operands */

          luaV_concat(L, c - b + 1);
          let rb = base + b;
          lobject.setobjs2s(L, ra, rb);
          ldo.adjust_top(L, ci.top);
          /* restore top */

          break;
        }

      case OP_JMP:
        {
          dojump(L, ci, i, 0);
          break;
        }

      case OP_EQ:
        {
          if (luaV_equalobj(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A) ci.l_savedpc++;else donextjump(L, ci);
          break;
        }

      case OP_LT:
        {
          if (luaV_lessthan(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A) ci.l_savedpc++;else donextjump(L, ci);
          break;
        }

      case OP_LE:
        {
          if (luaV_lessequal(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A) ci.l_savedpc++;else donextjump(L, ci);
          break;
        }

      case OP_TEST:
        {
          if (i.C ? L.stack[ra].l_isfalse() : !L.stack[ra].l_isfalse()) ci.l_savedpc++;else donextjump(L, ci);
          break;
        }

      case OP_TESTSET:
        {
          let rbIdx = RB(L, base, i);
          let rb = L.stack[rbIdx];
          if (i.C ? rb.l_isfalse() : !rb.l_isfalse()) ci.l_savedpc++;else {
            lobject.setobjs2s(L, ra, rbIdx);
            donextjump(L, ci);
          }
          break;
        }

      case OP_CALL:
        {
          let b = i.B;
          let nresults = i.C - 1;
          if (b !== 0) ldo.adjust_top(L, ra + b);
          /* else previous instruction set top */

          if (ldo.luaD_precall(L, ra, nresults)) {
            if (nresults >= 0) ldo.adjust_top(L, ci.top);
            /* adjust results */
          } else {
            ci = L.ci;
            continue newframe;
          }

          break;
        }

      case OP_TAILCALL:
        {
          let b = i.B;
          if (b !== 0) ldo.adjust_top(L, ra + b);
          /* else previous instruction set top */

          if (ldo.luaD_precall(L, ra, LUA_MULTRET)) {// JS function
          } else {
            /* tail call: put called frame (n) in place of caller one (o) */
            let nci = L.ci;
            let oci = nci.previous;
            let nfunc = nci.func;
            let nfuncOff = nci.funcOff;
            let ofuncOff = oci.funcOff;
            let lim = nci.l_base + nfunc.value.p.numparams;
            if (cl.p.p.length > 0) lfunc.luaF_close(L, oci.l_base);

            for (let aux = 0; nfuncOff + aux < lim; aux++) lobject.setobjs2s(L, ofuncOff + aux, nfuncOff + aux);

            oci.l_base = ofuncOff + (nci.l_base - nfuncOff);
            oci.top = ofuncOff + (L.top - nfuncOff);
            ldo.adjust_top(L, oci.top);
            /* correct top */

            oci.l_code = nci.l_code;
            oci.l_savedpc = nci.l_savedpc;
            oci.callstatus |= lstate.CIST_TAIL;
            oci.next = null;
            ci = L.ci = oci;
            lua_assert(L.top === oci.l_base + L.stack[ofuncOff].value.p.maxstacksize);
            continue newframe;
          }

          break;
        }

      case OP_RETURN:
        {
          if (cl.p.p.length > 0) lfunc.luaF_close(L, base);
          let b = ldo.luaD_poscall(L, ci, ra, i.B !== 0 ? i.B - 1 : L.top - ra);
          if (ci.callstatus & lstate.CIST_FRESH) return;
          /* external invocation: return */

          /* invocation via reentry: continue execution */

          ci = L.ci;
          if (b) ldo.adjust_top(L, ci.top);
          lua_assert(ci.callstatus & lstate.CIST_LUA);
          lua_assert(ci.l_code[ci.l_savedpc - 1].opcode === OP_CALL);
          continue newframe;
        }

      case OP_FORLOOP:
        {
          if (L.stack[ra].ttisinteger()) {
            /* integer loop? */
            let step = L.stack[ra + 2].value;
            let idx = L.stack[ra].value + step | 0;
            let limit = L.stack[ra + 1].value;

            if (0 < step ? idx <= limit : limit <= idx) {
              ci.l_savedpc += i.sBx;
              L.stack[ra].chgivalue(idx);
              /* update internal index... */

              L.stack[ra + 3].setivalue(idx);
            }
          } else {
            /* floating loop */
            let step = L.stack[ra + 2].value;
            let idx = L.stack[ra].value + step;
            let limit = L.stack[ra + 1].value;

            if (0 < step ? idx <= limit : limit <= idx) {
              ci.l_savedpc += i.sBx;
              L.stack[ra].chgfltvalue(idx);
              /* update internal index... */

              L.stack[ra + 3].setfltvalue(idx);
            }
          }

          break;
        }

      case OP_FORPREP:
        {
          let init = L.stack[ra];
          let plimit = L.stack[ra + 1];
          let pstep = L.stack[ra + 2];
          let forlim;

          if (init.ttisinteger() && pstep.ttisinteger() && (forlim = forlimit(plimit, pstep.value))) {
            /* all values are integer */
            let initv = forlim.stopnow ? 0 : init.value;
            plimit.value = forlim.ilimit;
            init.value = initv - pstep.value | 0;
          } else {
            /* try making all values floats */
            let nlimit, nstep, ninit;
            if ((nlimit = tonumber(plimit)) === false) ldebug.luaG_runerror(L, to_luastring("'for' limit must be a number", true));
            L.stack[ra + 1].setfltvalue(nlimit);
            if ((nstep = tonumber(pstep)) === false) ldebug.luaG_runerror(L, to_luastring("'for' step must be a number", true));
            L.stack[ra + 2].setfltvalue(nstep);
            if ((ninit = tonumber(init)) === false) ldebug.luaG_runerror(L, to_luastring("'for' initial value must be a number", true));
            L.stack[ra].setfltvalue(ninit - nstep);
          }

          ci.l_savedpc += i.sBx;
          break;
        }

      case OP_TFORCALL:
        {
          let cb = ra + 3;
          /* call base */

          lobject.setobjs2s(L, cb + 2, ra + 2);
          lobject.setobjs2s(L, cb + 1, ra + 1);
          lobject.setobjs2s(L, cb, ra);
          ldo.adjust_top(L, cb + 3);
          /* func. + 2 args (state and index) */

          ldo.luaD_call(L, cb, i.C);
          ldo.adjust_top(L, ci.top);
          /* go straight to OP_TFORLOOP */

          i = ci.l_code[ci.l_savedpc++];
          ra = RA(L, base, i);
          lua_assert(i.opcode === OP_TFORLOOP);
        }

      /* fall through */

      case OP_TFORLOOP:
        {
          if (!L.stack[ra + 1].ttisnil()) {
            /* continue loop? */
            lobject.setobjs2s(L, ra, ra + 1);
            /* save control variable */

            ci.l_savedpc += i.sBx;
            /* jump back */
          }

          break;
        }

      case OP_SETLIST:
        {
          let n = i.B;
          let c = i.C;
          if (n === 0) n = L.top - ra - 1;

          if (c === 0) {
            lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);
            c = ci.l_code[ci.l_savedpc++].Ax;
          }

          let h = L.stack[ra].value;
          let last = (c - 1) * LFIELDS_PER_FLUSH + n;

          for (; n > 0; n--) {
            ltable.luaH_setint(h, last--, L.stack[ra + n]);
          }

          ldo.adjust_top(L, ci.top);
          /* correct top (in case of previous open call) */

          break;
        }

      case OP_CLOSURE:
        {
          let p = cl.p.p[i.Bx];
          let ncl = getcached(p, cl.upvals, L.stack, base);
          /* cached closure */

          if (ncl === null)
            /* no match? */
            pushclosure(L, p, cl.upvals, base, ra);
            /* create a new one */
          else L.stack[ra].setclLvalue(ncl);
          break;
        }

      case OP_VARARG:
        {
          let b = i.B - 1;
          let n = base - ci.funcOff - cl.p.numparams - 1;
          let j;
          if (n < 0)
            /* less arguments than parameters? */
            n = 0;
          /* no vararg arguments */

          if (b < 0) {
            b = n;
            /* get all var. arguments */

            ldo.luaD_checkstack(L, n);
            ldo.adjust_top(L, ra + n);
          }

          for (j = 0; j < b && j < n; j++) lobject.setobjs2s(L, ra + j, base - n + j);

          for (; j < b; j++)
          /* complete required results with nil */
          L.stack[ra + j].setnilvalue();

          break;
        }

      case OP_EXTRAARG:
        {
          throw Error("invalid opcode");
        }
    }
  }
};

const dojump = function (L, ci, i, e) {
  let a = i.A;
  if (a !== 0) lfunc.luaF_close(L, ci.l_base + a - 1);
  ci.l_savedpc += i.sBx + e;
};

const donextjump = function (L, ci) {
  dojump(L, ci, ci.l_code[ci.l_savedpc], 1);
};

const luaV_lessthan = function (L, l, r) {
  if (l.ttisnumber() && r.ttisnumber()) return LTnum(l, r) ? 1 : 0;else if (l.ttisstring() && r.ttisstring()) return l_strcmp(l.tsvalue(), r.tsvalue()) < 0 ? 1 : 0;else {
    let res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LT);
    if (res === null) ldebug.luaG_ordererror(L, l, r);
    return res ? 1 : 0;
  }
};

const luaV_lessequal = function (L, l, r) {
  let res;
  if (l.ttisnumber() && r.ttisnumber()) return LEnum(l, r) ? 1 : 0;else if (l.ttisstring() && r.ttisstring()) return l_strcmp(l.tsvalue(), r.tsvalue()) <= 0 ? 1 : 0;else {
    res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LE);
    if (res !== null) return res ? 1 : 0;
  }
  /* try 'lt': */

  L.ci.callstatus |= lstate.CIST_LEQ;
  /* mark it is doing 'lt' for 'le' */

  res = ltm.luaT_callorderTM(L, r, l, ltm.TMS.TM_LT);
  L.ci.callstatus ^= lstate.CIST_LEQ;
  /* clear mark */

  if (res === null) ldebug.luaG_ordererror(L, l, r);
  return res ? 0 : 1;
  /* result is negated */
};

const luaV_equalobj = function (L, t1, t2) {
  if (t1.ttype() !== t2.ttype()) {
    /* not the same variant? */
    if (t1.ttnov() !== t2.ttnov() || t1.ttnov() !== LUA_TNUMBER) return 0;
    /* only numbers can be equal with different variants */
    else {
        /* two numbers with different variants */

        /* OPTIMIZATION: instead of calling luaV_tointeger we can just let JS do the comparison */
        return t1.value === t2.value ? 1 : 0;
      }
  }

  let tm;
  /* values have same type and same variant */

  switch (t1.ttype()) {
    case LUA_TNIL:
      return 1;

    case LUA_TBOOLEAN:
      return t1.value == t2.value ? 1 : 0;
    // Might be 1 or true

    case LUA_TLIGHTUSERDATA:
    case LUA_TNUMINT:
    case LUA_TNUMFLT:
    case LUA_TLCF:
      return t1.value === t2.value ? 1 : 0;

    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      {
        return luaS_eqlngstr(t1.tsvalue(), t2.tsvalue()) ? 1 : 0;
      }

    case LUA_TUSERDATA:
    case LUA_TTABLE:
      if (t1.value === t2.value) return 1;else if (L === null) return 0;
      tm = ltm.fasttm(L, t1.value.metatable, ltm.TMS.TM_EQ);
      if (tm === null) tm = ltm.fasttm(L, t2.value.metatable, ltm.TMS.TM_EQ);
      break;

    default:
      return t1.value === t2.value ? 1 : 0;
  }

  if (tm === null)
    /* no TM? */
    return 0;
  let tv = new lobject.TValue();
  /* doesn't use the stack */

  ltm.luaT_callTM(L, tm, t1, t2, tv, 1);
  return tv.l_isfalse() ? 0 : 1;
};

const luaV_rawequalobj = function (t1, t2) {
  return luaV_equalobj(null, t1, t2);
};

const forlimit = function (obj, step) {
  let stopnow = false;
  let ilimit = luaV_tointeger(obj, step < 0 ? 2 : 1);

  if (ilimit === false) {
    let n = tonumber(obj);
    if (n === false) return false;

    if (0 < n) {
      ilimit = LUA_MAXINTEGER;
      if (step < 0) stopnow = true;
    } else {
      ilimit = LUA_MININTEGER;
      if (step >= 0) stopnow = true;
    }
  }

  return {
    stopnow: stopnow,
    ilimit: ilimit
  };
};
/*
** try to convert a value to an integer, rounding according to 'mode':
** mode === 0: accepts only integral values
** mode === 1: takes the floor of the number
** mode === 2: takes the ceil of the number
*/


const luaV_tointeger = function (obj, mode) {
  if (obj.ttisfloat()) {
    let n = obj.value;
    let f = Math.floor(n);

    if (n !== f) {
      /* not an integral value? */
      if (mode === 0) return false;
      /* fails if mode demands integral value */
      else if (mode > 1)
          /* needs ceil? */
          f += 1;
      /* convert floor to ceil (remember: n !== f) */
    }

    return lua_numbertointeger(f);
  } else if (obj.ttisinteger()) {
    return obj.value;
  } else if (cvt2num(obj)) {
    let v = new lobject.TValue();
    if (lobject.luaO_str2num(obj.svalue(), v) === obj.vslen() + 1) return luaV_tointeger(v, mode);
  }

  return false;
};

const tointeger = function (o) {
  return o.ttisinteger() ? o.value : luaV_tointeger(o, 0);
};

const tonumber = function (o) {
  if (o.ttnov() === LUA_TNUMBER) return o.value;

  if (cvt2num(o)) {
    /* string convertible to number? */
    let v = new lobject.TValue();
    if (lobject.luaO_str2num(o.svalue(), v) === o.vslen() + 1) return v.value;
  }

  return false;
};
/*
** Return 'l < r', for numbers.
** As fengari uses javascript numbers for both floats and integers and has
** correct semantics, we can just compare values.
*/


const LTnum = function (l, r) {
  return l.value < r.value;
};
/*
** Return 'l <= r', for numbers.
*/


const LEnum = function (l, r) {
  return l.value <= r.value;
};
/*
** Compare two strings 'ls' x 'rs', returning an integer smaller-equal-
** -larger than zero if 'ls' is smaller-equal-larger than 'rs'.
*/


const l_strcmp = function (ls, rs) {
  let l = luaS_hashlongstr(ls);
  let r = luaS_hashlongstr(rs);
  /* In fengari we assume string hash has same collation as byte values */

  if (l === r) return 0;else if (l < r) return -1;else return 1;
};
/*
** Main operation 'ra' = #rb'.
*/


const luaV_objlen = function (L, ra, rb) {
  let tm;

  switch (rb.ttype()) {
    case LUA_TTABLE:
      {
        let h = rb.value;
        tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_LEN);
        if (tm !== null) break;
        /* metamethod? break switch to call it */

        ra.setivalue(ltable.luaH_getn(h));
        /* else primitive len */

        return;
      }

    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      ra.setivalue(rb.vslen());
      return;

    default:
      {
        tm = ltm.luaT_gettmbyobj(L, rb, ltm.TMS.TM_LEN);
        if (tm.ttisnil()) ldebug.luaG_typeerror(L, rb, to_luastring("get length of", true));
        break;
      }
  }

  ltm.luaT_callTM(L, tm, rb, rb, ra, 1);
};
/* Shim taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul */


const luaV_imul = Math.imul || function (a, b) {
  let aHi = a >>> 16 & 0xffff;
  let aLo = a & 0xffff;
  let bHi = b >>> 16 & 0xffff;
  let bLo = b & 0xffff;
  /*
  ** the shift by 0 fixes the sign on the high part
  ** the final |0 converts the unsigned value into a signed value
  */

  return aLo * bLo + (aHi * bLo + aLo * bHi << 16 >>> 0) | 0;
};

const luaV_div = function (L, m, n) {
  if (n === 0) ldebug.luaG_runerror(L, to_luastring("attempt to divide by zero"));
  return Math.floor(m / n) | 0;
}; // % semantic on negative numbers is different in js


const luaV_mod = function (L, m, n) {
  if (n === 0) ldebug.luaG_runerror(L, to_luastring("attempt to perform 'n%%0'"));
  return m - Math.floor(m / n) * n | 0;
};

const NBITS = 32;

const luaV_shiftl = function (x, y) {
  if (y < 0) {
    /* shift right? */
    if (y <= -NBITS) return 0;else return x >>> -y;
  } else {
    /* shift left */
    if (y >= NBITS) return 0;else return x << y;
  }
};
/*
** check whether cached closure in prototype 'p' may be reused, that is,
** whether there is a cached closure with the same upvalues needed by
** new closure to be created.
*/


const getcached = function (p, encup, stack, base) {
  let c = p.cache;

  if (c !== null) {
    /* is there a cached closure? */
    let uv = p.upvalues;
    let nup = uv.length;

    for (let i = 0; i < nup; i++) {
      /* check whether it has right upvalues */
      let v = uv[i].instack ? stack[base + uv[i].idx] : encup[uv[i].idx];
      if (c.upvals[i] !== v) return null;
      /* wrong upvalue; cannot reuse closure */
    }
  }

  return c;
  /* return cached closure (or NULL if no cached closure) */
};
/*
** create a new Lua closure, push it in the stack, and initialize
** its upvalues.
*/


const pushclosure = function (L, p, encup, base, ra) {
  let nup = p.upvalues.length;
  let uv = p.upvalues;
  let ncl = new lobject.LClosure(L, nup);
  ncl.p = p;
  L.stack[ra].setclLvalue(ncl);

  for (let i = 0; i < nup; i++) {
    if (uv[i].instack) ncl.upvals[i] = lfunc.luaF_findupval(L, base + uv[i].idx);else ncl.upvals[i] = encup[uv[i].idx];
  }

  p.cache = ncl;
  /* save it on cache for reuse */
};

const cvt2str = function (o) {
  return o.ttisnumber();
};

const cvt2num = function (o) {
  return o.ttisstring();
};

const tostring = function (L, i) {
  let o = L.stack[i];
  if (o.ttisstring()) return true;

  if (cvt2str(o)) {
    lobject.luaO_tostring(L, o);
    return true;
  }

  return false;
};

const isemptystr = function (o) {
  return o.ttisstring() && o.vslen() === 0;
};
/* copy strings in stack from top - n up to top - 1 to buffer */


const copy2buff = function (L, top, n, buff) {
  let tl = 0;
  /* size already copied */

  do {
    let tv = L.stack[top - n];
    let l = tv.vslen();
    /* length of string being copied */

    let s = tv.svalue();
    buff.set(s, tl);
    tl += l;
  } while (--n > 0);
};
/*
** Main operation for concatenation: concat 'total' values in the stack,
** from 'L->top - total' up to 'L->top - 1'.
*/


const luaV_concat = function (L, total) {
  lua_assert(total >= 2);

  do {
    let top = L.top;
    let n = 2;
    /* number of elements handled in this pass (at least 2) */

    if (!(L.stack[top - 2].ttisstring() || cvt2str(L.stack[top - 2])) || !tostring(L, top - 1)) {
      ltm.luaT_trybinTM(L, L.stack[top - 2], L.stack[top - 1], L.stack[top - 2], ltm.TMS.TM_CONCAT);
    } else if (isemptystr(L.stack[top - 1])) {
      tostring(L, top - 2);
    } else if (isemptystr(L.stack[top - 2])) {
      lobject.setobjs2s(L, top - 2, top - 1);
    } else {
      /* at least two non-empty string values; get as many as possible */
      let tl = L.stack[top - 1].vslen();
      /* collect total length and number of strings */

      for (n = 1; n < total && tostring(L, top - n - 1); n++) {
        let l = L.stack[top - n - 1].vslen();
        tl += l;
      }

      let buff = new Uint8Array(tl);
      copy2buff(L, top, n, buff);
      let ts = luaS_bless(L, buff);
      lobject.setsvalue2s(L, top - n, ts);
    }

    total -= n - 1;
    /* got 'n' strings to create 1 new */

    /* popped 'n' strings and pushed one */

    for (; L.top > top - (n - 1);) delete L.stack[--L.top];
  } while (total > 1);
  /* repeat until only 1 result left */

};

const MAXTAGLOOP = 2000;

const luaV_gettable = function (L, t, key, ra) {
  for (let loop = 0; loop < MAXTAGLOOP; loop++) {
    let tm;

    if (!t.ttistable()) {
      tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_INDEX);
      if (tm.ttisnil()) ldebug.luaG_typeerror(L, t, to_luastring('index', true));
      /* no metamethod */

      /* else will try the metamethod */
    } else {
      let slot = ltable.luaH_get(L, t.value, key);

      if (!slot.ttisnil()) {
        lobject.setobj2s(L, ra, slot);
        return;
      } else {
        /* 't' is a table */
        tm = ltm.fasttm(L, t.value.metatable, ltm.TMS.TM_INDEX);
        /* table's metamethod */

        if (tm === null) {
          /* no metamethod? */
          L.stack[ra].setnilvalue();
          /* result is nil */

          return;
        }
      }
      /* else will try the metamethod */

    }

    if (tm.ttisfunction()) {
      /* is metamethod a function? */
      ltm.luaT_callTM(L, tm, t, key, L.stack[ra], 1);
      /* call it */

      return;
    }

    t = tm;
    /* else try to access 'tm[key]' */
  }

  ldebug.luaG_runerror(L, to_luastring("'__index' chain too long; possible loop", true));
};

const settable = function (L, t, key, val) {
  for (let loop = 0; loop < MAXTAGLOOP; loop++) {
    let tm;

    if (t.ttistable()) {
      let h = t.value;
      /* save 't' table */

      let slot = ltable.luaH_get(L, h, key);

      if (!slot.ttisnil() || (tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_NEWINDEX)) === null) {
        ltable.luaH_setfrom(L, h, key, val);
        ltable.invalidateTMcache(h);
        return;
      }
      /* else will try the metamethod */

    } else {
      /* not a table; check metamethod */
      if ((tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_NEWINDEX)).ttisnil()) ldebug.luaG_typeerror(L, t, to_luastring('index', true));
    }
    /* try the metamethod */


    if (tm.ttisfunction()) {
      ltm.luaT_callTM(L, tm, t, key, val, 0);
      return;
    }

    t = tm;
    /* else repeat assignment over 'tm' */
  }

  ldebug.luaG_runerror(L, to_luastring("'__newindex' chain too long; possible loop", true));
};

module.exports.cvt2str = cvt2str;
module.exports.cvt2num = cvt2num;
module.exports.luaV_gettable = luaV_gettable;
module.exports.luaV_concat = luaV_concat;
module.exports.luaV_div = luaV_div;
module.exports.luaV_equalobj = luaV_equalobj;
module.exports.luaV_execute = luaV_execute;
module.exports.luaV_finishOp = luaV_finishOp;
module.exports.luaV_imul = luaV_imul;
module.exports.luaV_lessequal = luaV_lessequal;
module.exports.luaV_lessthan = luaV_lessthan;
module.exports.luaV_mod = luaV_mod;
module.exports.luaV_objlen = luaV_objlen;
module.exports.luaV_rawequalobj = luaV_rawequalobj;
module.exports.luaV_shiftl = luaV_shiftl;
module.exports.luaV_tointeger = luaV_tointeger;
module.exports.settable = settable;
module.exports.tointeger = tointeger;
module.exports.tonumber = tonumber;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const OpCodes = ["MOVE", "LOADK", "LOADKX", "LOADBOOL", "LOADNIL", "GETUPVAL", "GETTABUP", "GETTABLE", "SETTABUP", "SETUPVAL", "SETTABLE", "NEWTABLE", "SELF", "ADD", "SUB", "MUL", "MOD", "POW", "DIV", "IDIV", "BAND", "BOR", "BXOR", "SHL", "SHR", "UNM", "BNOT", "NOT", "LEN", "CONCAT", "JMP", "EQ", "LT", "LE", "TEST", "TESTSET", "CALL", "TAILCALL", "RETURN", "FORLOOP", "FORPREP", "TFORCALL", "TFORLOOP", "SETLIST", "CLOSURE", "VARARG", "EXTRAARG"];
const OpCodesI = {
  OP_MOVE: 0,
  OP_LOADK: 1,
  OP_LOADKX: 2,
  OP_LOADBOOL: 3,
  OP_LOADNIL: 4,
  OP_GETUPVAL: 5,
  OP_GETTABUP: 6,
  OP_GETTABLE: 7,
  OP_SETTABUP: 8,
  OP_SETUPVAL: 9,
  OP_SETTABLE: 10,
  OP_NEWTABLE: 11,
  OP_SELF: 12,
  OP_ADD: 13,
  OP_SUB: 14,
  OP_MUL: 15,
  OP_MOD: 16,
  OP_POW: 17,
  OP_DIV: 18,
  OP_IDIV: 19,
  OP_BAND: 20,
  OP_BOR: 21,
  OP_BXOR: 22,
  OP_SHL: 23,
  OP_SHR: 24,
  OP_UNM: 25,
  OP_BNOT: 26,
  OP_NOT: 27,
  OP_LEN: 28,
  OP_CONCAT: 29,
  OP_JMP: 30,
  OP_EQ: 31,
  OP_LT: 32,
  OP_LE: 33,
  OP_TEST: 34,
  OP_TESTSET: 35,
  OP_CALL: 36,
  OP_TAILCALL: 37,
  OP_RETURN: 38,
  OP_FORLOOP: 39,
  OP_FORPREP: 40,
  OP_TFORCALL: 41,
  OP_TFORLOOP: 42,
  OP_SETLIST: 43,
  OP_CLOSURE: 44,
  OP_VARARG: 45,
  OP_EXTRAARG: 46
};
/*
** masks for instruction properties. The format is:
** bits 0-1: op mode
** bits 2-3: C arg mode
** bits 4-5: B arg mode
** bit 6: instruction set register A
** bit 7: operator is a test (next instruction must be a jump)
*/

const OpArgN = 0;
/* argument is not used */

const OpArgU = 1;
/* argument is used */

const OpArgR = 2;
/* argument is a register or a jump offset */

const OpArgK = 3;
/* argument is a constant or register/constant */

/* basic instruction format */

const iABC = 0;
const iABx = 1;
const iAsBx = 2;
const iAx = 3;
const luaP_opmodes = [0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,
/* OP_MOVE */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgN << 2 | iABx,
/* OP_LOADK */
0 << 7 | 1 << 6 | OpArgN << 4 | OpArgN << 2 | iABx,
/* OP_LOADKX */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,
/* OP_LOADBOOL */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,
/* OP_LOADNIL */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,
/* OP_GETUPVAL */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgK << 2 | iABC,
/* OP_GETTABUP */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,
/* OP_GETTABLE */
0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_SETTABUP */
0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,
/* OP_SETUPVAL */
0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_SETTABLE */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,
/* OP_NEWTABLE */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,
/* OP_SELF */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_ADD */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_SUB */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_MUL */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_MOD */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_POW */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_DIV */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_IDIV */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_BAND */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_BOR */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_BXOR */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_SHL */
0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_SHR */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,
/* OP_UNM */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,
/* OP_BNOT */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,
/* OP_NOT */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,
/* OP_LEN */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgR << 2 | iABC,
/* OP_CONCAT */
0 << 7 | 0 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,
/* OP_JMP */
1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_EQ */
1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_LT */
1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,
/* OP_LE */
1 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,
/* OP_TEST */
1 << 7 | 1 << 6 | OpArgR << 4 | OpArgU << 2 | iABC,
/* OP_TESTSET */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,
/* OP_CALL */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,
/* OP_TAILCALL */
0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,
/* OP_RETURN */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,
/* OP_FORLOOP */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,
/* OP_FORPREP */
0 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,
/* OP_TFORCALL */
0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,
/* OP_TFORLOOP */
0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,
/* OP_SETLIST */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABx,
/* OP_CLOSURE */
0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,
/* OP_VARARG */
0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iAx
/* OP_EXTRAARG */
];

const getOpMode = function (m) {
  return luaP_opmodes[m] & 3;
};

const getBMode = function (m) {
  return luaP_opmodes[m] >> 4 & 3;
};

const getCMode = function (m) {
  return luaP_opmodes[m] >> 2 & 3;
};

const testAMode = function (m) {
  return luaP_opmodes[m] & 1 << 6;
};

const testTMode = function (m) {
  return luaP_opmodes[m] & 1 << 7;
};

const SIZE_C = 9;
const SIZE_B = 9;
const SIZE_Bx = SIZE_C + SIZE_B;
const SIZE_A = 8;
const SIZE_Ax = SIZE_C + SIZE_B + SIZE_A;
const SIZE_OP = 6;
const POS_OP = 0;
const POS_A = POS_OP + SIZE_OP;
const POS_C = POS_A + SIZE_A;
const POS_B = POS_C + SIZE_C;
const POS_Bx = POS_C;
const POS_Ax = POS_A;
const MAXARG_Bx = (1 << SIZE_Bx) - 1;
const MAXARG_sBx = MAXARG_Bx >> 1;
/* 'sBx' is signed */

const MAXARG_Ax = (1 << SIZE_Ax) - 1;
const MAXARG_A = (1 << SIZE_A) - 1;
const MAXARG_B = (1 << SIZE_B) - 1;
const MAXARG_C = (1 << SIZE_C) - 1;
/* this bit 1 means constant (0 means register) */

const BITRK = 1 << SIZE_B - 1;
const MAXINDEXRK = BITRK - 1;
/*
** invalid register that fits in 8 bits
*/

const NO_REG = MAXARG_A;
/* test whether value is a constant */

const ISK = function (x) {
  return x & BITRK;
};
/* gets the index of the constant */


const INDEXK = function (r) {
  return r & ~BITRK;
};
/* code a constant index as a RK value */


const RKASK = function (x) {
  return x | BITRK;
};
/* creates a mask with 'n' 1 bits at position 'p' */


const MASK1 = function (n, p) {
  return ~(~0 << n) << p;
};
/* creates a mask with 'n' 0 bits at position 'p' */


const MASK0 = function (n, p) {
  return ~MASK1(n, p);
};

const GET_OPCODE = function (i) {
  return i.opcode;
};

const SET_OPCODE = function (i, o) {
  i.code = i.code & MASK0(SIZE_OP, POS_OP) | o << POS_OP & MASK1(SIZE_OP, POS_OP);
  return fullins(i);
};

const setarg = function (i, v, pos, size) {
  i.code = i.code & MASK0(size, pos) | v << pos & MASK1(size, pos);
  return fullins(i);
};

const GETARG_A = function (i) {
  return i.A;
};

const SETARG_A = function (i, v) {
  return setarg(i, v, POS_A, SIZE_A);
};

const GETARG_B = function (i) {
  return i.B;
};

const SETARG_B = function (i, v) {
  return setarg(i, v, POS_B, SIZE_B);
};

const GETARG_C = function (i) {
  return i.C;
};

const SETARG_C = function (i, v) {
  return setarg(i, v, POS_C, SIZE_C);
};

const GETARG_Bx = function (i) {
  return i.Bx;
};

const SETARG_Bx = function (i, v) {
  return setarg(i, v, POS_Bx, SIZE_Bx);
};

const GETARG_Ax = function (i) {
  return i.Ax;
};

const SETARG_Ax = function (i, v) {
  return setarg(i, v, POS_Ax, SIZE_Ax);
};

const GETARG_sBx = function (i) {
  return i.sBx;
};

const SETARG_sBx = function (i, b) {
  return SETARG_Bx(i, b + MAXARG_sBx);
};
/*
** Pre-calculate all possible part of the instruction
*/


const fullins = function (ins) {
  if (typeof ins === "number") {
    return {
      code: ins,
      opcode: ins >> POS_OP & MASK1(SIZE_OP, 0),
      A: ins >> POS_A & MASK1(SIZE_A, 0),
      B: ins >> POS_B & MASK1(SIZE_B, 0),
      C: ins >> POS_C & MASK1(SIZE_C, 0),
      Bx: ins >> POS_Bx & MASK1(SIZE_Bx, 0),
      Ax: ins >> POS_Ax & MASK1(SIZE_Ax, 0),
      sBx: (ins >> POS_Bx & MASK1(SIZE_Bx, 0)) - MAXARG_sBx
    };
  } else {
    let i = ins.code;
    ins.opcode = i >> POS_OP & MASK1(SIZE_OP, 0);
    ins.A = i >> POS_A & MASK1(SIZE_A, 0);
    ins.B = i >> POS_B & MASK1(SIZE_B, 0);
    ins.C = i >> POS_C & MASK1(SIZE_C, 0);
    ins.Bx = i >> POS_Bx & MASK1(SIZE_Bx, 0);
    ins.Ax = i >> POS_Ax & MASK1(SIZE_Ax, 0);
    ins.sBx = (i >> POS_Bx & MASK1(SIZE_Bx, 0)) - MAXARG_sBx;
    return ins;
  }
};

const CREATE_ABC = function (o, a, b, c) {
  return fullins(o << POS_OP | a << POS_A | b << POS_B | c << POS_C);
};

const CREATE_ABx = function (o, a, bc) {
  return fullins(o << POS_OP | a << POS_A | bc << POS_Bx);
};

const CREATE_Ax = function (o, a) {
  return fullins(o << POS_OP | a << POS_Ax);
};
/* number of list items to accumulate before a SETLIST instruction */


const LFIELDS_PER_FLUSH = 50;
module.exports.BITRK = BITRK;
module.exports.CREATE_ABC = CREATE_ABC;
module.exports.CREATE_ABx = CREATE_ABx;
module.exports.CREATE_Ax = CREATE_Ax;
module.exports.GET_OPCODE = GET_OPCODE;
module.exports.GETARG_A = GETARG_A;
module.exports.GETARG_B = GETARG_B;
module.exports.GETARG_C = GETARG_C;
module.exports.GETARG_Bx = GETARG_Bx;
module.exports.GETARG_Ax = GETARG_Ax;
module.exports.GETARG_sBx = GETARG_sBx;
module.exports.INDEXK = INDEXK;
module.exports.ISK = ISK;
module.exports.LFIELDS_PER_FLUSH = LFIELDS_PER_FLUSH;
module.exports.MAXARG_A = MAXARG_A;
module.exports.MAXARG_Ax = MAXARG_Ax;
module.exports.MAXARG_B = MAXARG_B;
module.exports.MAXARG_Bx = MAXARG_Bx;
module.exports.MAXARG_C = MAXARG_C;
module.exports.MAXARG_sBx = MAXARG_sBx;
module.exports.MAXINDEXRK = MAXINDEXRK;
module.exports.NO_REG = NO_REG;
module.exports.OpArgK = OpArgK;
module.exports.OpArgN = OpArgN;
module.exports.OpArgR = OpArgR;
module.exports.OpArgU = OpArgU;
module.exports.OpCodes = OpCodes;
module.exports.OpCodesI = OpCodesI;
module.exports.POS_A = POS_A;
module.exports.POS_Ax = POS_Ax;
module.exports.POS_B = POS_B;
module.exports.POS_Bx = POS_Bx;
module.exports.POS_C = POS_C;
module.exports.POS_OP = POS_OP;
module.exports.RKASK = RKASK;
module.exports.SETARG_A = SETARG_A;
module.exports.SETARG_Ax = SETARG_Ax;
module.exports.SETARG_B = SETARG_B;
module.exports.SETARG_Bx = SETARG_Bx;
module.exports.SETARG_C = SETARG_C;
module.exports.SETARG_sBx = SETARG_sBx;
module.exports.SET_OPCODE = SET_OPCODE;
module.exports.SIZE_A = SIZE_A;
module.exports.SIZE_Ax = SIZE_Ax;
module.exports.SIZE_B = SIZE_B;
module.exports.SIZE_Bx = SIZE_Bx;
module.exports.SIZE_C = SIZE_C;
module.exports.SIZE_OP = SIZE_OP;
module.exports.fullins = fullins;
module.exports.getBMode = getBMode;
module.exports.getCMode = getCMode;
module.exports.getOpMode = getOpMode;
module.exports.iABC = iABC;
module.exports.iABx = iABx;
module.exports.iAsBx = iAsBx;
module.exports.iAx = iAx;
module.exports.testAMode = testAMode;
module.exports.testTMode = testTMode;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_VERSION_MAJOR,
  LUA_VERSION_MINOR
} = __webpack_require__(2);

const LUA_VERSUFFIX = "_" + LUA_VERSION_MAJOR + "_" + LUA_VERSION_MINOR;
module.exports.LUA_VERSUFFIX = LUA_VERSUFFIX;

module.exports.lua_assert = function (c) {};

module.exports.luaopen_base = __webpack_require__(35).luaopen_base;
const LUA_COLIBNAME = "coroutine";
module.exports.LUA_COLIBNAME = LUA_COLIBNAME;
module.exports.luaopen_coroutine = __webpack_require__(36).luaopen_coroutine;
const LUA_TABLIBNAME = "table";
module.exports.LUA_TABLIBNAME = LUA_TABLIBNAME;
module.exports.luaopen_table = __webpack_require__(37).luaopen_table;

if (false) {}

const LUA_OSLIBNAME = "os";
module.exports.LUA_OSLIBNAME = LUA_OSLIBNAME;
module.exports.luaopen_os = __webpack_require__(38).luaopen_os;
const LUA_STRLIBNAME = "string";
module.exports.LUA_STRLIBNAME = LUA_STRLIBNAME;
module.exports.luaopen_string = __webpack_require__(39).luaopen_string;
const LUA_UTF8LIBNAME = "utf8";
module.exports.LUA_UTF8LIBNAME = LUA_UTF8LIBNAME;
module.exports.luaopen_utf8 = __webpack_require__(40).luaopen_utf8;
const LUA_BITLIBNAME = "bit32";
module.exports.LUA_BITLIBNAME = LUA_BITLIBNAME; // module.exports.luaopen_bit32 = require("./lbitlib.js").luaopen_bit32;

const LUA_MATHLIBNAME = "math";
module.exports.LUA_MATHLIBNAME = LUA_MATHLIBNAME;
module.exports.luaopen_math = __webpack_require__(41).luaopen_math;
const LUA_DBLIBNAME = "debug";
module.exports.LUA_DBLIBNAME = LUA_DBLIBNAME;
module.exports.luaopen_debug = __webpack_require__(42).luaopen_debug;
const LUA_LOADLIBNAME = "package";
module.exports.LUA_LOADLIBNAME = LUA_LOADLIBNAME;
module.exports.luaopen_package = __webpack_require__(43).luaopen_package;
const LUA_FENGARILIBNAME = "fengari";
module.exports.LUA_FENGARILIBNAME = LUA_FENGARILIBNAME;
module.exports.luaopen_fengari = __webpack_require__(44).luaopen_fengari;

const linit = __webpack_require__(68);

module.exports.luaL_openlibs = linit.luaL_openlibs;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__19__;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
 * The Operate Lua VM can be easily extended, either with native Lua modules,
 * or JavaScript code that is added to the Lua VM as functions.
 *
 * @interface Extension
 * @hideconstructor
 */
class Extension {
  /**
   * @abstract
   * @param {Object} vm
   */
  static extend(vm) {}

}

module.exports = Extension;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);
/**
 * TODO
 */


const util = {
  /**
   * TODO
   */
  encode(data, encoding) {
    switch (encoding) {
      case 'base64':
      case 'hex':
        return binary.to(data, encoding);

      default:
        return binary.to(data);
    }
  },

  /**
   * TODO
   */
  decode(data, encoding) {
    if (binary.is(data)) return data;

    switch (encoding) {
      case 'base64':
      case 'hex':
        return binary.from(data, encoding);

      default:
        return binary.from(data);
    }
  },

  /**
   * TODO
   */
  importKey(key, algo, usages) {
    const format = binary.is(key) ? 'raw' : 'jwk';
    return crypto.subtle.importKey(format, key, algo, false, usages);
  },

  /**
   * TODO
   */
  varIntEncode(val) {
    let buf;

    if (val < 253) {
      buf = binary.create(1);
      binary.writeUInt8(buf, val);
    } else if (val < 0x10000) {
      buf = binary.create(3);
      binary.writeUInt8(buf, 253);
      binary.writeUInt16LE(buf, val);
    } else if (val < 0x100000000) {
      buf = binary.create(5);
      binary.writeUInt8(buf, 254);
      binary.writeUInt32LE(buf, val);
    } else {
      buf = binary.create(9);
      binary.writeUInt8(buf, 255);
      binary.writeUInt64LE(buf, val);
    }

    return buf;
  }

};
module.exports = util;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MULTRET,
  LUA_OPBNOT,
  LUA_OPEQ,
  LUA_OPLE,
  LUA_OPLT,
  LUA_OPUNM,
  LUA_REGISTRYINDEX,
  LUA_RIDX_GLOBALS,
  LUA_VERSION_NUM,
  constant_types: {
    LUA_NUMTAGS,
    LUA_TBOOLEAN,
    LUA_TCCL,
    LUA_TFUNCTION,
    LUA_TLCF,
    LUA_TLCL,
    LUA_TLIGHTUSERDATA,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNONE,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR,
    LUA_TTABLE,
    LUA_TTHREAD,
    LUA_TUSERDATA
  },
  thread_status: {
    LUA_OK
  },
  from_userstring,
  to_luastring
} = __webpack_require__(1);

const {
  api_check
} = __webpack_require__(5);

const ldebug = __webpack_require__(12);

const ldo = __webpack_require__(9);

const {
  luaU_dump
} = __webpack_require__(66);

const lfunc = __webpack_require__(14);

const lobject = __webpack_require__(7);

const lstate = __webpack_require__(13);

const {
  luaS_bless,
  luaS_new,
  luaS_newliteral
} = __webpack_require__(11);

const ltm = __webpack_require__(15);

const {
  LUAI_MAXSTACK
} = __webpack_require__(4);

const lvm = __webpack_require__(16);

const ltable = __webpack_require__(10);

const {
  ZIO
} = __webpack_require__(23);

const TValue = lobject.TValue;
const CClosure = lobject.CClosure;

const api_incr_top = function (L) {
  L.top++;
  api_check(L, L.top <= L.ci.top, "stack overflow");
};

const api_checknelems = function (L, n) {
  api_check(L, n < L.top - L.ci.funcOff, "not enough elements in the stack");
};

const fengari_argcheck = function (c) {
  if (!c) throw TypeError("invalid argument");
};

const fengari_argcheckinteger = function (n) {
  fengari_argcheck(typeof n === "number" && (n | 0) === n);
};

const isvalid = function (o) {
  return o !== lobject.luaO_nilobject;
};

const lua_version = function (L) {
  if (L === null) return LUA_VERSION_NUM;else return L.l_G.version;
};

const lua_atpanic = function (L, panicf) {
  let old = L.l_G.panic;
  L.l_G.panic = panicf;
  return old;
};

const lua_atnativeerror = function (L, errorf) {
  let old = L.l_G.atnativeerror;
  L.l_G.atnativeerror = errorf;
  return old;
}; // Return value for idx on stack


const index2addr = function (L, idx) {
  let ci = L.ci;

  if (idx > 0) {
    let o = ci.funcOff + idx;
    api_check(L, idx <= ci.top - (ci.funcOff + 1), "unacceptable index");
    if (o >= L.top) return lobject.luaO_nilobject;else return L.stack[o];
  } else if (idx > LUA_REGISTRYINDEX) {
    api_check(L, idx !== 0 && -idx <= L.top, "invalid index");
    return L.stack[L.top + idx];
  } else if (idx === LUA_REGISTRYINDEX) {
    return L.l_G.l_registry;
  } else {
    /* upvalues */
    idx = LUA_REGISTRYINDEX - idx;
    api_check(L, idx <= lfunc.MAXUPVAL + 1, "upvalue index too large");
    if (ci.func.ttislcf())
      /* light C function? */
      return lobject.luaO_nilobject;
      /* it has no upvalues */
    else {
        return idx <= ci.func.value.nupvalues ? ci.func.value.upvalue[idx - 1] : lobject.luaO_nilobject;
      }
  }
}; // Like index2addr but returns the index on stack; doesn't allow pseudo indices


const index2addr_ = function (L, idx) {
  let ci = L.ci;

  if (idx > 0) {
    let o = ci.funcOff + idx;
    api_check(L, idx <= ci.top - (ci.funcOff + 1), "unacceptable index");
    if (o >= L.top) return null;else return o;
  } else if (idx > LUA_REGISTRYINDEX) {
    api_check(L, idx !== 0 && -idx <= L.top, "invalid index");
    return L.top + idx;
  } else {
    /* registry or upvalue */
    throw Error("attempt to use pseudo-index");
  }
};

const lua_checkstack = function (L, n) {
  let res;
  let ci = L.ci;
  api_check(L, n >= 0, "negative 'n'");
  if (L.stack_last - L.top > n)
    /* stack large enough? */
    res = true;else {
    /* no; need to grow stack */
    let inuse = L.top + lstate.EXTRA_STACK;
    if (inuse > LUAI_MAXSTACK - n)
      /* can grow without overflow? */
      res = false;
      /* no */
    else {
        /* try to grow stack */
        ldo.luaD_growstack(L, n);
        res = true;
      }
  }
  if (res && ci.top < L.top + n) ci.top = L.top + n;
  /* adjust frame top */

  return res;
};

const lua_xmove = function (from, to, n) {
  if (from === to) return;
  api_checknelems(from, n);
  api_check(from, from.l_G === to.l_G, "moving among independent states");
  api_check(from, to.ci.top - to.top >= n, "stack overflow");
  from.top -= n;

  for (let i = 0; i < n; i++) {
    to.stack[to.top] = new lobject.TValue();
    lobject.setobj2s(to, to.top, from.stack[from.top + i]);
    delete from.stack[from.top + i];
    to.top++;
  }
};
/*
** basic stack manipulation
*/

/*
** convert an acceptable stack index into an absolute index
*/


const lua_absindex = function (L, idx) {
  return idx > 0 || idx <= LUA_REGISTRYINDEX ? idx : L.top - L.ci.funcOff + idx;
};

const lua_gettop = function (L) {
  return L.top - (L.ci.funcOff + 1);
};

const lua_pushvalue = function (L, idx) {
  lobject.pushobj2s(L, index2addr(L, idx));
  api_check(L, L.top <= L.ci.top, "stack overflow");
};

const lua_settop = function (L, idx) {
  let func = L.ci.funcOff;
  let newtop;

  if (idx >= 0) {
    api_check(L, idx <= L.stack_last - (func + 1), "new top too large");
    newtop = func + 1 + idx;
  } else {
    api_check(L, -(idx + 1) <= L.top - (func + 1), "invalid new top");
    newtop = L.top + idx + 1;
    /* 'subtract' index (index is negative) */
  }

  ldo.adjust_top(L, newtop);
};

const lua_pop = function (L, n) {
  lua_settop(L, -n - 1);
};

const reverse = function (L, from, to) {
  for (; from < to; from++, to--) {
    let fromtv = L.stack[from];
    let temp = new TValue(fromtv.type, fromtv.value);
    lobject.setobjs2s(L, from, to);
    lobject.setobj2s(L, to, temp);
  }
};
/*
** Let x = AB, where A is a prefix of length 'n'. Then,
** rotate x n === BA. But BA === (A^r . B^r)^r.
*/


const lua_rotate = function (L, idx, n) {
  let t = L.top - 1;
  let pIdx = index2addr_(L, idx);
  let p = L.stack[pIdx];
  api_check(L, isvalid(p) && idx > LUA_REGISTRYINDEX, "index not in the stack");
  api_check(L, (n >= 0 ? n : -n) <= t - pIdx + 1, "invalid 'n'");
  let m = n >= 0 ? t - n : pIdx - n - 1;
  /* end of prefix */

  reverse(L, pIdx, m);
  reverse(L, m + 1, L.top - 1);
  reverse(L, pIdx, L.top - 1);
};

const lua_copy = function (L, fromidx, toidx) {
  let from = index2addr(L, fromidx);
  index2addr(L, toidx).setfrom(from);
};

const lua_remove = function (L, idx) {
  lua_rotate(L, idx, -1);
  lua_pop(L, 1);
};

const lua_insert = function (L, idx) {
  lua_rotate(L, idx, 1);
};

const lua_replace = function (L, idx) {
  lua_copy(L, -1, idx);
  lua_pop(L, 1);
};
/*
** push functions (JS -> stack)
*/


const lua_pushnil = function (L) {
  L.stack[L.top] = new TValue(LUA_TNIL, null);
  api_incr_top(L);
};

const lua_pushnumber = function (L, n) {
  fengari_argcheck(typeof n === "number");
  L.stack[L.top] = new TValue(LUA_TNUMFLT, n);
  api_incr_top(L);
};

const lua_pushinteger = function (L, n) {
  fengari_argcheckinteger(n);
  L.stack[L.top] = new TValue(LUA_TNUMINT, n);
  api_incr_top(L);
};

const lua_pushlstring = function (L, s, len) {
  fengari_argcheckinteger(len);
  let ts;

  if (len === 0) {
    s = to_luastring("", true);
    ts = luaS_bless(L, s);
  } else {
    s = from_userstring(s);
    api_check(L, s.length >= len, "invalid length to lua_pushlstring");
    ts = luaS_new(L, s.subarray(0, len));
  }

  lobject.pushsvalue2s(L, ts);
  api_check(L, L.top <= L.ci.top, "stack overflow");
  return ts.value;
};

const lua_pushstring = function (L, s) {
  if (s === undefined || s === null) {
    L.stack[L.top] = new TValue(LUA_TNIL, null);
    L.top++;
  } else {
    let ts = luaS_new(L, from_userstring(s));
    lobject.pushsvalue2s(L, ts);
    s = ts.getstr();
    /* internal copy */
  }

  api_check(L, L.top <= L.ci.top, "stack overflow");
  return s;
};

const lua_pushvfstring = function (L, fmt, argp) {
  fmt = from_userstring(fmt);
  return lobject.luaO_pushvfstring(L, fmt, argp);
};

const lua_pushfstring = function (L, fmt, ...argp) {
  fmt = from_userstring(fmt);
  return lobject.luaO_pushvfstring(L, fmt, argp);
};
/* Similar to lua_pushstring, but takes a JS string */


const lua_pushliteral = function (L, s) {
  if (s === undefined || s === null) {
    L.stack[L.top] = new TValue(LUA_TNIL, null);
    L.top++;
  } else {
    fengari_argcheck(typeof s === "string");
    let ts = luaS_newliteral(L, s);
    lobject.pushsvalue2s(L, ts);
    s = ts.getstr();
    /* internal copy */
  }

  api_check(L, L.top <= L.ci.top, "stack overflow");
  return s;
};

const lua_pushcclosure = function (L, fn, n) {
  fengari_argcheck(typeof fn === "function");
  fengari_argcheckinteger(n);
  if (n === 0) L.stack[L.top] = new TValue(LUA_TLCF, fn);else {
    api_checknelems(L, n);
    api_check(L, n <= lfunc.MAXUPVAL, "upvalue index too large");
    let cl = new CClosure(L, fn, n);

    for (let i = 0; i < n; i++) cl.upvalue[i].setfrom(L.stack[L.top - n + i]);

    for (let i = 1; i < n; i++) delete L.stack[--L.top];

    if (n > 0) --L.top;
    L.stack[L.top].setclCvalue(cl);
  }
  api_incr_top(L);
};

const lua_pushjsclosure = lua_pushcclosure;

const lua_pushcfunction = function (L, fn) {
  lua_pushcclosure(L, fn, 0);
};

const lua_pushjsfunction = lua_pushcfunction;

const lua_pushboolean = function (L, b) {
  L.stack[L.top] = new TValue(LUA_TBOOLEAN, !!b);
  api_incr_top(L);
};

const lua_pushlightuserdata = function (L, p) {
  L.stack[L.top] = new TValue(LUA_TLIGHTUSERDATA, p);
  api_incr_top(L);
};

const lua_pushthread = function (L) {
  L.stack[L.top] = new TValue(LUA_TTHREAD, L);
  api_incr_top(L);
  return L.l_G.mainthread === L;
};

const lua_pushglobaltable = function (L) {
  lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);
};
/*
** set functions (stack -> Lua)
*/

/*
** t[k] = value at the top of the stack (where 'k' is a string)
*/


const auxsetstr = function (L, t, k) {
  let str = luaS_new(L, from_userstring(k));
  api_checknelems(L, 1);
  lobject.pushsvalue2s(L, str);
  /* push 'str' (to make it a TValue) */

  api_check(L, L.top <= L.ci.top, "stack overflow");
  lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);
  /* pop value and key */

  delete L.stack[--L.top];
  delete L.stack[--L.top];
};

const lua_setglobal = function (L, name) {
  auxsetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);
};

const lua_setmetatable = function (L, objindex) {
  api_checknelems(L, 1);
  let mt;
  let obj = index2addr(L, objindex);
  if (L.stack[L.top - 1].ttisnil()) mt = null;else {
    api_check(L, L.stack[L.top - 1].ttistable(), "table expected");
    mt = L.stack[L.top - 1].value;
  }

  switch (obj.ttnov()) {
    case LUA_TUSERDATA:
    case LUA_TTABLE:
      {
        obj.value.metatable = mt;
        break;
      }

    default:
      {
        L.l_G.mt[obj.ttnov()] = mt;
        break;
      }
  }

  delete L.stack[--L.top];
  return true;
};

const lua_settable = function (L, idx) {
  api_checknelems(L, 2);
  let t = index2addr(L, idx);
  lvm.settable(L, t, L.stack[L.top - 2], L.stack[L.top - 1]);
  delete L.stack[--L.top];
  delete L.stack[--L.top];
};

const lua_setfield = function (L, idx, k) {
  auxsetstr(L, index2addr(L, idx), k);
};

const lua_seti = function (L, idx, n) {
  fengari_argcheckinteger(n);
  api_checknelems(L, 1);
  let t = index2addr(L, idx);
  L.stack[L.top] = new TValue(LUA_TNUMINT, n);
  api_incr_top(L);
  lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);
  /* pop value and key */

  delete L.stack[--L.top];
  delete L.stack[--L.top];
};

const lua_rawset = function (L, idx) {
  api_checknelems(L, 2);
  let o = index2addr(L, idx);
  api_check(L, o.ttistable(), "table expected");
  let k = L.stack[L.top - 2];
  let v = L.stack[L.top - 1];
  ltable.luaH_setfrom(L, o.value, k, v);
  ltable.invalidateTMcache(o.value);
  delete L.stack[--L.top];
  delete L.stack[--L.top];
};

const lua_rawseti = function (L, idx, n) {
  fengari_argcheckinteger(n);
  api_checknelems(L, 1);
  let o = index2addr(L, idx);
  api_check(L, o.ttistable(), "table expected");
  ltable.luaH_setint(o.value, n, L.stack[L.top - 1]);
  delete L.stack[--L.top];
};

const lua_rawsetp = function (L, idx, p) {
  api_checknelems(L, 1);
  let o = index2addr(L, idx);
  api_check(L, o.ttistable(), "table expected");
  let k = new TValue(LUA_TLIGHTUSERDATA, p);
  let v = L.stack[L.top - 1];
  ltable.luaH_setfrom(L, o.value, k, v);
  delete L.stack[--L.top];
};
/*
** get functions (Lua -> stack)
*/


const auxgetstr = function (L, t, k) {
  let str = luaS_new(L, from_userstring(k));
  lobject.pushsvalue2s(L, str);
  api_check(L, L.top <= L.ci.top, "stack overflow");
  lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);
  return L.stack[L.top - 1].ttnov();
};

const lua_rawgeti = function (L, idx, n) {
  let t = index2addr(L, idx);
  fengari_argcheckinteger(n);
  api_check(L, t.ttistable(), "table expected");
  lobject.pushobj2s(L, ltable.luaH_getint(t.value, n));
  api_check(L, L.top <= L.ci.top, "stack overflow");
  return L.stack[L.top - 1].ttnov();
};

const lua_rawgetp = function (L, idx, p) {
  let t = index2addr(L, idx);
  api_check(L, t.ttistable(), "table expected");
  let k = new TValue(LUA_TLIGHTUSERDATA, p);
  lobject.pushobj2s(L, ltable.luaH_get(L, t.value, k));
  api_check(L, L.top <= L.ci.top, "stack overflow");
  return L.stack[L.top - 1].ttnov();
};

const lua_rawget = function (L, idx) {
  let t = index2addr(L, idx);
  api_check(L, t.ttistable(t), "table expected");
  lobject.setobj2s(L, L.top - 1, ltable.luaH_get(L, t.value, L.stack[L.top - 1]));
  return L.stack[L.top - 1].ttnov();
}; // narray and nrec are mostly useless for this implementation


const lua_createtable = function (L, narray, nrec) {
  let t = new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L));
  L.stack[L.top] = t;
  api_incr_top(L);
};

const luaS_newudata = function (L, size) {
  return new lobject.Udata(L, size);
};

const lua_newuserdata = function (L, size) {
  let u = luaS_newudata(L, size);
  L.stack[L.top] = new lobject.TValue(LUA_TUSERDATA, u);
  api_incr_top(L);
  return u.data;
};

const aux_upvalue = function (L, fi, n) {
  fengari_argcheckinteger(n);

  switch (fi.ttype()) {
    case LUA_TCCL:
      {
        /* C closure */
        let f = fi.value;
        if (!(1 <= n && n <= f.nupvalues)) return null;
        return {
          name: to_luastring("", true),
          val: f.upvalue[n - 1]
        };
      }

    case LUA_TLCL:
      {
        /* Lua closure */
        let f = fi.value;
        let p = f.p;
        if (!(1 <= n && n <= p.upvalues.length)) return null;
        let name = p.upvalues[n - 1].name;
        return {
          name: name ? name.getstr() : to_luastring("(*no name)", true),
          val: f.upvals[n - 1]
        };
      }

    default:
      return null;

    /* not a closure */
  }
};

const lua_getupvalue = function (L, funcindex, n) {
  let up = aux_upvalue(L, index2addr(L, funcindex), n);

  if (up) {
    let name = up.name;
    let val = up.val;
    lobject.pushobj2s(L, val);
    api_check(L, L.top <= L.ci.top, "stack overflow");
    return name;
  }

  return null;
};

const lua_setupvalue = function (L, funcindex, n) {
  let fi = index2addr(L, funcindex);
  api_checknelems(L, 1);
  let aux = aux_upvalue(L, fi, n);

  if (aux) {
    let name = aux.name;
    let val = aux.val;
    val.setfrom(L.stack[L.top - 1]);
    delete L.stack[--L.top];
    return name;
  }

  return null;
};

const lua_newtable = function (L) {
  lua_createtable(L, 0, 0);
};

const lua_register = function (L, n, f) {
  lua_pushcfunction(L, f);
  lua_setglobal(L, n);
};

const lua_getmetatable = function (L, objindex) {
  let obj = index2addr(L, objindex);
  let mt;
  let res = false;

  switch (obj.ttnov()) {
    case LUA_TTABLE:
    case LUA_TUSERDATA:
      mt = obj.value.metatable;
      break;

    default:
      mt = L.l_G.mt[obj.ttnov()];
      break;
  }

  if (mt !== null && mt !== undefined) {
    L.stack[L.top] = new TValue(LUA_TTABLE, mt);
    api_incr_top(L);
    res = true;
  }

  return res;
};

const lua_getuservalue = function (L, idx) {
  let o = index2addr(L, idx);
  api_check(L, o.ttisfulluserdata(), "full userdata expected");
  let uv = o.value.uservalue;
  L.stack[L.top] = new TValue(uv.type, uv.value);
  api_incr_top(L);
  return L.stack[L.top - 1].ttnov();
};

const lua_gettable = function (L, idx) {
  let t = index2addr(L, idx);
  lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);
  return L.stack[L.top - 1].ttnov();
};

const lua_getfield = function (L, idx, k) {
  return auxgetstr(L, index2addr(L, idx), k);
};

const lua_geti = function (L, idx, n) {
  let t = index2addr(L, idx);
  fengari_argcheckinteger(n);
  L.stack[L.top] = new TValue(LUA_TNUMINT, n);
  api_incr_top(L);
  lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);
  return L.stack[L.top - 1].ttnov();
};

const lua_getglobal = function (L, name) {
  return auxgetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);
};
/*
** access functions (stack -> JS)
*/


const lua_toboolean = function (L, idx) {
  let o = index2addr(L, idx);
  return !o.l_isfalse();
};

const lua_tolstring = function (L, idx) {
  let o = index2addr(L, idx);

  if (!o.ttisstring()) {
    if (!lvm.cvt2str(o)) {
      /* not convertible? */
      return null;
    }

    lobject.luaO_tostring(L, o);
  }

  return o.svalue();
};

const lua_tostring = lua_tolstring;

const lua_tojsstring = function (L, idx) {
  let o = index2addr(L, idx);

  if (!o.ttisstring()) {
    if (!lvm.cvt2str(o)) {
      /* not convertible? */
      return null;
    }

    lobject.luaO_tostring(L, o);
  }

  return o.jsstring();
};

const lua_todataview = function (L, idx) {
  let u8 = lua_tolstring(L, idx);
  return new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
};

const lua_rawlen = function (L, idx) {
  let o = index2addr(L, idx);

  switch (o.ttype()) {
    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      return o.vslen();

    case LUA_TUSERDATA:
      return o.value.len;

    case LUA_TTABLE:
      return ltable.luaH_getn(o.value);

    default:
      return 0;
  }
};

const lua_tocfunction = function (L, idx) {
  let o = index2addr(L, idx);
  if (o.ttislcf() || o.ttisCclosure()) return o.value;else return null;
  /* not a C function */
};

const lua_tointeger = function (L, idx) {
  let n = lua_tointegerx(L, idx);
  return n === false ? 0 : n;
};

const lua_tointegerx = function (L, idx) {
  return lvm.tointeger(index2addr(L, idx));
};

const lua_tonumber = function (L, idx) {
  let n = lua_tonumberx(L, idx);
  return n === false ? 0 : n;
};

const lua_tonumberx = function (L, idx) {
  return lvm.tonumber(index2addr(L, idx));
};

const lua_touserdata = function (L, idx) {
  let o = index2addr(L, idx);

  switch (o.ttnov()) {
    case LUA_TUSERDATA:
      return o.value.data;

    case LUA_TLIGHTUSERDATA:
      return o.value;

    default:
      return null;
  }
};

const lua_tothread = function (L, idx) {
  let o = index2addr(L, idx);
  return o.ttisthread() ? o.value : null;
};

const lua_topointer = function (L, idx) {
  let o = index2addr(L, idx);

  switch (o.ttype()) {
    case LUA_TTABLE:
    case LUA_TLCL:
    case LUA_TCCL:
    case LUA_TLCF:
    case LUA_TTHREAD:
    case LUA_TUSERDATA:
    /* note: this differs in behaviour to reference lua implementation */

    case LUA_TLIGHTUSERDATA:
      return o.value;

    default:
      return null;
  }
};
/* A proxy is a function that the same lua value to the given lua state. */

/* Having a weakmap of created proxies was only way I could think of to provide an 'isproxy' function */


const seen = new WeakMap();
/* is the passed object a proxy? is it from the given state? (if passed) */

const lua_isproxy = function (p, L) {
  let G = seen.get(p);
  if (!G) return false;
  return L === null || L.l_G === G;
};
/* Use 'create_proxy' helper function so that 'L' is not in scope */


const create_proxy = function (G, type, value) {
  let proxy = function (L) {
    api_check(L, L instanceof lstate.lua_State && G === L.l_G, "must be from same global state");
    L.stack[L.top] = new TValue(type, value);
    api_incr_top(L);
  };

  seen.set(proxy, G);
  return proxy;
};

const lua_toproxy = function (L, idx) {
  let tv = index2addr(L, idx);
  /* pass broken down tv incase it is an upvalue index */

  return create_proxy(L.l_G, tv.type, tv.value);
};

const lua_compare = function (L, index1, index2, op) {
  let o1 = index2addr(L, index1);
  let o2 = index2addr(L, index2);
  let i = 0;

  if (isvalid(o1) && isvalid(o2)) {
    switch (op) {
      case LUA_OPEQ:
        i = lvm.luaV_equalobj(L, o1, o2);
        break;

      case LUA_OPLT:
        i = lvm.luaV_lessthan(L, o1, o2);
        break;

      case LUA_OPLE:
        i = lvm.luaV_lessequal(L, o1, o2);
        break;

      default:
        api_check(L, false, "invalid option");
    }
  }

  return i;
};

const lua_stringtonumber = function (L, s) {
  let tv = new TValue();
  let sz = lobject.luaO_str2num(s, tv);

  if (sz !== 0) {
    L.stack[L.top] = tv;
    api_incr_top(L);
  }

  return sz;
};

const f_call = function (L, ud) {
  ldo.luaD_callnoyield(L, ud.funcOff, ud.nresults);
};

const lua_type = function (L, idx) {
  let o = index2addr(L, idx);
  return isvalid(o) ? o.ttnov() : LUA_TNONE;
};

const lua_typename = function (L, t) {
  api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, "invalid tag");
  return ltm.ttypename(t);
};

const lua_iscfunction = function (L, idx) {
  let o = index2addr(L, idx);
  return o.ttislcf(o) || o.ttisCclosure();
};

const lua_isnil = function (L, n) {
  return lua_type(L, n) === LUA_TNIL;
};

const lua_isboolean = function (L, n) {
  return lua_type(L, n) === LUA_TBOOLEAN;
};

const lua_isnone = function (L, n) {
  return lua_type(L, n) === LUA_TNONE;
};

const lua_isnoneornil = function (L, n) {
  return lua_type(L, n) <= 0;
};

const lua_istable = function (L, idx) {
  return index2addr(L, idx).ttistable();
};

const lua_isinteger = function (L, idx) {
  return index2addr(L, idx).ttisinteger();
};

const lua_isnumber = function (L, idx) {
  return lvm.tonumber(index2addr(L, idx)) !== false;
};

const lua_isstring = function (L, idx) {
  let o = index2addr(L, idx);
  return o.ttisstring() || lvm.cvt2str(o);
};

const lua_isuserdata = function (L, idx) {
  let o = index2addr(L, idx);
  return o.ttisfulluserdata(o) || o.ttislightuserdata();
};

const lua_isthread = function (L, idx) {
  return lua_type(L, idx) === LUA_TTHREAD;
};

const lua_isfunction = function (L, idx) {
  return lua_type(L, idx) === LUA_TFUNCTION;
};

const lua_islightuserdata = function (L, idx) {
  return lua_type(L, idx) === LUA_TLIGHTUSERDATA;
};

const lua_rawequal = function (L, index1, index2) {
  let o1 = index2addr(L, index1);
  let o2 = index2addr(L, index2);
  return isvalid(o1) && isvalid(o2) ? lvm.luaV_equalobj(null, o1, o2) : 0;
};

const lua_arith = function (L, op) {
  if (op !== LUA_OPUNM && op !== LUA_OPBNOT) api_checknelems(L, 2);
  /* all other operations expect two operands */
  else {
      /* for unary operations, add fake 2nd operand */
      api_checknelems(L, 1);
      lobject.pushobj2s(L, L.stack[L.top - 1]);
      api_check(L, L.top <= L.ci.top, "stack overflow");
    }
  /* first operand at top - 2, second at top - 1; result go to top - 2 */

  lobject.luaO_arith(L, op, L.stack[L.top - 2], L.stack[L.top - 1], L.stack[L.top - 2]);
  delete L.stack[--L.top];
  /* remove second operand */
};
/*
** 'load' and 'call' functions (run Lua code)
*/


const default_chunkname = to_luastring("?");

const lua_load = function (L, reader, data, chunkname, mode) {
  if (!chunkname) chunkname = default_chunkname;else chunkname = from_userstring(chunkname);
  if (mode !== null) mode = from_userstring(mode);
  let z = new ZIO(L, reader, data);
  let status = ldo.luaD_protectedparser(L, z, chunkname, mode);

  if (status === LUA_OK) {
    /* no errors? */
    let f = L.stack[L.top - 1].value;
    /* get newly created function */

    if (f.nupvalues >= 1) {
      /* does it have an upvalue? */

      /* get global table from registry */
      let gt = ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS);
      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */

      f.upvals[0].setfrom(gt);
    }
  }

  return status;
};

const lua_dump = function (L, writer, data, strip) {
  api_checknelems(L, 1);
  let o = L.stack[L.top - 1];
  if (o.ttisLclosure()) return luaU_dump(L, o.value.p, writer, data, strip);
  return 1;
};

const lua_status = function (L) {
  return L.status;
};

const lua_setuservalue = function (L, idx) {
  api_checknelems(L, 1);
  let o = index2addr(L, idx);
  api_check(L, o.ttisfulluserdata(), "full userdata expected");
  o.value.uservalue.setfrom(L.stack[L.top - 1]);
  delete L.stack[--L.top];
};

const checkresults = function (L, na, nr) {
  api_check(L, nr === LUA_MULTRET || L.ci.top - L.top >= nr - na, "results from function overflow current stack size");
};

const lua_callk = function (L, nargs, nresults, ctx, k) {
  api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), "cannot use continuations inside hooks");
  api_checknelems(L, nargs + 1);
  api_check(L, L.status === LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  let func = L.top - (nargs + 1);

  if (k !== null && L.nny === 0) {
    /* need to prepare continuation? */
    L.ci.c_k = k;
    L.ci.c_ctx = ctx;
    ldo.luaD_call(L, func, nresults);
  } else {
    /* no continuation or no yieldable */
    ldo.luaD_callnoyield(L, func, nresults);
  }

  if (nresults === LUA_MULTRET && L.ci.top < L.top) L.ci.top = L.top;
};

const lua_call = function (L, n, r) {
  lua_callk(L, n, r, 0, null);
};

const lua_pcallk = function (L, nargs, nresults, errfunc, ctx, k) {
  api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), "cannot use continuations inside hooks");
  api_checknelems(L, nargs + 1);
  api_check(L, L.status === LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  let status;
  let func;
  if (errfunc === 0) func = 0;else {
    func = index2addr_(L, errfunc);
  }
  let funcOff = L.top - (nargs + 1);
  /* function to be called */

  if (k === null || L.nny > 0) {
    /* no continuation or no yieldable? */
    let c = {
      funcOff: funcOff,
      nresults: nresults
      /* do a 'conventional' protected call */

    };
    status = ldo.luaD_pcall(L, f_call, c, funcOff, func);
  } else {
    /* prepare continuation (call is already protected by 'resume') */
    let ci = L.ci;
    ci.c_k = k;
    /* prepare continuation (call is already protected by 'resume') */

    ci.c_ctx = ctx;
    /* prepare continuation (call is already protected by 'resume') */

    /* save information for error recovery */

    ci.extra = funcOff;
    ci.c_old_errfunc = L.errfunc;
    L.errfunc = func;
    ci.callstatus &= ~lstate.CIST_OAH | L.allowhook;
    ci.callstatus |= lstate.CIST_YPCALL;
    /* function can do error recovery */

    ldo.luaD_call(L, funcOff, nresults);
    /* do the call */

    ci.callstatus &= ~lstate.CIST_YPCALL;
    L.errfunc = ci.c_old_errfunc;
    status = LUA_OK;
  }

  if (nresults === LUA_MULTRET && L.ci.top < L.top) L.ci.top = L.top;
  return status;
};

const lua_pcall = function (L, n, r, f) {
  return lua_pcallk(L, n, r, f, 0, null);
};
/*
** miscellaneous functions
*/


const lua_error = function (L) {
  api_checknelems(L, 1);
  ldebug.luaG_errormsg(L);
};

const lua_next = function (L, idx) {
  let t = index2addr(L, idx);
  api_check(L, t.ttistable(), "table expected");
  L.stack[L.top] = new TValue();
  let more = ltable.luaH_next(L, t.value, L.top - 1);

  if (more) {
    api_incr_top(L);
    return 1;
  } else {
    delete L.stack[L.top];
    delete L.stack[--L.top];
    return 0;
  }
};

const lua_concat = function (L, n) {
  api_checknelems(L, n);
  if (n >= 2) lvm.luaV_concat(L, n);else if (n === 0) {
    lobject.pushsvalue2s(L, luaS_bless(L, to_luastring("", true)));
    api_check(L, L.top <= L.ci.top, "stack overflow");
  }
};

const lua_len = function (L, idx) {
  let t = index2addr(L, idx);
  let tv = new TValue();
  lvm.luaV_objlen(L, tv, t);
  L.stack[L.top] = tv;
  api_incr_top(L);
};

const getupvalref = function (L, fidx, n) {
  let fi = index2addr(L, fidx);
  api_check(L, fi.ttisLclosure(), "Lua function expected");
  let f = fi.value;
  fengari_argcheckinteger(n);
  api_check(L, 1 <= n && n <= f.p.upvalues.length, "invalid upvalue index");
  return {
    f: f,
    i: n - 1
  };
};

const lua_upvalueid = function (L, fidx, n) {
  let fi = index2addr(L, fidx);

  switch (fi.ttype()) {
    case LUA_TLCL:
      {
        /* lua closure */
        let ref = getupvalref(L, fidx, n);
        return ref.f.upvals[ref.i];
      }

    case LUA_TCCL:
      {
        /* C closure */
        let f = fi.value;
        api_check(L, (n | 0) === n && n > 0 && n <= f.nupvalues, "invalid upvalue index");
        return f.upvalue[n - 1];
      }

    default:
      {
        api_check(L, false, "closure expected");
        return null;
      }
  }
};

const lua_upvaluejoin = function (L, fidx1, n1, fidx2, n2) {
  let ref1 = getupvalref(L, fidx1, n1);
  let ref2 = getupvalref(L, fidx2, n2);
  let up2 = ref2.f.upvals[ref2.i];
  ref1.f.upvals[ref1.i] = up2;
}; // This functions are only there for compatibility purposes


const lua_gc = function () {};

const lua_getallocf = function () {
  console.warn("lua_getallocf is not available");
  return 0;
};

const lua_setallocf = function () {
  console.warn("lua_setallocf is not available");
  return 0;
};

const lua_getextraspace = function () {
  console.warn("lua_getextraspace is not available");
  return 0;
};

module.exports.api_incr_top = api_incr_top;
module.exports.api_checknelems = api_checknelems;
module.exports.lua_absindex = lua_absindex;
module.exports.lua_arith = lua_arith;
module.exports.lua_atpanic = lua_atpanic;
module.exports.lua_atnativeerror = lua_atnativeerror;
module.exports.lua_call = lua_call;
module.exports.lua_callk = lua_callk;
module.exports.lua_checkstack = lua_checkstack;
module.exports.lua_compare = lua_compare;
module.exports.lua_concat = lua_concat;
module.exports.lua_copy = lua_copy;
module.exports.lua_createtable = lua_createtable;
module.exports.lua_dump = lua_dump;
module.exports.lua_error = lua_error;
module.exports.lua_gc = lua_gc;
module.exports.lua_getallocf = lua_getallocf;
module.exports.lua_getextraspace = lua_getextraspace;
module.exports.lua_getfield = lua_getfield;
module.exports.lua_getglobal = lua_getglobal;
module.exports.lua_geti = lua_geti;
module.exports.lua_getmetatable = lua_getmetatable;
module.exports.lua_gettable = lua_gettable;
module.exports.lua_gettop = lua_gettop;
module.exports.lua_getupvalue = lua_getupvalue;
module.exports.lua_getuservalue = lua_getuservalue;
module.exports.lua_insert = lua_insert;
module.exports.lua_isboolean = lua_isboolean;
module.exports.lua_iscfunction = lua_iscfunction;
module.exports.lua_isfunction = lua_isfunction;
module.exports.lua_isinteger = lua_isinteger;
module.exports.lua_islightuserdata = lua_islightuserdata;
module.exports.lua_isnil = lua_isnil;
module.exports.lua_isnone = lua_isnone;
module.exports.lua_isnoneornil = lua_isnoneornil;
module.exports.lua_isnumber = lua_isnumber;
module.exports.lua_isproxy = lua_isproxy;
module.exports.lua_isstring = lua_isstring;
module.exports.lua_istable = lua_istable;
module.exports.lua_isthread = lua_isthread;
module.exports.lua_isuserdata = lua_isuserdata;
module.exports.lua_len = lua_len;
module.exports.lua_load = lua_load;
module.exports.lua_newtable = lua_newtable;
module.exports.lua_newuserdata = lua_newuserdata;
module.exports.lua_next = lua_next;
module.exports.lua_pcall = lua_pcall;
module.exports.lua_pcallk = lua_pcallk;
module.exports.lua_pop = lua_pop;
module.exports.lua_pushboolean = lua_pushboolean;
module.exports.lua_pushcclosure = lua_pushcclosure;
module.exports.lua_pushcfunction = lua_pushcfunction;
module.exports.lua_pushfstring = lua_pushfstring;
module.exports.lua_pushglobaltable = lua_pushglobaltable;
module.exports.lua_pushinteger = lua_pushinteger;
module.exports.lua_pushjsclosure = lua_pushjsclosure;
module.exports.lua_pushjsfunction = lua_pushjsfunction;
module.exports.lua_pushlightuserdata = lua_pushlightuserdata;
module.exports.lua_pushliteral = lua_pushliteral;
module.exports.lua_pushlstring = lua_pushlstring;
module.exports.lua_pushnil = lua_pushnil;
module.exports.lua_pushnumber = lua_pushnumber;
module.exports.lua_pushstring = lua_pushstring;
module.exports.lua_pushthread = lua_pushthread;
module.exports.lua_pushvalue = lua_pushvalue;
module.exports.lua_pushvfstring = lua_pushvfstring;
module.exports.lua_rawequal = lua_rawequal;
module.exports.lua_rawget = lua_rawget;
module.exports.lua_rawgeti = lua_rawgeti;
module.exports.lua_rawgetp = lua_rawgetp;
module.exports.lua_rawlen = lua_rawlen;
module.exports.lua_rawset = lua_rawset;
module.exports.lua_rawseti = lua_rawseti;
module.exports.lua_rawsetp = lua_rawsetp;
module.exports.lua_register = lua_register;
module.exports.lua_remove = lua_remove;
module.exports.lua_replace = lua_replace;
module.exports.lua_rotate = lua_rotate;
module.exports.lua_setallocf = lua_setallocf;
module.exports.lua_setfield = lua_setfield;
module.exports.lua_setglobal = lua_setglobal;
module.exports.lua_seti = lua_seti;
module.exports.lua_setmetatable = lua_setmetatable;
module.exports.lua_settable = lua_settable;
module.exports.lua_settop = lua_settop;
module.exports.lua_setupvalue = lua_setupvalue;
module.exports.lua_setuservalue = lua_setuservalue;
module.exports.lua_status = lua_status;
module.exports.lua_stringtonumber = lua_stringtonumber;
module.exports.lua_toboolean = lua_toboolean;
module.exports.lua_tocfunction = lua_tocfunction;
module.exports.lua_todataview = lua_todataview;
module.exports.lua_tointeger = lua_tointeger;
module.exports.lua_tointegerx = lua_tointegerx;
module.exports.lua_tojsstring = lua_tojsstring;
module.exports.lua_tolstring = lua_tolstring;
module.exports.lua_tonumber = lua_tonumber;
module.exports.lua_tonumberx = lua_tonumberx;
module.exports.lua_topointer = lua_topointer;
module.exports.lua_toproxy = lua_toproxy;
module.exports.lua_tostring = lua_tostring;
module.exports.lua_tothread = lua_tothread;
module.exports.lua_touserdata = lua_touserdata;
module.exports.lua_type = lua_type;
module.exports.lua_typename = lua_typename;
module.exports.lua_upvalueid = lua_upvalueid;
module.exports.lua_upvaluejoin = lua_upvaluejoin;
module.exports.lua_version = lua_version;
module.exports.lua_xmove = lua_xmove;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  lua_assert
} = __webpack_require__(5);

class MBuffer {
  constructor() {
    this.buffer = null;
    this.n = 0;
  }

}

const luaZ_buffer = function (buff) {
  return buff.buffer.subarray(0, buff.n);
};

const luaZ_buffremove = function (buff, i) {
  buff.n -= i;
};

const luaZ_resetbuffer = function (buff) {
  buff.n = 0;
};

const luaZ_resizebuffer = function (L, buff, size) {
  let newbuff = new Uint8Array(size);
  if (buff.buffer) newbuff.set(buff.buffer);
  buff.buffer = newbuff;
};

class ZIO {
  constructor(L, reader, data) {
    this.L = L;
    /* Lua state (for reader) */

    lua_assert(typeof reader == "function", "ZIO requires a reader");
    this.reader = reader;
    /* reader function */

    this.data = data;
    /* additional data */

    this.n = 0;
    /* bytes still unread */

    this.buffer = null;
    this.off = 0;
    /* current position in buffer */
  }

  zgetc() {
    return this.n-- > 0 ? this.buffer[this.off++] : luaZ_fill(this);
  }

}

const EOZ = -1;

const luaZ_fill = function (z) {
  let buff = z.reader(z.L, z.data);
  if (buff === null) return EOZ;
  lua_assert(buff instanceof Uint8Array, "Should only load binary of array of bytes");
  let size = buff.length;
  if (size === 0) return EOZ;
  z.buffer = buff;
  z.off = 0;
  z.n = size - 1;
  return z.buffer[z.off++];
};
/* b should be an array-like that will be set to bytes
 * b_offset is the offset at which to start filling */


const luaZ_read = function (z, b, b_offset, n) {
  while (n) {
    if (z.n === 0) {
      /* no bytes in buffer? */
      if (luaZ_fill(z) === EOZ) return n;
      /* no more input; return number of missing bytes */
      else {
          z.n++;
          /* luaZ_fill consumed first byte; put it back */

          z.off--;
        }
    }

    let m = n <= z.n ? n : z.n;
    /* min. between n and z->n */

    for (let i = 0; i < m; i++) {
      b[b_offset++] = z.buffer[z.off++];
    }

    z.n -= m;
    if (z.n === 0) // remove reference to input so it can get freed
      z.buffer = null;
    n -= m;
  }

  return 0;
};

module.exports.EOZ = EOZ;
module.exports.luaZ_buffer = luaZ_buffer;
module.exports.luaZ_buffremove = luaZ_buffremove;
module.exports.luaZ_fill = luaZ_fill;
module.exports.luaZ_read = luaZ_read;
module.exports.luaZ_resetbuffer = luaZ_resetbuffer;
module.exports.luaZ_resizebuffer = luaZ_resizebuffer;
module.exports.MBuffer = MBuffer;
module.exports.ZIO = ZIO;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);
/**
 * A collection of commonly used helper functions.
 */


const util = {
  // Export BOPs binary helpers
  binary,

  /**
   * Converts the given map to an object. By default runs recursively.
   *
   * @param {Map} map Map object
   * @param {Boolean} deep Recusive. Defaults true.
   * @return {Object}
   */
  mapToObject(map, deep = true) {
    if (!(map instanceof Map)) return map;
    const obj = {};

    for (let [key, val] of map) {
      if (deep && Array.isArray(val)) {
        obj[key] = val.map(v => this.mapToObject(v, deep));
      } else if (deep && val instanceof Map) {
        obj[key] = this.mapToObject(val, deep);
      } else {
        obj[key] = val;
      }
    }

    return obj;
  }

};
module.exports = util;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);

const util = __webpack_require__(21);

const {
  ripemd160Loader
} = __webpack_require__(26);

const hashAlgorithms = ['RIPEMD160', 'SHA-1', 'SHA-256', 'SHA-384', 'SHA-512'];
/**
 * TODO
 */

const hash = {
  /**
   * TODO
   */
  async hash(algo, data, opts = {}) {
    if (!hashAlgorithms.includes(algo)) throw new Error('Unsupported hash algorithm.');
    if (algo === 'RIPEMD160') return this.ripemd160(data, opts);
    if (!binary.is(data)) data = binary.from(data);
    const hash = await crypto.subtle.digest({
      name: algo
    }, data),
          buf = binary.from(hash);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async ripemd160(data, opts = {}) {
    const ripemd160 = await ripemd160Loader();
    if (!binary.is(data)) data = binary.from(data);
    const hash = ripemd160.hash(data),
          buf = binary.from(hash);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  sha1(data, opts = {}) {
    return this.hash('SHA-1', data, opts);
  },

  /**
   * TODO
   */
  sha256(data, opts = {}) {
    return this.hash('SHA-256', data, opts);
  },

  /**
   * TODO
   */
  sha512(data, opts = {}) {
    return this.hash('SHA-512', data, opts);
  },

  /**
   * TODO
   */
  async sha256ripemd160(data, opts = {}) {
    data = await this.sha256(data);
    return this.ripemd160(data, opts);
  },

  /**
   * TODO
   */
  async sha256sha256(data, opts = {}) {
    data = await this.sha256(data);
    return this.sha256(data, opts);
  }

};
module.exports = hash;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

const {
  instantiateRipemd160,
  instantiateSecp256k1
} = __webpack_require__(90);
/**
 * TODO
 */


module.exports = {
  ripemd160Loader: () => instantiateRipemd160(),
  secp256k1Loader: () => instantiateSecp256k1()
};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

/**
 * An adapter is responsible for loading tapes and ops from a datasource -
 * potentially a web API, a database or even a Bitcoin node. Operate ships with
 * two default adapters, although these can be swapped out with any other
 * adpater by changing the configuration.
 *
 * An adapter must implement one or more of the following static methods:
 *
 * * `fetchTx()`
 * * `fetchTxBy()`
 * * `fetchOps()`
 *
 * @interface
 * @hideconstructor
 */
class Adapter {
  /**
   * Fetches a transaction by the given txid, and returns a Promise.
   *
   * @static
   * @param {String} txid Transaction id
   * @param {Object} opts Options
   * @return {Promise}
   */
  static fetchTx(txid, opts = {}) {
    throw `${this.constructor.name}#fetchTx() not implemented`;
  }
  /**
   * Fetches a list of transactions by the given query object, and returns a Promise.
   *
   * @static
   * @param {Object} query Query object
   * @param {Object} opts Options
   * @return {Promise}
   */


  static fetchTxBy(query, opts = {}) {
    throw `${this.constructor.name}#fetchTxBy() not implemented`;
  }
  /**
   * Fetches a list of Ops by the given list of Op references, and returns a Promise.
   *
   * @static
   * @param {Array} refs Op references
   * @param {Object} opts Options
   * @return {Promise}
   */


  static fetchOps(refs, opts = {}) {
    throw `${this.constructor.name}#fetchOps() not implemented`;
  }

}

module.exports = Adapter;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
    https://tools.ietf.org/html/rfc3629

    UTF8-char = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4

    UTF8-1    = %x00-7F

    UTF8-2    = %xC2-DF UTF8-tail

    UTF8-3    = %xE0 %xA0-BF UTF8-tail
                %xE1-EC 2( UTF8-tail )
                %xED %x80-9F UTF8-tail
                %xEE-EF 2( UTF8-tail )

    UTF8-4    = %xF0 %x90-BF 2( UTF8-tail )
                %xF1-F3 3( UTF8-tail )
                %xF4 %x80-8F 2( UTF8-tail )

    UTF8-tail = %x80-BF
*/

/**
 * Check if a Node.js Buffer or Uint8Array is utf-8
 *
 * @param {Buffer|Uint8Array} buf
 * @returns {boolean}
 */

function isUtf8(buf) {
  if (!buf) {
    return false;
  }

  var i = 0,
      len = buf.length;

  while (i < len) {
    // UTF8-1 = %x00-7F
    if (buf[i] <= 0x7F) {
      i++;
      continue;
    } // UTF8-2 = %xC2-DF UTF8-tail


    if (buf[i] >= 0xC2 && buf[i] <= 0xDF) {
      // if(buf[i + 1] >= 0x80 && buf[i + 1] <= 0xBF) {
      if (buf[i + 1] >> 6 === 2) {
        i += 2;
        continue;
      } else {
        return false;
      }
    } // UTF8-3 = %xE0 %xA0-BF UTF8-tail
    // UTF8-3 = %xED %x80-9F UTF8-tail


    if ((buf[i] === 0xE0 && buf[i + 1] >= 0xA0 && buf[i + 1] <= 0xBF || buf[i] === 0xED && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x9F) && buf[i + 2] >> 6 === 2) {
      i += 3;
      continue;
    } // UTF8-3 = %xE1-EC 2( UTF8-tail )
    // UTF8-3 = %xEE-EF 2( UTF8-tail )


    if ((buf[i] >= 0xE1 && buf[i] <= 0xEC || buf[i] >= 0xEE && buf[i] <= 0xEF) && buf[i + 1] >> 6 === 2 && buf[i + 2] >> 6 === 2) {
      i += 3;
      continue;
    } // UTF8-4 = %xF0 %x90-BF 2( UTF8-tail )
    //          %xF1-F3 3( UTF8-tail )
    //          %xF4 %x80-8F 2( UTF8-tail )


    if ((buf[i] === 0xF0 && buf[i + 1] >= 0x90 && buf[i + 1] <= 0xBF || buf[i] >= 0xF1 && buf[i] <= 0xF3 && buf[i + 1] >> 6 === 2 || buf[i] === 0xF4 && buf[i + 1] >= 0x80 && buf[i + 1] <= 0x8F) && buf[i + 2] >> 6 === 2 && buf[i + 3] >> 6 === 2) {
      i += 4;
      continue;
    }

    return false;
  }

  return true;
}

module.exports = isUtf8;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license MIT

Copyright Â© 2017-2018 Benoit Giannangeli
Copyright Â© 2017-2018 Daurnimator
Copyright Â© 1994â2017 Lua.org, PUC-Rio.
*/


const core = __webpack_require__(6);

module.exports.FENGARI_AUTHORS = core.FENGARI_AUTHORS;
module.exports.FENGARI_COPYRIGHT = core.FENGARI_COPYRIGHT;
module.exports.FENGARI_RELEASE = core.FENGARI_RELEASE;
module.exports.FENGARI_VERSION = core.FENGARI_VERSION;
module.exports.FENGARI_VERSION_MAJOR = core.FENGARI_VERSION_MAJOR;
module.exports.FENGARI_VERSION_MINOR = core.FENGARI_VERSION_MINOR;
module.exports.FENGARI_VERSION_NUM = core.FENGARI_VERSION_NUM;
module.exports.FENGARI_VERSION_RELEASE = core.FENGARI_VERSION_RELEASE;
module.exports.luastring_eq = core.luastring_eq;
module.exports.luastring_indexOf = core.luastring_indexOf;
module.exports.luastring_of = core.luastring_of;
module.exports.to_jsstring = core.to_jsstring;
module.exports.to_luastring = core.to_luastring;
module.exports.to_uristring = core.to_uristring;

const luaconf = __webpack_require__(4);

const lua = __webpack_require__(2);

const lauxlib = __webpack_require__(8);

const lualib = __webpack_require__(18);

module.exports.luaconf = luaconf;
module.exports.lua = lua;
module.exports.lauxlib = lauxlib;
module.exports.lualib = lualib;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TLNGSTR
  },
  thread_status: {
    LUA_ERRSYNTAX
  },
  to_luastring
} = __webpack_require__(1);

const {
  LUA_MINBUFFER,
  MAX_INT,
  lua_assert
} = __webpack_require__(5);

const ldebug = __webpack_require__(12);

const ldo = __webpack_require__(9);

const {
  lisdigit,
  lislalnum,
  lislalpha,
  lisspace,
  lisxdigit
} = __webpack_require__(33);

const lobject = __webpack_require__(7);

const {
  luaS_bless,
  luaS_hash,
  luaS_hashlongstr,
  luaS_new
} = __webpack_require__(11);

const ltable = __webpack_require__(10);

const {
  EOZ,
  luaZ_buffer,
  luaZ_buffremove,
  luaZ_resetbuffer,
  luaZ_resizebuffer
} = __webpack_require__(23);

const FIRST_RESERVED = 257;
const LUA_ENV = to_luastring("_ENV", true);
/* terminal symbols denoted by reserved words */

const TK_AND = FIRST_RESERVED;
const TK_BREAK = FIRST_RESERVED + 1;
const TK_DO = FIRST_RESERVED + 2;
const TK_ELSE = FIRST_RESERVED + 3;
const TK_ELSEIF = FIRST_RESERVED + 4;
const TK_END = FIRST_RESERVED + 5;
const TK_FALSE = FIRST_RESERVED + 6;
const TK_FOR = FIRST_RESERVED + 7;
const TK_FUNCTION = FIRST_RESERVED + 8;
const TK_GOTO = FIRST_RESERVED + 9;
const TK_IF = FIRST_RESERVED + 10;
const TK_IN = FIRST_RESERVED + 11;
const TK_LOCAL = FIRST_RESERVED + 12;
const TK_NIL = FIRST_RESERVED + 13;
const TK_NOT = FIRST_RESERVED + 14;
const TK_OR = FIRST_RESERVED + 15;
const TK_REPEAT = FIRST_RESERVED + 16;
const TK_RETURN = FIRST_RESERVED + 17;
const TK_THEN = FIRST_RESERVED + 18;
const TK_TRUE = FIRST_RESERVED + 19;
const TK_UNTIL = FIRST_RESERVED + 20;
const TK_WHILE = FIRST_RESERVED + 21;
/* other terminal symbols */

const TK_IDIV = FIRST_RESERVED + 22;
const TK_CONCAT = FIRST_RESERVED + 23;
const TK_DOTS = FIRST_RESERVED + 24;
const TK_EQ = FIRST_RESERVED + 25;
const TK_GE = FIRST_RESERVED + 26;
const TK_LE = FIRST_RESERVED + 27;
const TK_NE = FIRST_RESERVED + 28;
const TK_SHL = FIRST_RESERVED + 29;
const TK_SHR = FIRST_RESERVED + 30;
const TK_DBCOLON = FIRST_RESERVED + 31;
const TK_EOS = FIRST_RESERVED + 32;
const TK_FLT = FIRST_RESERVED + 33;
const TK_INT = FIRST_RESERVED + 34;
const TK_NAME = FIRST_RESERVED + 35;
const TK_STRING = FIRST_RESERVED + 36;
const RESERVED = {
  "TK_AND": TK_AND,
  "TK_BREAK": TK_BREAK,
  "TK_DO": TK_DO,
  "TK_ELSE": TK_ELSE,
  "TK_ELSEIF": TK_ELSEIF,
  "TK_END": TK_END,
  "TK_FALSE": TK_FALSE,
  "TK_FOR": TK_FOR,
  "TK_FUNCTION": TK_FUNCTION,
  "TK_GOTO": TK_GOTO,
  "TK_IF": TK_IF,
  "TK_IN": TK_IN,
  "TK_LOCAL": TK_LOCAL,
  "TK_NIL": TK_NIL,
  "TK_NOT": TK_NOT,
  "TK_OR": TK_OR,
  "TK_REPEAT": TK_REPEAT,
  "TK_RETURN": TK_RETURN,
  "TK_THEN": TK_THEN,
  "TK_TRUE": TK_TRUE,
  "TK_UNTIL": TK_UNTIL,
  "TK_WHILE": TK_WHILE,
  "TK_IDIV": TK_IDIV,
  "TK_CONCAT": TK_CONCAT,
  "TK_DOTS": TK_DOTS,
  "TK_EQ": TK_EQ,
  "TK_GE": TK_GE,
  "TK_LE": TK_LE,
  "TK_NE": TK_NE,
  "TK_SHL": TK_SHL,
  "TK_SHR": TK_SHR,
  "TK_DBCOLON": TK_DBCOLON,
  "TK_EOS": TK_EOS,
  "TK_FLT": TK_FLT,
  "TK_INT": TK_INT,
  "TK_NAME": TK_NAME,
  "TK_STRING": TK_STRING
};
const luaX_tokens = ["and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while", "//", "..", "...", "==", ">=", "<=", "~=", "<<", ">>", "::", "<eof>", "<number>", "<integer>", "<name>", "<string>"].map((e, i) => to_luastring(e));

class SemInfo {
  constructor() {
    this.r = NaN;
    this.i = NaN;
    this.ts = null;
  }

}

class Token {
  constructor() {
    this.token = NaN;
    this.seminfo = new SemInfo();
  }

}
/* state of the lexer plus state of the parser when shared by all
   functions */


class LexState {
  constructor() {
    this.current = NaN;
    /* current character (charint) */

    this.linenumber = NaN;
    /* input line counter */

    this.lastline = NaN;
    /* line of last token 'consumed' */

    this.t = new Token();
    /* current token */

    this.lookahead = new Token();
    /* look ahead token */

    this.fs = null;
    /* current function (parser) */

    this.L = null;
    this.z = null;
    /* input stream */

    this.buff = null;
    /* buffer for tokens */

    this.h = null;
    /* to reuse strings */

    this.dyd = null;
    /* dynamic structures used by the parser */

    this.source = null;
    /* current source name */

    this.envn = null;
    /* environment variable name */
  }

}

const save = function (ls, c) {
  let b = ls.buff;

  if (b.n + 1 > b.buffer.length) {
    if (b.buffer.length >= MAX_INT / 2) lexerror(ls, to_luastring("lexical element too long", true), 0);
    let newsize = b.buffer.length * 2;
    luaZ_resizebuffer(ls.L, b, newsize);
  }

  b.buffer[b.n++] = c < 0 ? 255 + c + 1 : c;
};

const luaX_token2str = function (ls, token) {
  if (token < FIRST_RESERVED) {
    /* single-byte symbols? */
    return lobject.luaO_pushfstring(ls.L, to_luastring("'%c'", true), token);
  } else {
    let s = luaX_tokens[token - FIRST_RESERVED];
    if (token < TK_EOS)
      /* fixed format (symbols and reserved words)? */
      return lobject.luaO_pushfstring(ls.L, to_luastring("'%s'", true), s);else
      /* names, strings, and numerals */
      return s;
  }
};

const currIsNewline = function (ls) {
  return ls.current === 10
  /* ('\n').charCodeAt(0) */
  || ls.current === 13
  /* ('\r').charCodeAt(0) */
  ;
};

const next = function (ls) {
  ls.current = ls.z.zgetc();
};

const save_and_next = function (ls) {
  save(ls, ls.current);
  next(ls);
};
/*
** creates a new string and anchors it in scanner's table so that
** it will not be collected until the end of the compilation
** (by that time it should be anchored somewhere)
*/


const TVtrue = new lobject.TValue(LUA_TBOOLEAN, true);

const luaX_newstring = function (ls, str) {
  let L = ls.L;
  let ts = luaS_new(L, str);
  /* HACK: Workaround lack of ltable 'keyfromval' */

  let tpair = ls.h.strong.get(luaS_hashlongstr(ts));

  if (!tpair) {
    /* not in use yet? */
    let key = new lobject.TValue(LUA_TLNGSTR, ts);
    ltable.luaH_setfrom(L, ls.h, key, TVtrue);
  } else {
    /* string already present */
    ts = tpair.key.tsvalue();
    /* re-use value previously stored */
  }

  return ts;
};
/*
** increment line number and skips newline sequence (any of
** \n, \r, \n\r, or \r\n)
*/


const inclinenumber = function (ls) {
  let old = ls.current;
  lua_assert(currIsNewline(ls));
  next(ls);
  /* skip '\n' or '\r' */

  if (currIsNewline(ls) && ls.current !== old) next(ls);
  /* skip '\n\r' or '\r\n' */

  if (++ls.linenumber >= MAX_INT) lexerror(ls, to_luastring("chunk has too many lines", true), 0);
};

const luaX_setinput = function (L, ls, z, source, firstchar) {
  ls.t = {
    token: 0,
    seminfo: new SemInfo()
  };
  ls.L = L;
  ls.current = firstchar;
  ls.lookahead = {
    token: TK_EOS,
    seminfo: new SemInfo()
  };
  ls.z = z;
  ls.fs = null;
  ls.linenumber = 1;
  ls.lastline = 1;
  ls.source = source;
  ls.envn = luaS_bless(L, LUA_ENV);
  luaZ_resizebuffer(L, ls.buff, LUA_MINBUFFER);
  /* initialize buffer */
};

const check_next1 = function (ls, c) {
  if (ls.current === c) {
    next(ls);
    return true;
  }

  return false;
};
/*
** Check whether current char is in set 'set' (with two chars) and
** saves it
*/


const check_next2 = function (ls, set) {
  if (ls.current === set[0].charCodeAt(0) || ls.current === set[1].charCodeAt(0)) {
    save_and_next(ls);
    return true;
  }

  return false;
};

const read_numeral = function (ls, seminfo) {
  let expo = "Ee";
  let first = ls.current;
  lua_assert(lisdigit(ls.current));
  save_and_next(ls);
  if (first === 48
  /* ('0').charCodeAt(0) */
  && check_next2(ls, "xX"))
    /* hexadecimal? */
    expo = "Pp";

  for (;;) {
    if (check_next2(ls, expo))
      /* exponent part? */
      check_next2(ls, "-+");
    /* optional exponent sign */

    if (lisxdigit(ls.current)) save_and_next(ls);else if (ls.current === 46
    /* ('.').charCodeAt(0) */
    ) save_and_next(ls);else break;
  } // save(ls, 0);


  let obj = new lobject.TValue();
  if (lobject.luaO_str2num(luaZ_buffer(ls.buff), obj) === 0)
    /* format error? */
    lexerror(ls, to_luastring("malformed number", true), TK_FLT);

  if (obj.ttisinteger()) {
    seminfo.i = obj.value;
    return TK_INT;
  } else {
    lua_assert(obj.ttisfloat());
    seminfo.r = obj.value;
    return TK_FLT;
  }
};

const txtToken = function (ls, token) {
  switch (token) {
    case TK_NAME:
    case TK_STRING:
    case TK_FLT:
    case TK_INT:
      // save(ls, 0);
      return lobject.luaO_pushfstring(ls.L, to_luastring("'%s'", true), luaZ_buffer(ls.buff));

    default:
      return luaX_token2str(ls, token);
  }
};

const lexerror = function (ls, msg, token) {
  msg = ldebug.luaG_addinfo(ls.L, msg, ls.source, ls.linenumber);
  if (token) lobject.luaO_pushfstring(ls.L, to_luastring("%s near %s"), msg, txtToken(ls, token));
  ldo.luaD_throw(ls.L, LUA_ERRSYNTAX);
};

const luaX_syntaxerror = function (ls, msg) {
  lexerror(ls, msg, ls.t.token);
};
/*
** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return
** its number of '='s; otherwise, return a negative number (-1 iff there
** are no '='s after initial bracket)
*/


const skip_sep = function (ls) {
  let count = 0;
  let s = ls.current;
  lua_assert(s === 91
  /* ('[').charCodeAt(0) */
  || s === 93
  /* (']').charCodeAt(0) */
  );
  save_and_next(ls);

  while (ls.current === 61
  /* ('=').charCodeAt(0) */
  ) {
    save_and_next(ls);
    count++;
  }

  return ls.current === s ? count : -count - 1;
};

const read_long_string = function (ls, seminfo, sep) {
  let line = ls.linenumber;
  /* initial line (for error message) */

  save_and_next(ls);
  /* skip 2nd '[' */

  if (currIsNewline(ls))
    /* string starts with a newline? */
    inclinenumber(ls);
  /* skip it */

  let skip = false;

  for (; !skip;) {
    switch (ls.current) {
      case EOZ:
        {
          /* error */
          let what = seminfo ? "string" : "comment";
          let msg = `unfinished long ${what} (starting at line ${line})`;
          lexerror(ls, to_luastring(msg), TK_EOS);
          break;
        }

      case 93
      /* (']').charCodeAt(0) */
      :
        {
          if (skip_sep(ls) === sep) {
            save_and_next(ls);
            /* skip 2nd ']' */

            skip = true;
          }

          break;
        }

      case 10
      /* ('\n').charCodeAt(0) */
      :
      case 13
      /* ('\r').charCodeAt(0) */
      :
        {
          save(ls, 10
          /* ('\n').charCodeAt(0) */
          );
          inclinenumber(ls);
          if (!seminfo) luaZ_resetbuffer(ls.buff);
          break;
        }

      default:
        {
          if (seminfo) save_and_next(ls);else next(ls);
        }
    }
  }

  if (seminfo) seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(2 + sep, ls.buff.n - (2 + sep)));
};

const esccheck = function (ls, c, msg) {
  if (!c) {
    if (ls.current !== EOZ) save_and_next(ls);
    /* add current to buffer for error message */

    lexerror(ls, msg, TK_STRING);
  }
};

const gethexa = function (ls) {
  save_and_next(ls);
  esccheck(ls, lisxdigit(ls.current), to_luastring("hexadecimal digit expected", true));
  return lobject.luaO_hexavalue(ls.current);
};

const readhexaesc = function (ls) {
  let r = gethexa(ls);
  r = (r << 4) + gethexa(ls);
  luaZ_buffremove(ls.buff, 2);
  /* remove saved chars from buffer */

  return r;
};

const readutf8desc = function (ls) {
  let i = 4;
  /* chars to be removed: '\', 'u', '{', and first digit */

  save_and_next(ls);
  /* skip 'u' */

  esccheck(ls, ls.current === 123
  /* ('{').charCodeAt(0) */
  , to_luastring("missing '{'", true));
  let r = gethexa(ls);
  /* must have at least one digit */

  save_and_next(ls);

  while (lisxdigit(ls.current)) {
    i++;
    r = (r << 4) + lobject.luaO_hexavalue(ls.current);
    esccheck(ls, r <= 0x10FFFF, to_luastring("UTF-8 value too large", true));
    save_and_next(ls);
  }

  esccheck(ls, ls.current === 125
  /* ('}').charCodeAt(0) */
  , to_luastring("missing '}'", true));
  next(ls);
  /* skip '}' */

  luaZ_buffremove(ls.buff, i);
  /* remove saved chars from buffer */

  return r;
};

const utf8esc = function (ls) {
  let buff = new Uint8Array(lobject.UTF8BUFFSZ);
  let n = lobject.luaO_utf8esc(buff, readutf8desc(ls));

  for (; n > 0; n--)
  /* add 'buff' to string */
  save(ls, buff[lobject.UTF8BUFFSZ - n]);
};

const readdecesc = function (ls) {
  let r = 0;
  /* result accumulator */

  let i;

  for (i = 0; i < 3 && lisdigit(ls.current); i++) {
    /* read up to 3 digits */
    r = 10 * r + ls.current - 48
    /* ('0').charCodeAt(0) */
    ;
    save_and_next(ls);
  }

  esccheck(ls, r <= 255, to_luastring("decimal escape too large", true));
  luaZ_buffremove(ls.buff, i);
  /* remove read digits from buffer */

  return r;
};

const read_string = function (ls, del, seminfo) {
  save_and_next(ls);
  /* keep delimiter (for error messages) */

  while (ls.current !== del) {
    switch (ls.current) {
      case EOZ:
        lexerror(ls, to_luastring("unfinished string", true), TK_EOS);
        break;

      case 10
      /* ('\n').charCodeAt(0) */
      :
      case 13
      /* ('\r').charCodeAt(0) */
      :
        lexerror(ls, to_luastring("unfinished string", true), TK_STRING);
        break;

      case 92
      /* ('\\').charCodeAt(0) */
      :
        {
          /* escape sequences */
          save_and_next(ls);
          /* keep '\\' for error messages */

          let will;
          let c;

          switch (ls.current) {
            case 97
            /* ('a').charCodeAt(0) */
            :
              c = 7
              /* \a isn't valid JS */
              ;
              will = 'read_save';
              break;

            case 98
            /* ('b').charCodeAt(0) */
            :
              c = 8
              /* ('\b').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 102
            /* ('f').charCodeAt(0) */
            :
              c = 12
              /* ('\f').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 110
            /* ('n').charCodeAt(0) */
            :
              c = 10
              /* ('\n').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 114
            /* ('r').charCodeAt(0) */
            :
              c = 13
              /* ('\r').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 116
            /* ('t').charCodeAt(0) */
            :
              c = 9
              /* ('\t').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 118
            /* ('v').charCodeAt(0) */
            :
              c = 11
              /* ('\v').charCodeAt(0) */
              ;
              will = 'read_save';
              break;

            case 120
            /* ('x').charCodeAt(0) */
            :
              c = readhexaesc(ls);
              will = 'read_save';
              break;

            case 117
            /* ('u').charCodeAt(0) */
            :
              utf8esc(ls);
              will = 'no_save';
              break;

            case 10
            /* ('\n').charCodeAt(0) */
            :
            case 13
            /* ('\r').charCodeAt(0) */
            :
              inclinenumber(ls);
              c = 10
              /* ('\n').charCodeAt(0) */
              ;
              will = 'only_save';
              break;

            case 92
            /* ('\\').charCodeAt(0) */
            :
            case 34
            /* ('"').charCodeAt(0) */
            :
            case 39
            /* ('\'').charCodeAt(0) */
            :
              c = ls.current;
              will = 'read_save';
              break;

            case EOZ:
              will = 'no_save';
              break;

            /* will raise an error next loop */

            case 122
            /* ('z').charCodeAt(0) */
            :
              {
                /* zap following span of spaces */
                luaZ_buffremove(ls.buff, 1);
                /* remove '\\' */

                next(ls);
                /* skip the 'z' */

                while (lisspace(ls.current)) {
                  if (currIsNewline(ls)) inclinenumber(ls);else next(ls);
                }

                will = 'no_save';
                break;
              }

            default:
              {
                esccheck(ls, lisdigit(ls.current), to_luastring("invalid escape sequence", true));
                c = readdecesc(ls);
                /* digital escape '\ddd' */

                will = 'only_save';
                break;
              }
          }

          if (will === 'read_save') next(ls);

          if (will === 'read_save' || will === 'only_save') {
            luaZ_buffremove(ls.buff, 1);
            /* remove '\\' */

            save(ls, c);
          }

          break;
        }

      default:
        save_and_next(ls);
    }
  }

  save_and_next(ls);
  /* skip delimiter */

  seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(1, ls.buff.n - 1));
};

const token_to_index = Object.create(null);
/* don't want to return true for e.g. 'hasOwnProperty' */

luaX_tokens.forEach((e, i) => token_to_index[luaS_hash(e)] = i);

const isreserved = function (w) {
  let kidx = token_to_index[luaS_hashlongstr(w)];
  return kidx !== void 0 && kidx <= 22;
};

const llex = function (ls, seminfo) {
  luaZ_resetbuffer(ls.buff);

  for (;;) {
    lua_assert(typeof ls.current == "number");
    /* fengari addition */

    switch (ls.current) {
      case 10
      /* ('\n').charCodeAt(0) */
      :
      case 13
      /* ('\r').charCodeAt(0) */
      :
        {
          /* line breaks */
          inclinenumber(ls);
          break;
        }

      case 32
      /* (' ').charCodeAt(0) */
      :
      case 12
      /* ('\f').charCodeAt(0) */
      :
      case 9
      /* ('\t').charCodeAt(0) */
      :
      case 11
      /* ('\v').charCodeAt(0) */
      :
        {
          /* spaces */
          next(ls);
          break;
        }

      case 45
      /* ('-').charCodeAt(0) */
      :
        {
          /* '-' or '--' (comment) */
          next(ls);
          if (ls.current !== 45
          /* ('-').charCodeAt(0) */
          ) return 45
            /* ('-').charCodeAt(0) */
            ;
          /* else is a comment */

          next(ls);

          if (ls.current === 91
          /* ('[').charCodeAt(0) */
          ) {
              /* long comment? */
              let sep = skip_sep(ls);
              luaZ_resetbuffer(ls.buff);
              /* 'skip_sep' may dirty the buffer */

              if (sep >= 0) {
                read_long_string(ls, null, sep);
                /* skip long comment */

                luaZ_resetbuffer(ls.buff);
                /* previous call may dirty the buff. */

                break;
              }
            }
          /* else short comment */


          while (!currIsNewline(ls) && ls.current !== EOZ) next(ls);
          /* skip until end of line (or end of file) */


          break;
        }

      case 91
      /* ('[').charCodeAt(0) */
      :
        {
          /* long string or simply '[' */
          let sep = skip_sep(ls);

          if (sep >= 0) {
            read_long_string(ls, seminfo, sep);
            return TK_STRING;
          } else if (sep !== -1)
            /* '[=...' missing second bracket */
            lexerror(ls, to_luastring("invalid long string delimiter", true), TK_STRING);

          return 91
          /* ('[').charCodeAt(0) */
          ;
        }

      case 61
      /* ('=').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 61
          /* ('=').charCodeAt(0) */
          )) return TK_EQ;else return 61
          /* ('=').charCodeAt(0) */
          ;
        }

      case 60
      /* ('<').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 61
          /* ('=').charCodeAt(0) */
          )) return TK_LE;else if (check_next1(ls, 60
          /* ('<').charCodeAt(0) */
          )) return TK_SHL;else return 60
          /* ('<').charCodeAt(0) */
          ;
        }

      case 62
      /* ('>').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 61
          /* ('=').charCodeAt(0) */
          )) return TK_GE;else if (check_next1(ls, 62
          /* ('>').charCodeAt(0) */
          )) return TK_SHR;else return 62
          /* ('>').charCodeAt(0) */
          ;
        }

      case 47
      /* ('/').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 47
          /* ('/').charCodeAt(0) */
          )) return TK_IDIV;else return 47
          /* ('/').charCodeAt(0) */
          ;
        }

      case 126
      /* ('~').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 61
          /* ('=').charCodeAt(0) */
          )) return TK_NE;else return 126
          /* ('~').charCodeAt(0) */
          ;
        }

      case 58
      /* (':').charCodeAt(0) */
      :
        {
          next(ls);
          if (check_next1(ls, 58
          /* (':').charCodeAt(0) */
          )) return TK_DBCOLON;else return 58
          /* (':').charCodeAt(0) */
          ;
        }

      case 34
      /* ('"').charCodeAt(0) */
      :
      case 39
      /* ('\'').charCodeAt(0) */
      :
        {
          /* short literal strings */
          read_string(ls, ls.current, seminfo);
          return TK_STRING;
        }

      case 46
      /* ('.').charCodeAt(0) */
      :
        {
          /* '.', '..', '...', or number */
          save_and_next(ls);

          if (check_next1(ls, 46
          /* ('.').charCodeAt(0) */
          )) {
            if (check_next1(ls, 46
            /* ('.').charCodeAt(0) */
            )) return TK_DOTS;
            /* '...' */
            else return TK_CONCAT;
            /* '..' */
          } else if (!lisdigit(ls.current)) return 46
          /* ('.').charCodeAt(0) */
          ;else return read_numeral(ls, seminfo);
        }

      case 48
      /* ('0').charCodeAt(0) */
      :
      case 49
      /* ('1').charCodeAt(0) */
      :
      case 50
      /* ('2').charCodeAt(0) */
      :
      case 51
      /* ('3').charCodeAt(0) */
      :
      case 52
      /* ('4').charCodeAt(0) */
      :
      case 53
      /* ('5').charCodeAt(0) */
      :
      case 54
      /* ('6').charCodeAt(0) */
      :
      case 55
      /* ('7').charCodeAt(0) */
      :
      case 56
      /* ('8').charCodeAt(0) */
      :
      case 57
      /* ('9').charCodeAt(0) */
      :
        {
          return read_numeral(ls, seminfo);
        }

      case EOZ:
        {
          return TK_EOS;
        }

      default:
        {
          if (lislalpha(ls.current)) {
            /* identifier or reserved word? */
            do {
              save_and_next(ls);
            } while (lislalnum(ls.current));

            let ts = luaX_newstring(ls, luaZ_buffer(ls.buff));
            seminfo.ts = ts;
            let kidx = token_to_index[luaS_hashlongstr(ts)];
            if (kidx !== void 0 && kidx <= 22)
              /* reserved word? */
              return kidx + FIRST_RESERVED;else return TK_NAME;
          } else {
            /* single-char tokens (+ - / ...) */
            let c = ls.current;
            next(ls);
            return c;
          }
        }
    }
  }
};

const luaX_next = function (ls) {
  ls.lastline = ls.linenumber;

  if (ls.lookahead.token !== TK_EOS) {
    /* is there a look-ahead token? */
    ls.t.token = ls.lookahead.token;
    /* use this one */

    ls.t.seminfo.i = ls.lookahead.seminfo.i;
    ls.t.seminfo.r = ls.lookahead.seminfo.r;
    ls.t.seminfo.ts = ls.lookahead.seminfo.ts;
    ls.lookahead.token = TK_EOS;
    /* and discharge it */
  } else ls.t.token = llex(ls, ls.t.seminfo);
  /* read next token */

};

const luaX_lookahead = function (ls) {
  lua_assert(ls.lookahead.token === TK_EOS);
  ls.lookahead.token = llex(ls, ls.lookahead.seminfo);
  return ls.lookahead.token;
};

module.exports.FIRST_RESERVED = FIRST_RESERVED;
module.exports.LUA_ENV = LUA_ENV;
module.exports.LexState = LexState;
module.exports.RESERVED = RESERVED;
module.exports.isreserved = isreserved;
module.exports.luaX_lookahead = luaX_lookahead;
module.exports.luaX_newstring = luaX_newstring;
module.exports.luaX_next = luaX_next;
module.exports.luaX_setinput = luaX_setinput;
module.exports.luaX_syntaxerror = luaX_syntaxerror;
module.exports.luaX_token2str = luaX_token2str;
module.exports.luaX_tokens = luaX_tokens;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

;

(function (exports) {
  'use strict';

  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var PLUS = '+'.charCodeAt(0);
  var SLASH = '/'.charCodeAt(0);
  var NUMBER = '0'.charCodeAt(0);
  var LOWER = 'a'.charCodeAt(0);
  var UPPER = 'A'.charCodeAt(0);
  var PLUS_URL_SAFE = '-'.charCodeAt(0);
  var SLASH_URL_SAFE = '_'.charCodeAt(0);

  function decode(elt) {
    var code = elt.charCodeAt(0);
    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'

    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'

    if (code < NUMBER) return -1; // no match

    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
    if (code < UPPER + 26) return code - UPPER;
    if (code < LOWER + 26) return code - LOWER + 26;
  }

  function b64ToByteArray(b64) {
    var i, j, l, tmp, placeHolders, arr;

    if (b64.length % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice


    var len = b64.length;
    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr(b64.length * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? b64.length - 4 : b64.length;
    var L = 0;

    function push(v) {
      arr[L++] = v;
    }

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
      push((tmp & 0xFF0000) >> 16);
      push((tmp & 0xFF00) >> 8);
      push(tmp & 0xFF);
    }

    if (placeHolders === 2) {
      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
      push(tmp & 0xFF);
    } else if (placeHolders === 1) {
      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
      push(tmp >> 8 & 0xFF);
      push(tmp & 0xFF);
    }

    return arr;
  }

  function uint8ToBase64(uint8) {
    var i;
    var extraBytes = uint8.length % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var temp, length;

    function encode(num) {
      return lookup.charAt(num);
    }

    function tripletToBase64(num) {
      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
    } // go through the array every three bytes, we'll deal with trailing stuff later


    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output += tripletToBase64(temp);
    } // pad the end with zeros, but make sure to not forget the extra bytes


    switch (extraBytes) {
      case 1:
        temp = uint8[uint8.length - 1];
        output += encode(temp >> 2);
        output += encode(temp << 4 & 0x3F);
        output += '==';
        break;

      case 2:
        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
        output += encode(temp >> 10);
        output += encode(temp >> 4 & 0x3F);
        output += encode(temp << 2 & 0x3F);
        output += '=';
        break;

      default:
        break;
    }

    return output;
  }

  exports.toByteArray = b64ToByteArray;
  exports.fromByteArray = uint8ToBase64;
})( false ? undefined : exports);

/***/ }),
/* 32 */
/***/ (function(module, exports) {

var proto, map;
module.exports = proto = {};
map = typeof WeakMap === 'undefined' ? null : new WeakMap();
proto.get = !map ? no_weakmap_get : get;

function no_weakmap_get(target) {
  return new DataView(target.buffer, 0);
}

function get(target) {
  var out = map.get(target.buffer);

  if (!out) {
    map.set(target.buffer, out = new DataView(target.buffer, 0));
  }

  return out;
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  luastring_of
} = __webpack_require__(1);

const luai_ctype_ = luastring_of(0x00,
/* EOZ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* 0. */
0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* 1. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
/* 2. */
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
/* 3. */
0x16, 0x16, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x05,
/* 4. */
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
/* 5. */
0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x05,
/* 6. */
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
/* 7. */
0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* 8. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* 9. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* a. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* b. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* c. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* d. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* e. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* f. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
const ALPHABIT = 0;
const DIGITBIT = 1;
const PRINTBIT = 2;
const SPACEBIT = 3;
const XDIGITBIT = 4;

const lisdigit = function (c) {
  return (luai_ctype_[c + 1] & 1 << DIGITBIT) !== 0;
};

const lisxdigit = function (c) {
  return (luai_ctype_[c + 1] & 1 << XDIGITBIT) !== 0;
};

const lisprint = function (c) {
  return (luai_ctype_[c + 1] & 1 << PRINTBIT) !== 0;
};

const lisspace = function (c) {
  return (luai_ctype_[c + 1] & 1 << SPACEBIT) !== 0;
};

const lislalpha = function (c) {
  return (luai_ctype_[c + 1] & 1 << ALPHABIT) !== 0;
};

const lislalnum = function (c) {
  return (luai_ctype_[c + 1] & (1 << ALPHABIT | 1 << DIGITBIT)) !== 0;
};

module.exports.lisdigit = lisdigit;
module.exports.lislalnum = lislalnum;
module.exports.lislalpha = lislalpha;
module.exports.lisprint = lisprint;
module.exports.lisspace = lisspace;
module.exports.lisxdigit = lisxdigit;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MULTRET,
  to_luastring
} = __webpack_require__(1);

const {
  BinOpr: {
    OPR_ADD,
    OPR_AND,
    OPR_BAND,
    OPR_BOR,
    OPR_BXOR,
    OPR_CONCAT,
    OPR_DIV,
    OPR_EQ,
    OPR_GE,
    OPR_GT,
    OPR_IDIV,
    OPR_LE,
    OPR_LT,
    OPR_MOD,
    OPR_MUL,
    OPR_NE,
    OPR_NOBINOPR,
    OPR_OR,
    OPR_POW,
    OPR_SHL,
    OPR_SHR,
    OPR_SUB
  },
  UnOpr: {
    OPR_BNOT,
    OPR_LEN,
    OPR_MINUS,
    OPR_NOT,
    OPR_NOUNOPR
  },
  NO_JUMP,
  getinstruction,
  luaK_checkstack,
  luaK_codeABC,
  luaK_codeABx,
  luaK_codeAsBx,
  luaK_codek,
  luaK_concat,
  luaK_dischargevars,
  luaK_exp2RK,
  luaK_exp2anyreg,
  luaK_exp2anyregup,
  luaK_exp2nextreg,
  luaK_exp2val,
  luaK_fixline,
  luaK_getlabel,
  luaK_goiffalse,
  luaK_goiftrue,
  luaK_indexed,
  luaK_infix,
  luaK_intK,
  luaK_jump,
  luaK_jumpto,
  luaK_nil,
  luaK_patchclose,
  luaK_patchlist,
  luaK_patchtohere,
  luaK_posfix,
  luaK_prefix,
  luaK_reserveregs,
  luaK_ret,
  luaK_self,
  luaK_setlist,
  luaK_setmultret,
  luaK_setoneret,
  luaK_setreturns,
  luaK_storevar,
  luaK_stringK
} = __webpack_require__(64);

const ldo = __webpack_require__(9);

const lfunc = __webpack_require__(14);

const llex = __webpack_require__(30);

const {
  LUAI_MAXCCALLS,
  MAX_INT,
  lua_assert
} = __webpack_require__(5);

const lobject = __webpack_require__(7);

const {
  OpCodesI: {
    OP_CALL,
    OP_CLOSURE,
    OP_FORLOOP,
    OP_FORPREP,
    OP_GETUPVAL,
    OP_MOVE,
    OP_NEWTABLE,
    OP_SETTABLE,
    OP_TAILCALL,
    OP_TFORCALL,
    OP_TFORLOOP,
    OP_VARARG
  },
  LFIELDS_PER_FLUSH,
  SETARG_B,
  SETARG_C,
  SET_OPCODE
} = __webpack_require__(17);

const {
  luaS_eqlngstr,
  luaS_new,
  luaS_newliteral
} = __webpack_require__(11);

const ltable = __webpack_require__(10);

const Proto = lfunc.Proto;
const R = llex.RESERVED;
const MAXVARS = 200;

const hasmultret = function (k) {
  return k === expkind.VCALL || k === expkind.VVARARG;
};

const eqstr = function (a, b) {
  /* TODO: use plain equality as strings are cached */
  return luaS_eqlngstr(a, b);
};

class BlockCnt {
  constructor() {
    this.previous = null;
    /* chain */

    this.firstlabel = NaN;
    /* index of first label in this block */

    this.firstgoto = NaN;
    /* index of first pending goto in this block */

    this.nactvar = NaN;
    /* # active locals outside the block */

    this.upval = NaN;
    /* true if some variable in the block is an upvalue */

    this.isloop = NaN;
    /* true if 'block' is a loop */
  }

}

const expkind = {
  VVOID: 0,

  /* when 'expdesc' describes the last expression a list,
     this kind means an empty list (so, no expression) */
  VNIL: 1,

  /* constant nil */
  VTRUE: 2,

  /* constant true */
  VFALSE: 3,

  /* constant false */
  VK: 4,

  /* constant in 'k'; info = index of constant in 'k' */
  VKFLT: 5,

  /* floating constant; nval = numerical float value */
  VKINT: 6,

  /* integer constant; nval = numerical integer value */
  VNONRELOC: 7,

  /* expression has its value in a fixed register;
     info = result register */
  VLOCAL: 8,

  /* local variable; info = local register */
  VUPVAL: 9,

  /* upvalue variable; info = index of upvalue in 'upvalues' */
  VINDEXED: 10,

  /* indexed variable;
     ind.vt = whether 't' is register or upvalue;
     ind.t = table register or upvalue;
     ind.idx = key's R/K index */
  VJMP: 11,

  /* expression is a test/comparison;
     info = pc of corresponding jump instruction */
  VRELOCABLE: 12,

  /* expression can put result in any register;
     info = instruction pc */
  VCALL: 13,

  /* expression is a function call; info = instruction pc */
  VVARARG: 14
  /* vararg expression; info = instruction pc */

};

const vkisvar = function (k) {
  return expkind.VLOCAL <= k && k <= expkind.VINDEXED;
};

const vkisinreg = function (k) {
  return k === expkind.VNONRELOC || k === expkind.VLOCAL;
};

class expdesc {
  constructor() {
    this.k = NaN;
    this.u = {
      ival: NaN,

      /* for VKINT */
      nval: NaN,

      /* for VKFLT */
      info: NaN,

      /* for generic use */
      ind: {
        /* for indexed variables (VINDEXED) */
        idx: NaN,

        /* index (R/K) */
        t: NaN,

        /* table (register or upvalue) */
        vt: NaN
        /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */

      }
    };
    this.t = NaN;
    /* patch list of 'exit when true' */

    this.f = NaN;
    /* patch list of 'exit when false' */
  }

  to(e) {
    // Copy e content to this, cf. luaK_posfix
    this.k = e.k;
    this.u = e.u;
    this.t = e.t;
    this.f = e.f;
  }

}

class FuncState {
  constructor() {
    this.f = null;
    /* current function header */

    this.prev = null;
    /* enclosing function */

    this.ls = null;
    /* lexical state */

    this.bl = null;
    /* chain of current blocks */

    this.pc = NaN;
    /* next position to code (equivalent to 'ncode') */

    this.lasttarget = NaN;
    /* 'label' of last 'jump label' */

    this.jpc = NaN;
    /* list of pending jumps to 'pc' */

    this.nk = NaN;
    /* number of elements in 'k' */

    this.np = NaN;
    /* number of elements in 'p' */

    this.firstlocal = NaN;
    /* index of first local var (in Dyndata array) */

    this.nlocvars = NaN;
    /* number of elements in 'f->locvars' */

    this.nactvar = NaN;
    /* number of active local variables */

    this.nups = NaN;
    /* number of upvalues */

    this.freereg = NaN;
    /* first free register */
  }

}
/* description of active local variable */


class Vardesc {
  constructor() {
    this.idx = NaN;
    /* variable index in stack */
  }

}
/* description of pending goto statements and label statements */


class Labeldesc {
  constructor() {
    this.name = null;
    /* label identifier */

    this.pc = NaN;
    /* position in code */

    this.line = NaN;
    /* line where it appeared */

    this.nactvar = NaN;
    /* local level where it appears in current block */
  }

}
/* list of labels or gotos */


class Labellist {
  constructor() {
    this.arr = [];
    /* array */

    this.n = NaN;
    /* number of entries in use */

    this.size = NaN;
    /* array size */
  }

}
/* dynamic structures used by the parser */


class Dyndata {
  constructor() {
    this.actvar = {
      /* list of active local variables */
      arr: [],
      n: NaN,
      size: NaN
    };
    this.gt = new Labellist();
    this.label = new Labellist();
  }

}

const semerror = function (ls, msg) {
  ls.t.token = 0;
  /* remove "near <token>" from final message */

  llex.luaX_syntaxerror(ls, msg);
};

const error_expected = function (ls, token) {
  llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L, to_luastring("%s expected", true), llex.luaX_token2str(ls, token)));
};

const errorlimit = function (fs, limit, what) {
  let L = fs.ls.L;
  let line = fs.f.linedefined;
  let where = line === 0 ? to_luastring("main function", true) : lobject.luaO_pushfstring(L, to_luastring("function at line %d", true), line);
  let msg = lobject.luaO_pushfstring(L, to_luastring("too many %s (limit is %d) in %s", true), what, limit, where);
  llex.luaX_syntaxerror(fs.ls, msg);
};

const checklimit = function (fs, v, l, what) {
  if (v > l) errorlimit(fs, l, what);
};

const testnext = function (ls, c) {
  if (ls.t.token === c) {
    llex.luaX_next(ls);
    return true;
  }

  return false;
};

const check = function (ls, c) {
  if (ls.t.token !== c) error_expected(ls, c);
};

const checknext = function (ls, c) {
  check(ls, c);
  llex.luaX_next(ls);
};

const check_condition = function (ls, c, msg) {
  if (!c) llex.luaX_syntaxerror(ls, msg);
};

const check_match = function (ls, what, who, where) {
  if (!testnext(ls, what)) {
    if (where === ls.linenumber) error_expected(ls, what);else llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L, to_luastring("%s expected (to close %s at line %d)"), llex.luaX_token2str(ls, what), llex.luaX_token2str(ls, who), where));
  }
};

const str_checkname = function (ls) {
  check(ls, R.TK_NAME);
  let ts = ls.t.seminfo.ts;
  llex.luaX_next(ls);
  return ts;
};

const init_exp = function (e, k, i) {
  e.f = e.t = NO_JUMP;
  e.k = k;
  e.u.info = i;
};

const codestring = function (ls, e, s) {
  init_exp(e, expkind.VK, luaK_stringK(ls.fs, s));
};

const checkname = function (ls, e) {
  codestring(ls, e, str_checkname(ls));
};

const registerlocalvar = function (ls, varname) {
  let fs = ls.fs;
  let f = fs.f;
  f.locvars[fs.nlocvars] = new lobject.LocVar();
  f.locvars[fs.nlocvars].varname = varname;
  return fs.nlocvars++;
};

const new_localvar = function (ls, name) {
  let fs = ls.fs;
  let dyd = ls.dyd;
  let reg = registerlocalvar(ls, name);
  checklimit(fs, dyd.actvar.n + 1 - fs.firstlocal, MAXVARS, to_luastring("local variables", true));
  dyd.actvar.arr[dyd.actvar.n] = new Vardesc();
  dyd.actvar.arr[dyd.actvar.n].idx = reg;
  dyd.actvar.n++;
};

const new_localvarliteral = function (ls, name) {
  new_localvar(ls, llex.luaX_newstring(ls, to_luastring(name, true)));
};

const getlocvar = function (fs, i) {
  let idx = fs.ls.dyd.actvar.arr[fs.firstlocal + i].idx;
  lua_assert(idx < fs.nlocvars);
  return fs.f.locvars[idx];
};

const adjustlocalvars = function (ls, nvars) {
  let fs = ls.fs;
  fs.nactvar = fs.nactvar + nvars;

  for (; nvars; nvars--) getlocvar(fs, fs.nactvar - nvars).startpc = fs.pc;
};

const removevars = function (fs, tolevel) {
  fs.ls.dyd.actvar.n -= fs.nactvar - tolevel;

  while (fs.nactvar > tolevel) getlocvar(fs, --fs.nactvar).endpc = fs.pc;
};

const searchupvalue = function (fs, name) {
  let up = fs.f.upvalues;

  for (let i = 0; i < fs.nups; i++) {
    if (eqstr(up[i].name, name)) return i;
  }

  return -1;
  /* not found */
};

const newupvalue = function (fs, name, v) {
  let f = fs.f;
  checklimit(fs, fs.nups + 1, lfunc.MAXUPVAL, to_luastring("upvalues", true));
  f.upvalues[fs.nups] = {
    instack: v.k === expkind.VLOCAL,
    idx: v.u.info,
    name: name
  };
  return fs.nups++;
};

const searchvar = function (fs, n) {
  for (let i = fs.nactvar - 1; i >= 0; i--) {
    if (eqstr(n, getlocvar(fs, i).varname)) return i;
  }

  return -1;
};
/*
** Mark block where variable at given level was defined
** (to emit close instructions later).
*/


const markupval = function (fs, level) {
  let bl = fs.bl;

  while (bl.nactvar > level) bl = bl.previous;

  bl.upval = 1;
};
/*
** Find variable with given name 'n'. If it is an upvalue, add this
** upvalue into all intermediate functions.
*/


const singlevaraux = function (fs, n, vr, base) {
  if (fs === null)
    /* no more levels? */
    init_exp(vr, expkind.VVOID, 0);
    /* default is global */
  else {
      let v = searchvar(fs, n);
      /* look up locals at current level */

      if (v >= 0) {
        /* found? */
        init_exp(vr, expkind.VLOCAL, v);
        /* variable is local */

        if (!base) markupval(fs, v);
        /* local will be used as an upval */
      } else {
        /* not found as local at current level; try upvalues */
        let idx = searchupvalue(fs, n);
        /* try existing upvalues */

        if (idx < 0) {
          /* not found? */
          singlevaraux(fs.prev, n, vr, 0);
          /* try upper levels */

          if (vr.k === expkind.VVOID)
            /* not found? */
            return;
          /* it is a global */

          /* else was LOCAL or UPVAL */

          idx = newupvalue(fs, n, vr);
          /* will be a new upvalue */
        }

        init_exp(vr, expkind.VUPVAL, idx);
        /* new or old upvalue */
      }
    }
};

const singlevar = function (ls, vr) {
  let varname = str_checkname(ls);
  let fs = ls.fs;
  singlevaraux(fs, varname, vr, 1);

  if (vr.k === expkind.VVOID) {
    /* is global name? */
    let key = new expdesc();
    singlevaraux(fs, ls.envn, vr, 1);
    /* get environment variable */

    lua_assert(vr.k !== expkind.VVOID);
    /* this one must exist */

    codestring(ls, key, varname);
    /* key is variable name */

    luaK_indexed(fs, vr, key);
    /* env[varname] */
  }
};

const adjust_assign = function (ls, nvars, nexps, e) {
  let fs = ls.fs;
  let extra = nvars - nexps;

  if (hasmultret(e.k)) {
    extra++;
    /* includes call itself */

    if (extra < 0) extra = 0;
    luaK_setreturns(fs, e, extra);
    /* last exp. provides the difference */

    if (extra > 1) luaK_reserveregs(fs, extra - 1);
  } else {
    if (e.k !== expkind.VVOID) luaK_exp2nextreg(fs, e);
    /* close last expression */

    if (extra > 0) {
      let reg = fs.freereg;
      luaK_reserveregs(fs, extra);
      luaK_nil(fs, reg, extra);
    }
  }

  if (nexps > nvars) ls.fs.freereg -= nexps - nvars;
  /* remove extra values */
};

const enterlevel = function (ls) {
  let L = ls.L;
  ++L.nCcalls;
  checklimit(ls.fs, L.nCcalls, LUAI_MAXCCALLS, to_luastring("JS levels", true));
};

const leavelevel = function (ls) {
  return ls.L.nCcalls--;
};

const closegoto = function (ls, g, label) {
  let fs = ls.fs;
  let gl = ls.dyd.gt;
  let gt = gl.arr[g];
  lua_assert(eqstr(gt.name, label.name));

  if (gt.nactvar < label.nactvar) {
    let vname = getlocvar(fs, gt.nactvar).varname;
    let msg = lobject.luaO_pushfstring(ls.L, to_luastring("<goto %s> at line %d jumps into the scope of local '%s'"), gt.name.getstr(), gt.line, vname.getstr());
    semerror(ls, msg);
  }

  luaK_patchlist(fs, gt.pc, label.pc);
  /* remove goto from pending list */

  for (let i = g; i < gl.n - 1; i++) gl.arr[i] = gl.arr[i + 1];

  gl.n--;
};
/*
** try to close a goto with existing labels; this solves backward jumps
*/


const findlabel = function (ls, g) {
  let bl = ls.fs.bl;
  let dyd = ls.dyd;
  let gt = dyd.gt.arr[g];
  /* check labels in current block for a match */

  for (let i = bl.firstlabel; i < dyd.label.n; i++) {
    let lb = dyd.label.arr[i];

    if (eqstr(lb.name, gt.name)) {
      /* correct label? */
      if (gt.nactvar > lb.nactvar && (bl.upval || dyd.label.n > bl.firstlabel)) luaK_patchclose(ls.fs, gt.pc, lb.nactvar);
      closegoto(ls, g, lb);
      /* close it */

      return true;
    }
  }

  return false;
  /* label not found; cannot close goto */
};

const newlabelentry = function (ls, l, name, line, pc) {
  let n = l.n;
  l.arr[n] = new Labeldesc();
  l.arr[n].name = name;
  l.arr[n].line = line;
  l.arr[n].nactvar = ls.fs.nactvar;
  l.arr[n].pc = pc;
  l.n = n + 1;
  return n;
};
/*
** check whether new label 'lb' matches any pending gotos in current
** block; solves forward jumps
*/


const findgotos = function (ls, lb) {
  let gl = ls.dyd.gt;
  let i = ls.fs.bl.firstgoto;

  while (i < gl.n) {
    if (eqstr(gl.arr[i].name, lb.name)) closegoto(ls, i, lb);else i++;
  }
};
/*
** export pending gotos to outer level, to check them against
** outer labels; if the block being exited has upvalues, and
** the goto exits the scope of any variable (which can be the
** upvalue), close those variables being exited.
*/


const movegotosout = function (fs, bl) {
  let i = bl.firstgoto;
  let gl = fs.ls.dyd.gt;
  /* correct pending gotos to current block and try to close it
     with visible labels */

  while (i < gl.n) {
    let gt = gl.arr[i];

    if (gt.nactvar > bl.nactvar) {
      if (bl.upval) luaK_patchclose(fs, gt.pc, bl.nactvar);
      gt.nactvar = bl.nactvar;
    }

    if (!findlabel(fs.ls, i)) i++;
    /* move to next one */
  }
};

const enterblock = function (fs, bl, isloop) {
  bl.isloop = isloop;
  bl.nactvar = fs.nactvar;
  bl.firstlabel = fs.ls.dyd.label.n;
  bl.firstgoto = fs.ls.dyd.gt.n;
  bl.upval = 0;
  bl.previous = fs.bl;
  fs.bl = bl;
  lua_assert(fs.freereg === fs.nactvar);
};
/*
** create a label named 'break' to resolve break statements
*/


const breaklabel = function (ls) {
  let n = luaS_newliteral(ls.L, "break");
  let l = newlabelentry(ls, ls.dyd.label, n, 0, ls.fs.pc);
  findgotos(ls, ls.dyd.label.arr[l]);
};
/*
** generates an error for an undefined 'goto'; choose appropriate
** message when label name is a reserved word (which can only be 'break')
*/


const undefgoto = function (ls, gt) {
  let msg = llex.isreserved(gt.name) ? "<%s> at line %d not inside a loop" : "no visible label '%s' for <goto> at line %d";
  msg = lobject.luaO_pushfstring(ls.L, to_luastring(msg), gt.name.getstr(), gt.line);
  semerror(ls, msg);
};
/*
** adds a new prototype into list of prototypes
*/


const addprototype = function (ls) {
  let L = ls.L;
  let clp = new Proto(L);
  let fs = ls.fs;
  let f = fs.f;
  /* prototype of current function */

  f.p[fs.np++] = clp;
  return clp;
};
/*
** codes instruction to create new closure in parent function.
*/


const codeclosure = function (ls, v) {
  let fs = ls.fs.prev;
  init_exp(v, expkind.VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs.np - 1));
  luaK_exp2nextreg(fs, v);
  /* fix it at the last register */
};

const open_func = function (ls, fs, bl) {
  fs.prev = ls.fs;
  /* linked list of funcstates */

  fs.ls = ls;
  ls.fs = fs;
  fs.pc = 0;
  fs.lasttarget = 0;
  fs.jpc = NO_JUMP;
  fs.freereg = 0;
  fs.nk = 0;
  fs.np = 0;
  fs.nups = 0;
  fs.nlocvars = 0;
  fs.nactvar = 0;
  fs.firstlocal = ls.dyd.actvar.n;
  fs.bl = null;
  let f = fs.f;
  f.source = ls.source;
  f.maxstacksize = 2;
  /* registers 0/1 are always valid */

  enterblock(fs, bl, false);
};

const leaveblock = function (fs) {
  let bl = fs.bl;
  let ls = fs.ls;

  if (bl.previous && bl.upval) {
    /* create a 'jump to here' to close upvalues */
    let j = luaK_jump(fs);
    luaK_patchclose(fs, j, bl.nactvar);
    luaK_patchtohere(fs, j);
  }

  if (bl.isloop) breaklabel(ls);
  /* close pending breaks */

  fs.bl = bl.previous;
  removevars(fs, bl.nactvar);
  lua_assert(bl.nactvar === fs.nactvar);
  fs.freereg = fs.nactvar;
  /* free registers */

  ls.dyd.label.n = bl.firstlabel;
  /* remove local labels */

  if (bl.previous)
    /* inner block? */
    movegotosout(fs, bl);
    /* update pending gotos to outer block */
  else if (bl.firstgoto < ls.dyd.gt.n)
      /* pending gotos in outer block? */
      undefgoto(ls, ls.dyd.gt.arr[bl.firstgoto]);
  /* error */
};

const close_func = function (ls) {
  let fs = ls.fs;
  luaK_ret(fs, 0, 0);
  /* final return */

  leaveblock(fs);
  lua_assert(fs.bl === null);
  ls.fs = fs.prev;
};
/*============================================================*/

/* GRAMMAR RULES */

/*============================================================*/


const block_follow = function (ls, withuntil) {
  switch (ls.t.token) {
    case R.TK_ELSE:
    case R.TK_ELSEIF:
    case R.TK_END:
    case R.TK_EOS:
      return true;

    case R.TK_UNTIL:
      return withuntil;

    default:
      return false;
  }
};

const statlist = function (ls) {
  /* statlist -> { stat [';'] } */
  while (!block_follow(ls, 1)) {
    if (ls.t.token === R.TK_RETURN) {
      statement(ls);
      return;
      /* 'return' must be last statement */
    }

    statement(ls);
  }
};

const fieldsel = function (ls, v) {
  /* fieldsel -> ['.' | ':'] NAME */
  let fs = ls.fs;
  let key = new expdesc();
  luaK_exp2anyregup(fs, v);
  llex.luaX_next(ls);
  /* skip the dot or colon */

  checkname(ls, key);
  luaK_indexed(fs, v, key);
};

const yindex = function (ls, v) {
  /* index -> '[' expr ']' */
  llex.luaX_next(ls);
  /* skip the '[' */

  expr(ls, v);
  luaK_exp2val(ls.fs, v);
  checknext(ls, 93
  /* (']').charCodeAt(0) */
  );
};
/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/


class ConsControl {
  constructor() {
    this.v = new expdesc();
    /* last list item read */

    this.t = new expdesc();
    /* table descriptor */

    this.nh = NaN;
    /* total number of 'record' elements */

    this.na = NaN;
    /* total number of array elements */

    this.tostore = NaN;
    /* number of array elements pending to be stored */
  }

}

const recfield = function (ls, cc) {
  /* recfield -> (NAME | '['exp1']') = exp1 */
  let fs = ls.fs;
  let reg = ls.fs.freereg;
  let key = new expdesc();
  let val = new expdesc();

  if (ls.t.token === R.TK_NAME) {
    checklimit(fs, cc.nh, MAX_INT, to_luastring("items in a constructor", true));
    checkname(ls, key);
  } else
    /* ls->t.token === '[' */
    yindex(ls, key);

  cc.nh++;
  checknext(ls, 61
  /* ('=').charCodeAt(0) */
  );
  let rkkey = luaK_exp2RK(fs, key);
  expr(ls, val);
  luaK_codeABC(fs, OP_SETTABLE, cc.t.u.info, rkkey, luaK_exp2RK(fs, val));
  fs.freereg = reg;
  /* free registers */
};

const closelistfield = function (fs, cc) {
  if (cc.v.k === expkind.VVOID) return;
  /* there is no list item */

  luaK_exp2nextreg(fs, cc.v);
  cc.v.k = expkind.VVOID;

  if (cc.tostore === LFIELDS_PER_FLUSH) {
    luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);
    /* flush */

    cc.tostore = 0;
    /* no more items pending */
  }
};

const lastlistfield = function (fs, cc) {
  if (cc.tostore === 0) return;

  if (hasmultret(cc.v.k)) {
    luaK_setmultret(fs, cc.v);
    luaK_setlist(fs, cc.t.u.info, cc.na, LUA_MULTRET);
    cc.na--;
    /* do not count last expression (unknown number of elements) */
  } else {
    if (cc.v.k !== expkind.VVOID) luaK_exp2nextreg(fs, cc.v);
    luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);
  }
};

const listfield = function (ls, cc) {
  /* listfield -> exp */
  expr(ls, cc.v);
  checklimit(ls.fs, cc.na, MAX_INT, to_luastring("items in a constructor", true));
  cc.na++;
  cc.tostore++;
};

const field = function (ls, cc) {
  /* field -> listfield | recfield */
  switch (ls.t.token) {
    case R.TK_NAME:
      {
        /* may be 'listfield' or 'recfield' */
        if (llex.luaX_lookahead(ls) !== 61
        /* ('=').charCodeAt(0) */
        )
          /* expression? */
          listfield(ls, cc);else recfield(ls, cc);
        break;
      }

    case 91
    /* ('[').charCodeAt(0) */
    :
      {
        recfield(ls, cc);
        break;
      }

    default:
      {
        listfield(ls, cc);
        break;
      }
  }
};

const constructor = function (ls, t) {
  /* constructor -> '{' [ field { sep field } [sep] ] '}'
     sep -> ',' | ';' */
  let fs = ls.fs;
  let line = ls.linenumber;
  let pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
  let cc = new ConsControl();
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  init_exp(t, expkind.VRELOCABLE, pc);
  init_exp(cc.v, expkind.VVOID, 0);
  /* no value (yet) */

  luaK_exp2nextreg(ls.fs, t);
  /* fix it at stack top */

  checknext(ls, 123
  /* ('{').charCodeAt(0) */
  );

  do {
    lua_assert(cc.v.k === expkind.VVOID || cc.tostore > 0);
    if (ls.t.token === 125
    /* ('}').charCodeAt(0) */
    ) break;
    closelistfield(fs, cc);
    field(ls, cc);
  } while (testnext(ls, 44
  /* (',').charCodeAt(0) */
  ) || testnext(ls, 59
  /* (';').charCodeAt(0) */
  ));

  check_match(ls, 125
  /* ('}').charCodeAt(0) */
  , 123
  /* ('{').charCodeAt(0) */
  , line);
  lastlistfield(fs, cc);
  SETARG_B(fs.f.code[pc], lobject.luaO_int2fb(cc.na));
  /* set initial array size */

  SETARG_C(fs.f.code[pc], lobject.luaO_int2fb(cc.nh));
  /* set initial table size */
};
/* }====================================================================== */


const parlist = function (ls) {
  /* parlist -> [ param { ',' param } ] */
  let fs = ls.fs;
  let f = fs.f;
  let nparams = 0;
  f.is_vararg = false;

  if (ls.t.token !== 41
  /* (')').charCodeAt(0) */
  ) {
      /* is 'parlist' not empty? */
      do {
        switch (ls.t.token) {
          case R.TK_NAME:
            {
              /* param -> NAME */
              new_localvar(ls, str_checkname(ls));
              nparams++;
              break;
            }

          case R.TK_DOTS:
            {
              /* param -> '...' */
              llex.luaX_next(ls);
              f.is_vararg = true;
              /* declared vararg */

              break;
            }

          default:
            llex.luaX_syntaxerror(ls, to_luastring("<name> or '...' expected", true));
        }
      } while (!f.is_vararg && testnext(ls, 44
      /* (',').charCodeAt(0) */
      ));
    }

  adjustlocalvars(ls, nparams);
  f.numparams = fs.nactvar;
  luaK_reserveregs(fs, fs.nactvar);
  /* reserve register for parameters */
};

const body = function (ls, e, ismethod, line) {
  /* body ->  '(' parlist ')' block END */
  let new_fs = new FuncState();
  let bl = new BlockCnt();
  new_fs.f = addprototype(ls);
  new_fs.f.linedefined = line;
  open_func(ls, new_fs, bl);
  checknext(ls, 40
  /* ('(').charCodeAt(0) */
  );

  if (ismethod) {
    new_localvarliteral(ls, "self");
    /* create 'self' parameter */

    adjustlocalvars(ls, 1);
  }

  parlist(ls);
  checknext(ls, 41
  /* (')').charCodeAt(0) */
  );
  statlist(ls);
  new_fs.f.lastlinedefined = ls.linenumber;
  check_match(ls, R.TK_END, R.TK_FUNCTION, line);
  codeclosure(ls, e);
  close_func(ls);
};

const explist = function (ls, v) {
  /* explist -> expr { ',' expr } */
  let n = 1;
  /* at least one expression */

  expr(ls, v);

  while (testnext(ls, 44
  /* (',').charCodeAt(0) */
  )) {
    luaK_exp2nextreg(ls.fs, v);
    expr(ls, v);
    n++;
  }

  return n;
};

const funcargs = function (ls, f, line) {
  let fs = ls.fs;
  let args = new expdesc();

  switch (ls.t.token) {
    case 40
    /* ('(').charCodeAt(0) */
    :
      {
        /* funcargs -> '(' [ explist ] ')' */
        llex.luaX_next(ls);
        if (ls.t.token === 41
        /* (')').charCodeAt(0) */
        )
          /* arg list is empty? */
          args.k = expkind.VVOID;else {
          explist(ls, args);
          luaK_setmultret(fs, args);
        }
        check_match(ls, 41
        /* (')').charCodeAt(0) */
        , 40
        /* ('(').charCodeAt(0) */
        , line);
        break;
      }

    case 123
    /* ('{').charCodeAt(0) */
    :
      {
        /* funcargs -> constructor */
        constructor(ls, args);
        break;
      }

    case R.TK_STRING:
      {
        /* funcargs -> STRING */
        codestring(ls, args, ls.t.seminfo.ts);
        llex.luaX_next(ls);
        /* must use 'seminfo' before 'next' */

        break;
      }

    default:
      {
        llex.luaX_syntaxerror(ls, to_luastring("function arguments expected", true));
      }
  }

  lua_assert(f.k === expkind.VNONRELOC);
  let nparams;
  let base = f.u.info;
  /* base register for call */

  if (hasmultret(args.k)) nparams = LUA_MULTRET;
  /* open call */
  else {
      if (args.k !== expkind.VVOID) luaK_exp2nextreg(fs, args);
      /* close last argument */

      nparams = fs.freereg - (base + 1);
    }
  init_exp(f, expkind.VCALL, luaK_codeABC(fs, OP_CALL, base, nparams + 1, 2));
  luaK_fixline(fs, line);
  fs.freereg = base + 1;
  /* call remove function and arguments and leaves (unless changed) one result */
};
/*
** {======================================================================
** Expression parsing
** =======================================================================
*/


const primaryexp = function (ls, v) {
  /* primaryexp -> NAME | '(' expr ')' */
  switch (ls.t.token) {
    case 40
    /* ('(').charCodeAt(0) */
    :
      {
        let line = ls.linenumber;
        llex.luaX_next(ls);
        expr(ls, v);
        check_match(ls, 41
        /* (')').charCodeAt(0) */
        , 40
        /* ('(').charCodeAt(0) */
        , line);
        luaK_dischargevars(ls.fs, v);
        return;
      }

    case R.TK_NAME:
      {
        singlevar(ls, v);
        return;
      }

    default:
      {
        llex.luaX_syntaxerror(ls, to_luastring("unexpected symbol", true));
      }
  }
};

const suffixedexp = function (ls, v) {
  /* suffixedexp ->
     primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
  let fs = ls.fs;
  let line = ls.linenumber;
  primaryexp(ls, v);

  for (;;) {
    switch (ls.t.token) {
      case 46
      /* ('.').charCodeAt(0) */
      :
        {
          /* fieldsel */
          fieldsel(ls, v);
          break;
        }

      case 91
      /* ('[').charCodeAt(0) */
      :
        {
          /* '[' exp1 ']' */
          let key = new expdesc();
          luaK_exp2anyregup(fs, v);
          yindex(ls, key);
          luaK_indexed(fs, v, key);
          break;
        }

      case 58
      /* (':').charCodeAt(0) */
      :
        {
          /* ':' NAME funcargs */
          let key = new expdesc();
          llex.luaX_next(ls);
          checkname(ls, key);
          luaK_self(fs, v, key);
          funcargs(ls, v, line);
          break;
        }

      case 40
      /* ('(').charCodeAt(0) */
      :
      case R.TK_STRING:
      case 123
      /* ('{').charCodeAt(0) */
      :
        {
          /* funcargs */
          luaK_exp2nextreg(fs, v);
          funcargs(ls, v, line);
          break;
        }

      default:
        return;
    }
  }
};

const simpleexp = function (ls, v) {
  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
     constructor | FUNCTION body | suffixedexp */
  switch (ls.t.token) {
    case R.TK_FLT:
      {
        init_exp(v, expkind.VKFLT, 0);
        v.u.nval = ls.t.seminfo.r;
        break;
      }

    case R.TK_INT:
      {
        init_exp(v, expkind.VKINT, 0);
        v.u.ival = ls.t.seminfo.i;
        break;
      }

    case R.TK_STRING:
      {
        codestring(ls, v, ls.t.seminfo.ts);
        break;
      }

    case R.TK_NIL:
      {
        init_exp(v, expkind.VNIL, 0);
        break;
      }

    case R.TK_TRUE:
      {
        init_exp(v, expkind.VTRUE, 0);
        break;
      }

    case R.TK_FALSE:
      {
        init_exp(v, expkind.VFALSE, 0);
        break;
      }

    case R.TK_DOTS:
      {
        /* vararg */
        let fs = ls.fs;
        check_condition(ls, fs.f.is_vararg, to_luastring("cannot use '...' outside a vararg function", true));
        init_exp(v, expkind.VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
        break;
      }

    case 123
    /* ('{').charCodeAt(0) */
    :
      {
        /* constructor */
        constructor(ls, v);
        return;
      }

    case R.TK_FUNCTION:
      {
        llex.luaX_next(ls);
        body(ls, v, 0, ls.linenumber);
        return;
      }

    default:
      {
        suffixedexp(ls, v);
        return;
      }
  }

  llex.luaX_next(ls);
};

const getunopr = function (op) {
  switch (op) {
    case R.TK_NOT:
      return OPR_NOT;

    case 45
    /* ('-').charCodeAt(0) */
    :
      return OPR_MINUS;

    case 126
    /* ('~').charCodeAt(0) */
    :
      return OPR_BNOT;

    case 35
    /* ('#').charCodeAt(0) */
    :
      return OPR_LEN;

    default:
      return OPR_NOUNOPR;
  }
};

const getbinopr = function (op) {
  switch (op) {
    case 43
    /* ('+').charCodeAt(0) */
    :
      return OPR_ADD;

    case 45
    /* ('-').charCodeAt(0) */
    :
      return OPR_SUB;

    case 42
    /* ('*').charCodeAt(0) */
    :
      return OPR_MUL;

    case 37
    /* ('%').charCodeAt(0) */
    :
      return OPR_MOD;

    case 94
    /* ('^').charCodeAt(0) */
    :
      return OPR_POW;

    case 47
    /* ('/').charCodeAt(0) */
    :
      return OPR_DIV;

    case R.TK_IDIV:
      return OPR_IDIV;

    case 38
    /* ('&').charCodeAt(0) */
    :
      return OPR_BAND;

    case 124
    /* ('|').charCodeAt(0) */
    :
      return OPR_BOR;

    case 126
    /* ('~').charCodeAt(0) */
    :
      return OPR_BXOR;

    case R.TK_SHL:
      return OPR_SHL;

    case R.TK_SHR:
      return OPR_SHR;

    case R.TK_CONCAT:
      return OPR_CONCAT;

    case R.TK_NE:
      return OPR_NE;

    case R.TK_EQ:
      return OPR_EQ;

    case 60
    /* ('<').charCodeAt(0) */
    :
      return OPR_LT;

    case R.TK_LE:
      return OPR_LE;

    case 62
    /* ('>').charCodeAt(0) */
    :
      return OPR_GT;

    case R.TK_GE:
      return OPR_GE;

    case R.TK_AND:
      return OPR_AND;

    case R.TK_OR:
      return OPR_OR;

    default:
      return OPR_NOBINOPR;
  }
};

const priority = [
/* ORDER OPR */
{
  left: 10,
  right: 10
}, {
  left: 10,
  right: 10
},
/* '+' '-' */
{
  left: 11,
  right: 11
}, {
  left: 11,
  right: 11
},
/* '*' '%' */
{
  left: 14,
  right: 13
},
/* '^' (right associative) */
{
  left: 11,
  right: 11
}, {
  left: 11,
  right: 11
},
/* '/' '//' */
{
  left: 6,
  right: 6
}, {
  left: 4,
  right: 4
}, {
  left: 5,
  right: 5
},
/* '&' '|' '~' */
{
  left: 7,
  right: 7
}, {
  left: 7,
  right: 7
},
/* '<<' '>>' */
{
  left: 9,
  right: 8
},
/* '..' (right associative) */
{
  left: 3,
  right: 3
}, {
  left: 3,
  right: 3
}, {
  left: 3,
  right: 3
},
/* ==, <, <= */
{
  left: 3,
  right: 3
}, {
  left: 3,
  right: 3
}, {
  left: 3,
  right: 3
},
/* ~=, >, >= */
{
  left: 2,
  right: 2
}, {
  left: 1,
  right: 1
}
/* and, or */
];
const UNARY_PRIORITY = 12;
/*
** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
** where 'binop' is any binary operator with a priority higher than 'limit'
*/

const subexpr = function (ls, v, limit) {
  enterlevel(ls);
  let uop = getunopr(ls.t.token);

  if (uop !== OPR_NOUNOPR) {
    let line = ls.linenumber;
    llex.luaX_next(ls);
    subexpr(ls, v, UNARY_PRIORITY);
    luaK_prefix(ls.fs, uop, v, line);
  } else simpleexp(ls, v);
  /* expand while operators have priorities higher than 'limit' */


  let op = getbinopr(ls.t.token);

  while (op !== OPR_NOBINOPR && priority[op].left > limit) {
    let v2 = new expdesc();
    let line = ls.linenumber;
    llex.luaX_next(ls);
    luaK_infix(ls.fs, op, v);
    /* read sub-expression with higher priority */

    let nextop = subexpr(ls, v2, priority[op].right);
    luaK_posfix(ls.fs, op, v, v2, line);
    op = nextop;
  }

  leavelevel(ls);
  return op;
  /* return first untreated operator */
};

const expr = function (ls, v) {
  subexpr(ls, v, 0);
};
/* }==================================================================== */

/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/


const block = function (ls) {
  /* block -> statlist */
  let fs = ls.fs;
  let bl = new BlockCnt();
  enterblock(fs, bl, 0);
  statlist(ls);
  leaveblock(fs);
};
/*
** structure to chain all variables in the left-hand side of an
** assignment
*/


class LHS_assign {
  constructor() {
    this.prev = null;
    this.v = new expdesc();
    /* variable (global, local, upvalue, or indexed) */
  }

}
/*
** check whether, in an assignment to an upvalue/local variable, the
** upvalue/local variable is begin used in a previous assignment to a
** table. If so, save original upvalue/local value in a safe place and
** use this safe copy in the previous assignment.
*/


const check_conflict = function (ls, lh, v) {
  let fs = ls.fs;
  let extra = fs.freereg;
  /* eventual position to save local variable */

  let conflict = false;

  for (; lh; lh = lh.prev) {
    /* check all previous assignments */
    if (lh.v.k === expkind.VINDEXED) {
      /* assigning to a table? */

      /* table is the upvalue/local being assigned now? */
      if (lh.v.u.ind.vt === v.k && lh.v.u.ind.t === v.u.info) {
        conflict = true;
        lh.v.u.ind.vt = expkind.VLOCAL;
        lh.v.u.ind.t = extra;
        /* previous assignment will use safe copy */
      }
      /* index is the local being assigned? (index cannot be upvalue) */


      if (v.k === expkind.VLOCAL && lh.v.u.ind.idx === v.u.info) {
        conflict = true;
        lh.v.u.ind.idx = extra;
        /* previous assignment will use safe copy */
      }
    }
  }

  if (conflict) {
    /* copy upvalue/local value to a temporary (in position 'extra') */
    let op = v.k === expkind.VLOCAL ? OP_MOVE : OP_GETUPVAL;
    luaK_codeABC(fs, op, extra, v.u.info, 0);
    luaK_reserveregs(fs, 1);
  }
};

const assignment = function (ls, lh, nvars) {
  let e = new expdesc();
  check_condition(ls, vkisvar(lh.v.k), to_luastring("syntax error", true));

  if (testnext(ls, 44
  /* (',').charCodeAt(0) */
  )) {
    /* assignment -> ',' suffixedexp assignment */
    let nv = new LHS_assign();
    nv.prev = lh;
    suffixedexp(ls, nv.v);
    if (nv.v.k !== expkind.VINDEXED) check_conflict(ls, lh, nv.v);
    checklimit(ls.fs, nvars + ls.L.nCcalls, LUAI_MAXCCALLS, to_luastring("JS levels", true));
    assignment(ls, nv, nvars + 1);
  } else {
    /* assignment -> '=' explist */
    checknext(ls, 61
    /* ('=').charCodeAt(0) */
    );
    let nexps = explist(ls, e);
    if (nexps !== nvars) adjust_assign(ls, nvars, nexps, e);else {
      luaK_setoneret(ls.fs, e);
      /* close last expression */

      luaK_storevar(ls.fs, lh.v, e);
      return;
      /* avoid default */
    }
  }

  init_exp(e, expkind.VNONRELOC, ls.fs.freereg - 1);
  /* default assignment */

  luaK_storevar(ls.fs, lh.v, e);
};

const cond = function (ls) {
  /* cond -> exp */
  let v = new expdesc();
  expr(ls, v);
  /* read condition */

  if (v.k === expkind.VNIL) v.k = expkind.VFALSE;
  /* 'falses' are all equal here */

  luaK_goiftrue(ls.fs, v);
  return v.f;
};

const gotostat = function (ls, pc) {
  let line = ls.linenumber;
  let label;
  if (testnext(ls, R.TK_GOTO)) label = str_checkname(ls);else {
    llex.luaX_next(ls);
    /* skip break */

    label = luaS_newliteral(ls.L, "break");
  }
  let g = newlabelentry(ls, ls.dyd.gt, label, line, pc);
  findlabel(ls, g);
  /* close it if label already defined */
};
/* check for repeated labels on the same block */


const checkrepeated = function (fs, ll, label) {
  for (let i = fs.bl.firstlabel; i < ll.n; i++) {
    if (eqstr(label, ll.arr[i].name)) {
      let msg = lobject.luaO_pushfstring(fs.ls.L, to_luastring("label '%s' already defined on line %d", true), label.getstr(), ll.arr[i].line);
      semerror(fs.ls, msg);
    }
  }
};
/* skip no-op statements */


const skipnoopstat = function (ls) {
  while (ls.t.token === 59
  /* (';').charCodeAt(0) */
  || ls.t.token === R.TK_DBCOLON) statement(ls);
};

const labelstat = function (ls, label, line) {
  /* label -> '::' NAME '::' */
  let fs = ls.fs;
  let ll = ls.dyd.label;
  let l;
  /* index of new label being created */

  checkrepeated(fs, ll, label);
  /* check for repeated labels */

  checknext(ls, R.TK_DBCOLON);
  /* skip double colon */

  /* create new entry for this label */

  l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));
  skipnoopstat(ls);
  /* skip other no-op statements */

  if (block_follow(ls, 0)) {
    /* label is last no-op statement in the block? */

    /* assume that locals are already out of scope */
    ll.arr[l].nactvar = fs.bl.nactvar;
  }

  findgotos(ls, ll.arr[l]);
};

const whilestat = function (ls, line) {
  /* whilestat -> WHILE cond DO block END */
  let fs = ls.fs;
  let bl = new BlockCnt();
  llex.luaX_next(ls);
  /* skip WHILE */

  let whileinit = luaK_getlabel(fs);
  let condexit = cond(ls);
  enterblock(fs, bl, 1);
  checknext(ls, R.TK_DO);
  block(ls);
  luaK_jumpto(fs, whileinit);
  check_match(ls, R.TK_END, R.TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);
  /* false conditions finish the loop */
};

const repeatstat = function (ls, line) {
  /* repeatstat -> REPEAT block UNTIL cond */
  let fs = ls.fs;
  let repeat_init = luaK_getlabel(fs);
  let bl1 = new BlockCnt();
  let bl2 = new BlockCnt();
  enterblock(fs, bl1, 1);
  /* loop block */

  enterblock(fs, bl2, 0);
  /* scope block */

  llex.luaX_next(ls);
  /* skip REPEAT */

  statlist(ls);
  check_match(ls, R.TK_UNTIL, R.TK_REPEAT, line);
  let condexit = cond(ls);
  /* read condition (inside scope block) */

  if (bl2.upval)
    /* upvalues? */
    luaK_patchclose(fs, condexit, bl2.nactvar);
  leaveblock(fs);
  /* finish scope */

  luaK_patchlist(fs, condexit, repeat_init);
  /* close the loop */

  leaveblock(fs);
  /* finish loop */
};

const exp1 = function (ls) {
  let e = new expdesc();
  expr(ls, e);
  luaK_exp2nextreg(ls.fs, e);
  lua_assert(e.k === expkind.VNONRELOC);
  let reg = e.u.info;
  return reg;
};

const forbody = function (ls, base, line, nvars, isnum) {
  /* forbody -> DO block */
  let bl = new BlockCnt();
  let fs = ls.fs;
  let endfor;
  adjustlocalvars(ls, 3);
  /* control variables */

  checknext(ls, R.TK_DO);
  let prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
  enterblock(fs, bl, 0);
  /* scope for declared variables */

  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);
  /* end of scope for declared variables */

  luaK_patchtohere(fs, prep);
  if (isnum)
    /* end of scope for declared variables */
    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);else {
    /* generic for */
    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
    luaK_fixline(fs, line);
    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
  }
  luaK_patchlist(fs, endfor, prep + 1);
  luaK_fixline(fs, line);
};

const fornum = function (ls, varname, line) {
  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
  let fs = ls.fs;
  let base = fs.freereg;
  new_localvarliteral(ls, "(for index)");
  new_localvarliteral(ls, "(for limit)");
  new_localvarliteral(ls, "(for step)");
  new_localvar(ls, varname);
  checknext(ls, 61
  /* ('=').charCodeAt(0) */
  );
  exp1(ls);
  /* initial value */

  checknext(ls, 44
  /* (',').charCodeAt(0) */
  );
  exp1(ls);
  /* limit */

  if (testnext(ls, 44
  /* (',').charCodeAt(0) */
  )) exp1(ls);
  /* optional step */
  else {
      /* default step = 1 */
      luaK_codek(fs, fs.freereg, luaK_intK(fs, 1));
      luaK_reserveregs(fs, 1);
    }
  forbody(ls, base, line, 1, 1);
};

const forlist = function (ls, indexname) {
  /* forlist -> NAME {,NAME} IN explist forbody */
  let fs = ls.fs;
  let e = new expdesc();
  let nvars = 4;
  /* gen, state, control, plus at least one declared var */

  let base = fs.freereg;
  /* create control variables */

  new_localvarliteral(ls, "(for generator)");
  new_localvarliteral(ls, "(for state)");
  new_localvarliteral(ls, "(for control)");
  /* create declared variables */

  new_localvar(ls, indexname);

  while (testnext(ls, 44
  /* (',').charCodeAt(0) */
  )) {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  }

  checknext(ls, R.TK_IN);
  let line = ls.linenumber;
  adjust_assign(ls, 3, explist(ls, e), e);
  luaK_checkstack(fs, 3);
  /* extra space to call generator */

  forbody(ls, base, line, nvars - 3, 0);
};

const forstat = function (ls, line) {
  /* forstat -> FOR (fornum | forlist) END */
  let fs = ls.fs;
  let bl = new BlockCnt();
  enterblock(fs, bl, 1);
  /* scope for loop and control variables */

  llex.luaX_next(ls);
  /* skip 'for' */

  let varname = str_checkname(ls);
  /* first variable name */

  switch (ls.t.token) {
    case 61
    /* ('=').charCodeAt(0) */
    :
      fornum(ls, varname, line);
      break;

    case 44
    /* (',').charCodeAt(0) */
    :
    case R.TK_IN:
      forlist(ls, varname);
      break;

    default:
      llex.luaX_syntaxerror(ls, to_luastring("'=' or 'in' expected", true));
  }

  check_match(ls, R.TK_END, R.TK_FOR, line);
  leaveblock(fs);
  /* loop scope ('break' jumps to this point) */
};

const test_then_block = function (ls, escapelist) {
  /* test_then_block -> [IF | ELSEIF] cond THEN block */
  let bl = new BlockCnt();
  let fs = ls.fs;
  let v = new expdesc();
  let jf;
  /* instruction to skip 'then' code (if condition is false) */

  llex.luaX_next(ls);
  /* skip IF or ELSEIF */

  expr(ls, v);
  /* read condition */

  checknext(ls, R.TK_THEN);

  if (ls.t.token === R.TK_GOTO || ls.t.token === R.TK_BREAK) {
    luaK_goiffalse(ls.fs, v);
    /* will jump to label if condition is true */

    enterblock(fs, bl, false);
    /* must enter block before 'goto' */

    gotostat(ls, v.t);
    /* handle goto/break */

    while (testnext(ls, 59
    /* (';').charCodeAt(0) */
    ));
    /* skip colons */


    if (block_follow(ls, 0)) {
      /* 'goto' is the entire block? */
      leaveblock(fs);
      return escapelist;
      /* and that is it */
    } else
      /* must skip over 'then' part if condition is false */
      jf = luaK_jump(fs);
  } else {
    /* regular case (not goto/break) */
    luaK_goiftrue(ls.fs, v);
    /* skip over block if condition is false */

    enterblock(fs, bl, false);
    jf = v.f;
  }

  statlist(ls);
  /* 'then' part */

  leaveblock(fs);
  if (ls.t.token === R.TK_ELSE || ls.t.token === R.TK_ELSEIF)
    /* followed by 'else'/'elseif'? */
    escapelist = luaK_concat(fs, escapelist, luaK_jump(fs));
  /* must jump over it */

  luaK_patchtohere(fs, jf);
  return escapelist;
};

const ifstat = function (ls, line) {
  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  let fs = ls.fs;
  let escapelist = NO_JUMP;
  /* exit list for finished parts */

  escapelist = test_then_block(ls, escapelist);
  /* IF cond THEN block */

  while (ls.t.token === R.TK_ELSEIF) escapelist = test_then_block(ls, escapelist);
  /* ELSEIF cond THEN block */


  if (testnext(ls, R.TK_ELSE)) block(ls);
  /* 'else' part */

  check_match(ls, R.TK_END, R.TK_IF, line);
  luaK_patchtohere(fs, escapelist);
  /* patch escape list to 'if' end */
};

const localfunc = function (ls) {
  let b = new expdesc();
  let fs = ls.fs;
  new_localvar(ls, str_checkname(ls));
  /* new local variable */

  adjustlocalvars(ls, 1);
  /* enter its scope */

  body(ls, b, 0, ls.linenumber);
  /* function created in next register */

  /* debug information will only see the variable after this point! */

  getlocvar(fs, b.u.info).startpc = fs.pc;
};

const localstat = function (ls) {
  /* stat -> LOCAL NAME {',' NAME} ['=' explist] */
  let nvars = 0;
  let nexps;
  let e = new expdesc();

  do {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  } while (testnext(ls, 44
  /* (',').charCodeAt(0) */
  ));

  if (testnext(ls, 61
  /* ('=').charCodeAt(0) */
  )) nexps = explist(ls, e);else {
    e.k = expkind.VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, e);
  adjustlocalvars(ls, nvars);
};

const funcname = function (ls, v) {
  /* funcname -> NAME {fieldsel} [':' NAME] */
  let ismethod = 0;
  singlevar(ls, v);

  while (ls.t.token === 46
  /* ('.').charCodeAt(0) */
  ) fieldsel(ls, v);

  if (ls.t.token === 58
  /* (':').charCodeAt(0) */
  ) {
      ismethod = 1;
      fieldsel(ls, v);
    }

  return ismethod;
};

const funcstat = function (ls, line) {
  /* funcstat -> FUNCTION funcname body */
  let v = new expdesc();
  let b = new expdesc();
  llex.luaX_next(ls);
  /* skip FUNCTION */

  let ismethod = funcname(ls, v);
  body(ls, b, ismethod, line);
  luaK_storevar(ls.fs, v, b);
  luaK_fixline(ls.fs, line);
  /* definition "happens" in the first line */
};

const exprstat = function (ls) {
  /* stat -> func | assignment */
  let fs = ls.fs;
  let v = new LHS_assign();
  suffixedexp(ls, v.v);

  if (ls.t.token === 61
  /* ('=').charCodeAt(0) */
  || ls.t.token === 44
  /* (',').charCodeAt(0) */
  ) {
      /* stat . assignment ? */
      v.prev = null;
      assignment(ls, v, 1);
    } else {
    /* stat -> func */
    check_condition(ls, v.v.k === expkind.VCALL, to_luastring("syntax error", true));
    SETARG_C(getinstruction(fs, v.v), 1);
    /* call statement uses no results */
  }
};

const retstat = function (ls) {
  /* stat -> RETURN [explist] [';'] */
  let fs = ls.fs;
  let e = new expdesc();
  let first, nret;
  /* registers with returned values */

  if (block_follow(ls, 1) || ls.t.token === 59
  /* (';').charCodeAt(0) */
  ) first = nret = 0;
    /* return no values */
  else {
      nret = explist(ls, e);
      /* optional return values */

      if (hasmultret(e.k)) {
        luaK_setmultret(fs, e);

        if (e.k === expkind.VCALL && nret === 1) {
          /* tail call? */
          SET_OPCODE(getinstruction(fs, e), OP_TAILCALL);
          lua_assert(getinstruction(fs, e).A === fs.nactvar);
        }

        first = fs.nactvar;
        nret = LUA_MULTRET;
        /* return all values */
      } else {
        if (nret === 1)
          /* only one single value? */
          first = luaK_exp2anyreg(fs, e);else {
          luaK_exp2nextreg(fs, e);
          /* values must go to the stack */

          first = fs.nactvar;
          /* return all active values */

          lua_assert(nret === fs.freereg - first);
        }
      }
    }
  luaK_ret(fs, first, nret);
  testnext(ls, 59
  /* (';').charCodeAt(0) */
  );
  /* skip optional semicolon */
};

const statement = function (ls) {
  let line = ls.linenumber;
  /* may be needed for error messages */

  enterlevel(ls);

  switch (ls.t.token) {
    case 59
    /* (';').charCodeAt(0) */
    :
      {
        /* stat -> ';' (empty statement) */
        llex.luaX_next(ls);
        /* skip ';' */

        break;
      }

    case R.TK_IF:
      {
        /* stat -> ifstat */
        ifstat(ls, line);
        break;
      }

    case R.TK_WHILE:
      {
        /* stat -> whilestat */
        whilestat(ls, line);
        break;
      }

    case R.TK_DO:
      {
        /* stat -> DO block END */
        llex.luaX_next(ls);
        /* skip DO */

        block(ls);
        check_match(ls, R.TK_END, R.TK_DO, line);
        break;
      }

    case R.TK_FOR:
      {
        /* stat -> forstat */
        forstat(ls, line);
        break;
      }

    case R.TK_REPEAT:
      {
        /* stat -> repeatstat */
        repeatstat(ls, line);
        break;
      }

    case R.TK_FUNCTION:
      {
        /* stat -> funcstat */
        funcstat(ls, line);
        break;
      }

    case R.TK_LOCAL:
      {
        /* stat -> localstat */
        llex.luaX_next(ls);
        /* skip LOCAL */

        if (testnext(ls, R.TK_FUNCTION))
          /* local function? */
          localfunc(ls);else localstat(ls);
        break;
      }

    case R.TK_DBCOLON:
      {
        /* stat -> label */
        llex.luaX_next(ls);
        /* skip double colon */

        labelstat(ls, str_checkname(ls), line);
        break;
      }

    case R.TK_RETURN:
      {
        /* skip double colon */
        llex.luaX_next(ls);
        /* skip RETURN */

        retstat(ls);
        break;
      }

    case R.TK_BREAK:
    /* stat -> breakstat */

    case R.TK_GOTO:
      {
        /* stat -> 'goto' NAME */
        gotostat(ls, luaK_jump(ls.fs));
        break;
      }

    default:
      {
        /* stat -> func | assignment */
        exprstat(ls);
        break;
      }
  }

  lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg && ls.fs.freereg >= ls.fs.nactvar);
  ls.fs.freereg = ls.fs.nactvar;
  /* free registers */

  leavelevel(ls);
};
/*
** compiles the main function, which is a regular vararg function with an
** upvalue named LUA_ENV
*/


const mainfunc = function (ls, fs) {
  let bl = new BlockCnt();
  let v = new expdesc();
  open_func(ls, fs, bl);
  fs.f.is_vararg = true;
  /* main function is always declared vararg */

  init_exp(v, expkind.VLOCAL, 0);
  /* create and... */

  newupvalue(fs, ls.envn, v);
  /* ...set environment upvalue */

  llex.luaX_next(ls);
  /* read first token */

  statlist(ls);
  /* parse main body */

  check(ls, R.TK_EOS);
  close_func(ls);
};

const luaY_parser = function (L, z, buff, dyd, name, firstchar) {
  let lexstate = new llex.LexState();
  let funcstate = new FuncState();
  let cl = lfunc.luaF_newLclosure(L, 1);
  /* create main closure */

  ldo.luaD_inctop(L);
  L.stack[L.top - 1].setclLvalue(cl);
  lexstate.h = ltable.luaH_new(L);
  /* create table for scanner */

  ldo.luaD_inctop(L);
  L.stack[L.top - 1].sethvalue(lexstate.h);
  funcstate.f = cl.p = new Proto(L);
  funcstate.f.source = luaS_new(L, name);
  lexstate.buff = buff;
  lexstate.dyd = dyd;
  dyd.actvar.n = dyd.gt.n = dyd.label.n = 0;
  llex.luaX_setinput(L, lexstate, z, funcstate.f.source, firstchar);
  mainfunc(lexstate, funcstate);
  lua_assert(!funcstate.prev && funcstate.nups === 1 && !lexstate.fs);
  /* all scopes should be correctly finished */

  lua_assert(dyd.actvar.n === 0 && dyd.gt.n === 0 && dyd.label.n === 0);
  delete L.stack[--L.top];
  /* remove scanner's table */

  return cl;
  /* closure is on the stack, too */
};

module.exports.Dyndata = Dyndata;
module.exports.expkind = expkind;
module.exports.expdesc = expdesc;
module.exports.luaY_parser = luaY_parser;
module.exports.vkisinreg = vkisinreg;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MULTRET,
  LUA_OK,
  LUA_TFUNCTION,
  LUA_TNIL,
  LUA_TNONE,
  LUA_TNUMBER,
  LUA_TSTRING,
  LUA_TTABLE,
  LUA_VERSION,
  LUA_YIELD,
  lua_call,
  lua_callk,
  lua_concat,
  lua_error,
  lua_getglobal,
  lua_geti,
  lua_getmetatable,
  lua_gettop,
  lua_insert,
  lua_isnil,
  lua_isnone,
  lua_isstring,
  lua_load,
  lua_next,
  lua_pcallk,
  lua_pop,
  lua_pushboolean,
  lua_pushcfunction,
  lua_pushglobaltable,
  lua_pushinteger,
  lua_pushliteral,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_rawequal,
  lua_rawget,
  lua_rawlen,
  lua_rawset,
  lua_remove,
  lua_replace,
  lua_rotate,
  lua_setfield,
  lua_setmetatable,
  lua_settop,
  lua_setupvalue,
  lua_stringtonumber,
  lua_toboolean,
  lua_tolstring,
  lua_tostring,
  lua_type,
  lua_typename
} = __webpack_require__(2);

const {
  luaL_argcheck,
  luaL_checkany,
  luaL_checkinteger,
  luaL_checkoption,
  luaL_checkstack,
  luaL_checktype,
  luaL_error,
  luaL_getmetafield,
  luaL_loadbufferx,
  luaL_loadfile,
  luaL_loadfilex,
  luaL_optinteger,
  luaL_optstring,
  luaL_setfuncs,
  luaL_tolstring,
  luaL_where
} = __webpack_require__(8);

const {
  to_jsstring,
  to_luastring
} = __webpack_require__(6);

let lua_writestring;
let lua_writeline;

if (true) {
  if (typeof TextDecoder === "function") {
    /* Older browsers don't have TextDecoder */
    let buff = "";
    let decoder = new TextDecoder("utf-8");

    lua_writestring = function (s) {
      buff += decoder.decode(s, {
        stream: true
      });
    };

    let empty = new Uint8Array(0);

    lua_writeline = function () {
      buff += decoder.decode(empty);
      console.log(buff);
      buff = "";
    };
  } else {
    let buff = [];

    lua_writestring = function (s) {
      try {
        /* If the string is valid utf8, then we can use to_jsstring */
        s = to_jsstring(s);
      } catch (e) {
        /* otherwise push copy of raw array */
        let copy = new Uint8Array(s.length);
        copy.set(s);
        s = copy;
      }

      buff.push(s);
    };

    lua_writeline = function () {
      console.log.apply(console.log, buff);
      buff = [];
    };
  }
} else {}

const luaB_print = function (L) {
  let n = lua_gettop(L);
  /* number of arguments */

  lua_getglobal(L, to_luastring("tostring", true));

  for (let i = 1; i <= n; i++) {
    lua_pushvalue(L, -1);
    /* function to be called */

    lua_pushvalue(L, i);
    /* value to print */

    lua_call(L, 1, 1);
    let s = lua_tolstring(L, -1);
    if (s === null) return luaL_error(L, to_luastring("'tostring' must return a string to 'print'"));
    if (i > 1) lua_writestring(to_luastring("\t"));
    lua_writestring(s);
    lua_pop(L, 1);
  }

  lua_writeline();
  return 0;
};

const luaB_tostring = function (L) {
  luaL_checkany(L, 1);
  luaL_tolstring(L, 1);
  return 1;
};

const luaB_getmetatable = function (L) {
  luaL_checkany(L, 1);

  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;
    /* no metatable */
  }

  luaL_getmetafield(L, 1, to_luastring("__metatable", true));
  return 1;
  /* returns either __metatable field (if present) or metatable */
};

const luaB_setmetatable = function (L) {
  let t = lua_type(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_argcheck(L, t === LUA_TNIL || t === LUA_TTABLE, 2, "nil or table expected");
  if (luaL_getmetafield(L, 1, to_luastring("__metatable", true)) !== LUA_TNIL) return luaL_error(L, to_luastring("cannot change a protected metatable"));
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
};

const luaB_rawequal = function (L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
};

const luaB_rawlen = function (L) {
  let t = lua_type(L, 1);
  luaL_argcheck(L, t === LUA_TTABLE || t === LUA_TSTRING, 1, "table or string expected");
  lua_pushinteger(L, lua_rawlen(L, 1));
  return 1;
};

const luaB_rawget = function (L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
};

const luaB_rawset = function (L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
};

const opts = ["stop", "restart", "collect", "count", "step", "setpause", "setstepmul", "isrunning"].map(e => to_luastring(e));

const luaB_collectgarbage = function (L) {
  luaL_checkoption(L, 1, "collect", opts);
  luaL_optinteger(L, 2, 0);
  luaL_error(L, to_luastring("lua_gc not implemented"));
};

const luaB_type = function (L) {
  let t = lua_type(L, 1);
  luaL_argcheck(L, t !== LUA_TNONE, 1, "value expected");
  lua_pushstring(L, lua_typename(L, t));
  return 1;
};

const pairsmeta = function (L, method, iszero, iter) {
  luaL_checkany(L, 1);

  if (luaL_getmetafield(L, 1, method) === LUA_TNIL) {
    /* no metamethod? */
    lua_pushcfunction(L, iter);
    /* will return generator, */

    lua_pushvalue(L, 1);
    /* state, */

    if (iszero) lua_pushinteger(L, 0);
    /* and initial value */
    else lua_pushnil(L);
  } else {
    lua_pushvalue(L, 1);
    /* argument 'self' to metamethod */

    lua_call(L, 1, 3);
    /* get 3 values from metamethod */
  }

  return 3;
};

const luaB_next = function (L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_settop(L, 2);
  /* create a 2nd argument if there isn't one */

  if (lua_next(L, 1)) return 2;else {
    lua_pushnil(L);
    return 1;
  }
};

const luaB_pairs = function (L) {
  return pairsmeta(L, to_luastring("__pairs", true), 0, luaB_next);
};
/*
** Traversal function for 'ipairs'
*/


const ipairsaux = function (L) {
  let i = luaL_checkinteger(L, 2) + 1;
  lua_pushinteger(L, i);
  return lua_geti(L, 1, i) === LUA_TNIL ? 1 : 2;
};
/*
** 'ipairs' function. Returns 'ipairsaux', given "table", 0.
** (The given "table" may not be a table.)
*/


const luaB_ipairs = function (L) {
  // Lua 5.2
  // return pairsmeta(L, "__ipairs", 1, ipairsaux);
  luaL_checkany(L, 1);
  lua_pushcfunction(L, ipairsaux);
  /* iteration function */

  lua_pushvalue(L, 1);
  /* state */

  lua_pushinteger(L, 0);
  /* initial value */

  return 3;
};

const b_str2int = function (s, base) {
  try {
    s = to_jsstring(s);
  } catch (e) {
    return null;
  }

  let r = /^[\t\v\f \n\r]*([+-]?)0*([0-9A-Za-z]+)[\t\v\f \n\r]*$/.exec(s);
  if (!r) return null;
  let v = parseInt(r[1] + r[2], base);
  if (isNaN(v)) return null;
  return v | 0;
};

const luaB_tonumber = function (L) {
  if (lua_type(L, 2) <= 0) {
    /* standard conversion? */
    luaL_checkany(L, 1);

    if (lua_type(L, 1) === LUA_TNUMBER) {
      /* already a number? */
      lua_settop(L, 1);
      return 1;
    } else {
      let s = lua_tostring(L, 1);
      if (s !== null && lua_stringtonumber(L, s) === s.length + 1) return 1;
      /* successful conversion to number */
    }
  } else {
    let base = luaL_checkinteger(L, 2);
    luaL_checktype(L, 1, LUA_TSTRING);
    /* no numbers as strings */

    let s = lua_tostring(L, 1);
    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
    let n = b_str2int(s, base);

    if (n !== null) {
      lua_pushinteger(L, n);
      return 1;
    }
  }

  lua_pushnil(L);
  return 1;
};

const luaB_error = function (L) {
  let level = luaL_optinteger(L, 2, 1);
  lua_settop(L, 1);

  if (lua_type(L, 1) === LUA_TSTRING && level > 0) {
    luaL_where(L, level);
    /* add extra information */

    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }

  return lua_error(L);
};

const luaB_assert = function (L) {
  if (lua_toboolean(L, 1))
    /* condition is true? */
    return lua_gettop(L);
    /* return all arguments */
  else {
      luaL_checkany(L, 1);
      /* there must be a condition */

      lua_remove(L, 1);
      /* remove it */

      lua_pushliteral(L, "assertion failed!");
      /* default message */

      lua_settop(L, 1);
      /* leave only message (default if no other one) */

      return luaB_error(L);
      /* call 'error' */
    }
};

const luaB_select = function (L) {
  let n = lua_gettop(L);

  if (lua_type(L, 1) === LUA_TSTRING && lua_tostring(L, 1)[0] === 35
  /* '#'.charCodeAt(0) */
  ) {
      lua_pushinteger(L, n - 1);
      return 1;
    } else {
    let i = luaL_checkinteger(L, 1);
    if (i < 0) i = n + i;else if (i > n) i = n;
    luaL_argcheck(L, 1 <= i, 1, "index out of range");
    return n - i;
  }
};
/*
** Continuation function for 'pcall' and 'xpcall'. Both functions
** already pushed a 'true' before doing the call, so in case of success
** 'finishpcall' only has to return everything in the stack minus
** 'extra' values (where 'extra' is exactly the number of items to be
** ignored).
*/


const finishpcall = function (L, status, extra) {
  if (status !== LUA_OK && status !== LUA_YIELD) {
    /* error? */
    lua_pushboolean(L, 0);
    /* first result (false) */

    lua_pushvalue(L, -2);
    /* error message */

    return 2;
    /* return false, msg */
  } else return lua_gettop(L) - extra;
};

const luaB_pcall = function (L) {
  luaL_checkany(L, 1);
  lua_pushboolean(L, 1);
  /* first result if no errors */

  lua_insert(L, 1);
  /* put it in place */

  let status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);
  return finishpcall(L, status, 0);
};
/*
** Do a protected call with error handling. After 'lua_rotate', the
** stack will have <f, err, true, f, [args...]>; so, the function passes
** 2 to 'finishpcall' to skip the 2 first values when returning results.
*/


const luaB_xpcall = function (L) {
  let n = lua_gettop(L);
  luaL_checktype(L, 2, LUA_TFUNCTION);
  /* check error function */

  lua_pushboolean(L, 1);
  /* first result */

  lua_pushvalue(L, 1);
  /* function */

  lua_rotate(L, 3, 2);
  /* move them below function's arguments */

  let status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);
  return finishpcall(L, status, 2);
};

const load_aux = function (L, status, envidx) {
  if (status === LUA_OK) {
    if (envidx !== 0) {
      /* 'env' parameter? */
      lua_pushvalue(L, envidx);
      /* environment for loaded function */

      if (!lua_setupvalue(L, -2, 1))
        /* set it as 1st upvalue */
        lua_pop(L, 1);
      /* remove 'env' if not used by previous call */
    }

    return 1;
  } else {
    /* error (message is on top of the stack) */
    lua_pushnil(L);
    lua_insert(L, -2);
    /* put before error message */

    return 2;
    /* return nil plus error message */
  }
};
/*
** reserved slot, above all arguments, to hold a copy of the returned
** string to avoid it being collected while parsed. 'load' has four
** optional arguments (chunk, source name, mode, and environment).
*/


const RESERVEDSLOT = 5;
/*
** Reader for generic 'load' function: 'lua_load' uses the
** stack for internal stuff, so the reader cannot change the
** stack top. Instead, it keeps its resulting string in a
** reserved slot inside the stack.
*/

const generic_reader = function (L, ud) {
  luaL_checkstack(L, 2, "too many nested functions");
  lua_pushvalue(L, 1);
  /* get function */

  lua_call(L, 0, 1);
  /* call it */

  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);
    /* pop result */

    return null;
  } else if (!lua_isstring(L, -1)) luaL_error(L, to_luastring("reader function must return a string"));

  lua_replace(L, RESERVEDSLOT);
  /* save string in reserved slot */

  return lua_tostring(L, RESERVEDSLOT);
};

const luaB_load = function (L) {
  let s = lua_tostring(L, 1);
  let mode = luaL_optstring(L, 3, "bt");
  let env = !lua_isnone(L, 4) ? 4 : 0;
  /* 'env' index or 0 if no 'env' */

  let status;

  if (s !== null) {
    /* loading a string? */
    let chunkname = luaL_optstring(L, 2, s);
    status = luaL_loadbufferx(L, s, s.length, chunkname, mode);
  } else {
    /* loading from a reader function */
    let chunkname = luaL_optstring(L, 2, "=(load)");
    luaL_checktype(L, 1, LUA_TFUNCTION);
    lua_settop(L, RESERVEDSLOT);
    /* create reserved slot */

    status = lua_load(L, generic_reader, null, chunkname, mode);
  }

  return load_aux(L, status, env);
};

const luaB_loadfile = function (L) {
  let fname = luaL_optstring(L, 1, null);
  let mode = luaL_optstring(L, 2, null);
  let env = !lua_isnone(L, 3) ? 3 : 0;
  /* 'env' index or 0 if no 'env' */

  let status = luaL_loadfilex(L, fname, mode);
  return load_aux(L, status, env);
};

const dofilecont = function (L, d1, d2) {
  return lua_gettop(L) - 1;
};

const luaB_dofile = function (L) {
  let fname = luaL_optstring(L, 1, null);
  lua_settop(L, 1);
  if (luaL_loadfile(L, fname) !== LUA_OK) return lua_error(L);
  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
  return dofilecont(L, 0, 0);
};

const base_funcs = {
  "assert": luaB_assert,
  "collectgarbage": luaB_collectgarbage,
  "dofile": luaB_dofile,
  "error": luaB_error,
  "getmetatable": luaB_getmetatable,
  "ipairs": luaB_ipairs,
  "load": luaB_load,
  "loadfile": luaB_loadfile,
  "next": luaB_next,
  "pairs": luaB_pairs,
  "pcall": luaB_pcall,
  "print": luaB_print,
  "rawequal": luaB_rawequal,
  "rawget": luaB_rawget,
  "rawlen": luaB_rawlen,
  "rawset": luaB_rawset,
  "select": luaB_select,
  "setmetatable": luaB_setmetatable,
  "tonumber": luaB_tonumber,
  "tostring": luaB_tostring,
  "type": luaB_type,
  "xpcall": luaB_xpcall
};

const luaopen_base = function (L) {
  /* open lib into global table */
  lua_pushglobaltable(L);
  luaL_setfuncs(L, base_funcs, 0);
  /* set global _G */

  lua_pushvalue(L, -1);
  lua_setfield(L, -2, to_luastring("_G"));
  /* set global _VERSION */

  lua_pushliteral(L, LUA_VERSION);
  lua_setfield(L, -2, to_luastring("_VERSION"));
  return 1;
};

module.exports.luaopen_base = luaopen_base;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_OK,
  LUA_TFUNCTION,
  LUA_TSTRING,
  LUA_YIELD,
  lua_Debug,
  lua_checkstack,
  lua_concat,
  lua_error,
  lua_getstack,
  lua_gettop,
  lua_insert,
  lua_isyieldable,
  lua_newthread,
  lua_pop,
  lua_pushboolean,
  lua_pushcclosure,
  lua_pushliteral,
  lua_pushthread,
  lua_pushvalue,
  lua_resume,
  lua_status,
  lua_tothread,
  lua_type,
  lua_upvalueindex,
  lua_xmove,
  lua_yield
} = __webpack_require__(2);

const {
  luaL_argcheck,
  luaL_checktype,
  luaL_newlib,
  luaL_where
} = __webpack_require__(8);

const getco = function (L) {
  let co = lua_tothread(L, 1);
  luaL_argcheck(L, co, 1, "thread expected");
  return co;
};

const auxresume = function (L, co, narg) {
  if (!lua_checkstack(co, narg)) {
    lua_pushliteral(L, "too many arguments to resume");
    return -1;
    /* error flag */
  }

  if (lua_status(co) === LUA_OK && lua_gettop(co) === 0) {
    lua_pushliteral(L, "cannot resume dead coroutine");
    return -1;
    /* error flag */
  }

  lua_xmove(L, co, narg);
  let status = lua_resume(co, L, narg);

  if (status === LUA_OK || status === LUA_YIELD) {
    let nres = lua_gettop(co);

    if (!lua_checkstack(L, nres + 1)) {
      lua_pop(co, nres);
      /* remove results anyway */

      lua_pushliteral(L, "too many results to resume");
      return -1;
      /* error flag */
    }

    lua_xmove(co, L, nres);
    /* move yielded values */

    return nres;
  } else {
    lua_xmove(co, L, 1);
    /* move error message */

    return -1;
    /* error flag */
  }
};

const luaB_coresume = function (L) {
  let co = getco(L);
  let r = auxresume(L, co, lua_gettop(L) - 1);

  if (r < 0) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;
    /* return false + error message */
  } else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;
    /* return true + 'resume' returns */
  }
};

const luaB_auxwrap = function (L) {
  let co = lua_tothread(L, lua_upvalueindex(1));
  let r = auxresume(L, co, lua_gettop(L));

  if (r < 0) {
    if (lua_type(L, -1) === LUA_TSTRING) {
      /* error object is a string? */
      luaL_where(L, 1);
      /* add extra info */

      lua_insert(L, -2);
      lua_concat(L, 2);
    }

    return lua_error(L);
    /* propagate error */
  }

  return r;
};

const luaB_cocreate = function (L) {
  luaL_checktype(L, 1, LUA_TFUNCTION);
  let NL = lua_newthread(L);
  lua_pushvalue(L, 1);
  /* move function to top */

  lua_xmove(L, NL, 1);
  /* move function from L to NL */

  return 1;
};

const luaB_cowrap = function (L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
};

const luaB_yield = function (L) {
  return lua_yield(L, lua_gettop(L));
};

const luaB_costatus = function (L) {
  let co = getco(L);
  if (L === co) lua_pushliteral(L, "running");else {
    switch (lua_status(co)) {
      case LUA_YIELD:
        lua_pushliteral(L, "suspended");
        break;

      case LUA_OK:
        {
          let ar = new lua_Debug();
          if (lua_getstack(co, 0, ar) > 0)
            /* does it have frames? */
            lua_pushliteral(L, "normal");
            /* it is running */
          else if (lua_gettop(co) === 0) lua_pushliteral(L, "dead");else lua_pushliteral(L, "suspended");
          /* initial state */

          break;
        }

      default:
        /* some error occurred */
        lua_pushliteral(L, "dead");
        break;
    }
  }
  return 1;
};

const luaB_yieldable = function (L) {
  lua_pushboolean(L, lua_isyieldable(L));
  return 1;
};

const luaB_corunning = function (L) {
  lua_pushboolean(L, lua_pushthread(L));
  return 2;
};

const co_funcs = {
  "create": luaB_cocreate,
  "isyieldable": luaB_yieldable,
  "resume": luaB_coresume,
  "running": luaB_corunning,
  "status": luaB_costatus,
  "wrap": luaB_cowrap,
  "yield": luaB_yield
};

const luaopen_coroutine = function (L) {
  luaL_newlib(L, co_funcs);
  return 1;
};

module.exports.luaopen_coroutine = luaopen_coroutine;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MAXINTEGER
} = __webpack_require__(4);

const {
  LUA_OPEQ,
  LUA_OPLT,
  LUA_TFUNCTION,
  LUA_TNIL,
  LUA_TTABLE,
  lua_call,
  lua_checkstack,
  lua_compare,
  lua_createtable,
  lua_geti,
  lua_getmetatable,
  lua_gettop,
  lua_insert,
  lua_isnil,
  lua_isnoneornil,
  lua_isstring,
  lua_pop,
  lua_pushinteger,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_rawget,
  lua_setfield,
  lua_seti,
  lua_settop,
  lua_toboolean,
  lua_type
} = __webpack_require__(2);

const {
  luaL_Buffer,
  luaL_addlstring,
  luaL_addvalue,
  luaL_argcheck,
  luaL_buffinit,
  luaL_checkinteger,
  luaL_checktype,
  luaL_error,
  luaL_len,
  luaL_newlib,
  luaL_opt,
  luaL_optinteger,
  luaL_optlstring,
  luaL_pushresult,
  luaL_typename
} = __webpack_require__(8);

const lualib = __webpack_require__(18);

const {
  to_luastring
} = __webpack_require__(6);
/*
** Operations that an object must define to mimic a table
** (some functions only need some of them)
*/


const TAB_R = 1;
/* read */

const TAB_W = 2;
/* write */

const TAB_L = 4;
/* length */

const TAB_RW = TAB_R | TAB_W;
/* read/write */

const checkfield = function (L, key, n) {
  lua_pushstring(L, key);
  return lua_rawget(L, -n) !== LUA_TNIL;
};
/*
** Check that 'arg' either is a table or can behave like one (that is,
** has a metatable with the required metamethods)
*/


const checktab = function (L, arg, what) {
  if (lua_type(L, arg) !== LUA_TTABLE) {
    /* is it not a table? */
    let n = 1;

    if (lua_getmetatable(L, arg) && (
    /* must have metatable */
    !(what & TAB_R) || checkfield(L, to_luastring("__index", true), ++n)) && (!(what & TAB_W) || checkfield(L, to_luastring("__newindex", true), ++n)) && (!(what & TAB_L) || checkfield(L, to_luastring("__len", true), ++n))) {
      lua_pop(L, n);
      /* pop metatable and tested metamethods */
    } else luaL_checktype(L, arg, LUA_TTABLE);
    /* force an error */

  }
};

const aux_getn = function (L, n, w) {
  checktab(L, n, w | TAB_L);
  return luaL_len(L, n);
};

const addfield = function (L, b, i) {
  lua_geti(L, 1, i);
  if (!lua_isstring(L, -1)) luaL_error(L, to_luastring("invalid value (%s) at index %d in table for 'concat'"), luaL_typename(L, -1), i);
  luaL_addvalue(b);
};

const tinsert = function (L) {
  let e = aux_getn(L, 1, TAB_RW) + 1;
  /* first empty element */

  let pos;

  switch (lua_gettop(L)) {
    case 2:
      pos = e;
      break;

    case 3:
      {
        pos = luaL_checkinteger(L, 2);
        /* 2nd argument is the position */

        luaL_argcheck(L, 1 <= pos && pos <= e, 2, "position out of bounds");

        for (let i = e; i > pos; i--) {
          /* move up elements */
          lua_geti(L, 1, i - 1);
          lua_seti(L, 1, i);
          /* t[i] = t[i - 1] */
        }

        break;
      }

    default:
      {
        return luaL_error(L, "wrong number of arguments to 'insert'");
      }
  }

  lua_seti(L, 1, pos);
  /* t[pos] = v */

  return 0;
};

const tremove = function (L) {
  let size = aux_getn(L, 1, TAB_RW);
  let pos = luaL_optinteger(L, 2, size);
  if (pos !== size)
    /* validate 'pos' if given */
    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, "position out of bounds");
  lua_geti(L, 1, pos);
  /* result = t[pos] */

  for (; pos < size; pos++) {
    lua_geti(L, 1, pos + 1);
    lua_seti(L, 1, pos);
    /* t[pos] = t[pos + 1] */
  }

  lua_pushnil(L);
  lua_seti(L, 1, pos);
  /* t[pos] = nil */

  return 1;
};
/*
** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever
** possible, copy in increasing order, which is better for rehashing.
** "possible" means destination after original range, or smaller
** than origin, or copying to another table.
*/


const tmove = function (L) {
  let f = luaL_checkinteger(L, 2);
  let e = luaL_checkinteger(L, 3);
  let t = luaL_checkinteger(L, 4);
  let tt = !lua_isnoneornil(L, 5) ? 5 : 1;
  /* destination table */

  checktab(L, 1, TAB_R);
  checktab(L, tt, TAB_W);

  if (e >= f) {
    /* otherwise, nothing to move */
    luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3, "too many elements to move");
    let n = e - f + 1;
    /* number of elements to move */

    luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4, "destination wrap around");

    if (t > e || t <= f || tt !== 1 && lua_compare(L, 1, tt, LUA_OPEQ) !== 1) {
      for (let i = 0; i < n; i++) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    } else {
      for (let i = n - 1; i >= 0; i--) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    }
  }

  lua_pushvalue(L, tt);
  /* return destination table */

  return 1;
};

const tconcat = function (L) {
  let last = aux_getn(L, 1, TAB_R);
  let sep = luaL_optlstring(L, 2, "");
  let lsep = sep.length;
  let i = luaL_optinteger(L, 3, 1);
  last = luaL_optinteger(L, 4, last);
  let b = new luaL_Buffer();
  luaL_buffinit(L, b);

  for (; i < last; i++) {
    addfield(L, b, i);
    luaL_addlstring(b, sep, lsep);
  }

  if (i === last) addfield(L, b, i);
  luaL_pushresult(b);
  return 1;
};

const pack = function (L) {
  let n = lua_gettop(L);
  /* number of elements to pack */

  lua_createtable(L, n, 1);
  /* create result table */

  lua_insert(L, 1);
  /* put it at index 1 */

  for (let i = n; i >= 1; i--)
  /* assign elements */
  lua_seti(L, 1, i);

  lua_pushinteger(L, n);
  lua_setfield(L, 1, to_luastring("n"));
  /* t.n = number of elements */

  return 1;
  /* return table */
};

const unpack = function (L) {
  let i = luaL_optinteger(L, 2, 1);
  let e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));
  if (i > e) return 0;
  /* empty range */

  let n = e - i;
  /* number of elements minus 1 (avoid overflows) */

  if (n >= Number.MAX_SAFE_INTEGER || !lua_checkstack(L, ++n)) return luaL_error(L, to_luastring("too many results to unpack"));

  for (; i < e; i++)
  /* push arg[i..e - 1] (to avoid overflows) */
  lua_geti(L, 1, i);

  lua_geti(L, 1, e);
  /* push last element */

  return n;
};

const l_randomizePivot = function () {
  return Math.floor(Math.random() * 0x100000000);
};

const RANLIMIT = 100;

const set2 = function (L, i, j) {
  lua_seti(L, 1, i);
  lua_seti(L, 1, j);
};

const sort_comp = function (L, a, b) {
  if (lua_isnil(L, 2))
    /* no function? */
    return lua_compare(L, a, b, LUA_OPLT);
    /* a < b */
  else {
      /* function */
      lua_pushvalue(L, 2);
      /* push function */

      lua_pushvalue(L, a - 1);
      /* -1 to compensate function */

      lua_pushvalue(L, b - 2);
      /* -2 to compensate function and 'a' */

      lua_call(L, 2, 1);
      /* call function */

      let res = lua_toboolean(L, -1);
      /* get result */

      lua_pop(L, 1);
      /* pop result */

      return res;
    }
};

const partition = function (L, lo, up) {
  let i = lo;
  /* will be incremented before first use */

  let j = up - 1;
  /* will be decremented before first use */

  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */

  for (;;) {
    /* next loop: repeat ++i while a[i] < P */
    while (lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {
      if (i == up - 1)
        /* a[i] < P  but a[up - 1] == P  ?? */
        luaL_error(L, to_luastring("invalid order function for sorting"));
      lua_pop(L, 1);
      /* remove a[i] */
    }
    /* after the loop, a[i] >= P and a[lo .. i - 1] < P */

    /* next loop: repeat --j while P < a[j] */


    while (lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {
      if (j < i)
        /* j < i  but  a[j] > P ?? */
        luaL_error(L, to_luastring("invalid order function for sorting"));
      lua_pop(L, 1);
      /* remove a[j] */
    }
    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */


    if (j < i) {
      /* no elements out of place? */

      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */
      lua_pop(L, 1);
      /* pop a[j] */

      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */

      set2(L, up - 1, i);
      return i;
    }
    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */


    set2(L, i, j);
  }
};

const choosePivot = function (lo, up, rnd) {
  let r4 = Math.floor((up - lo) / 4);
  /* range/4 */

  let p = rnd % (r4 * 2) + (lo + r4);
  lualib.lua_assert(lo + r4 <= p && p <= up - r4);
  return p;
};

const auxsort = function (L, lo, up, rnd) {
  while (lo < up) {
    /* loop for tail recursion */

    /* sort elements 'lo', 'p', and 'up' */
    lua_geti(L, 1, lo);
    lua_geti(L, 1, up);
    if (sort_comp(L, -1, -2))
      /* a[up] < a[lo]? */
      set2(L, lo, up);
      /* swap a[lo] - a[up] */
    else lua_pop(L, 2);
    /* remove both values */

    if (up - lo == 1)
      /* only 2 elements? */
      return;
    /* already sorted */

    let p;
    /* Pivot index */

    if (up - lo < RANLIMIT || rnd === 0)
      /* small interval or no randomize? */
      p = Math.floor((lo + up) / 2);
      /* middle element is a good pivot */
    else
      /* for larger intervals, it is worth a random pivot */
      p = choosePivot(lo, up, rnd);
    lua_geti(L, 1, p);
    lua_geti(L, 1, lo);
    if (sort_comp(L, -2, -1))
      /* a[p] < a[lo]? */
      set2(L, p, lo);
      /* swap a[p] - a[lo] */
    else {
        lua_pop(L, 1);
        /* remove a[lo] */

        lua_geti(L, 1, up);
        if (sort_comp(L, -1, -2))
          /* a[up] < a[p]? */
          set2(L, p, up);
          /* swap a[up] - a[p] */
        else lua_pop(L, 2);
      }
    if (up - lo == 2)
      /* only 3 elements? */
      return;
    /* already sorted */

    lua_geti(L, 1, p);
    /* get middle element (Pivot) */

    lua_pushvalue(L, -1);
    /* push Pivot */

    lua_geti(L, 1, up - 1);
    /* push a[up - 1] */

    set2(L, p, up - 1);
    /* swap Pivot (a[p]) with a[up - 1] */

    p = partition(L, lo, up);
    let n;
    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */

    if (p - lo < up - p) {
      /* lower interval is smaller? */
      auxsort(L, lo, p - 1, rnd);
      /* call recursively for lower interval */

      n = p - lo;
      /* size of smaller interval */

      lo = p + 1;
      /* tail call for [p + 1 .. up] (upper interval) */
    } else {
      auxsort(L, p + 1, up, rnd);
      /* call recursively for upper interval */

      n = up - p;
      /* size of smaller interval */

      up = p - 1;
      /* tail call for [lo .. p - 1]  (lower interval) */
    }

    if ((up - lo) / 128 > n)
      /* partition too imbalanced? */
      rnd = l_randomizePivot();
    /* try a new randomization */
  }
  /* tail call auxsort(L, lo, up, rnd) */

};

const sort = function (L) {
  let n = aux_getn(L, 1, TAB_RW);

  if (n > 1) {
    /* non-trivial interval? */
    luaL_argcheck(L, n < LUA_MAXINTEGER, 1, "array too big");
    if (!lua_isnoneornil(L, 2))
      /* is there a 2nd argument? */
      luaL_checktype(L, 2, LUA_TFUNCTION);
    /* must be a function */

    lua_settop(L, 2);
    /* make sure there are two arguments */

    auxsort(L, 1, n, 0);
  }

  return 0;
};

const tab_funcs = {
  "concat": tconcat,
  "insert": tinsert,
  "move": tmove,
  "pack": pack,
  "remove": tremove,
  "sort": sort,
  "unpack": unpack
};

const luaopen_table = function (L) {
  luaL_newlib(L, tab_funcs);
  return 1;
};

module.exports.luaopen_table = luaopen_table;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_TNIL,
  LUA_TTABLE,
  lua_close,
  lua_createtable,
  lua_getfield,
  lua_isboolean,
  lua_isnoneornil,
  lua_pop,
  lua_pushboolean,
  lua_pushfstring,
  lua_pushinteger,
  lua_pushliteral,
  lua_pushnil,
  lua_pushnumber,
  lua_pushstring,
  lua_setfield,
  lua_settop,
  lua_toboolean,
  lua_tointegerx
} = __webpack_require__(2);

const {
  luaL_Buffer,
  luaL_addchar,
  luaL_addstring,
  // luaL_argcheck,
  luaL_argerror,
  luaL_buffinit,
  luaL_checkinteger,
  luaL_checkstring,
  luaL_checktype,
  luaL_error,
  luaL_execresult,
  luaL_fileresult,
  luaL_newlib,
  luaL_optinteger,
  luaL_optlstring,
  luaL_optstring,
  luaL_pushresult
} = __webpack_require__(8);

const {
  luastring_eq,
  to_jsstring,
  to_luastring
} = __webpack_require__(6);
/* options for ANSI C 89 (only 1-char options) */
// const L_STRFTIMEC89 = to_luastring("aAbBcdHIjmMpSUwWxXyYZ%");
// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC89;

/* options for ISO C 99 and POSIX */
// const L_STRFTIMEC99 = to_luastring("aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy");  /* two-char options */
// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC99;

/* options for Windows */
// const L_STRFTIMEWIN = to_luastring("aAbBcdHIjmMpSUwWxXyYzZ%||#c#x#d#H#I#j#m#M#S#U#w#W#y#Y");  /* two-char options */
// const LUA_STRFTIMEOPTIONS = L_STRFTIMEWIN;

/* options for our own strftime implementation
  - should be superset of C89 options for compat
  - missing from C99:
      - ISO 8601 week specifiers: gGV
      - > single char specifiers
  - beyond C99:
      - %k: TZ extension: space-padded 24-hour
      - %l: TZ extension: space-padded 12-hour
      - %P: GNU extension: lower-case am/pm
*/


const LUA_STRFTIMEOPTIONS = to_luastring("aAbBcCdDeFhHIjklmMnpPrRStTuUwWxXyYzZ%");

const setfield = function (L, key, value) {
  lua_pushinteger(L, value);
  lua_setfield(L, -2, to_luastring(key, true));
};

const setallfields = function (L, time, utc) {
  setfield(L, "sec", utc ? time.getUTCSeconds() : time.getSeconds());
  setfield(L, "min", utc ? time.getUTCMinutes() : time.getMinutes());
  setfield(L, "hour", utc ? time.getUTCHours() : time.getHours());
  setfield(L, "day", utc ? time.getUTCDate() : time.getDate());
  setfield(L, "month", (utc ? time.getUTCMonth() : time.getMonth()) + 1);
  setfield(L, "year", utc ? time.getUTCFullYear() : time.getFullYear());
  setfield(L, "wday", (utc ? time.getUTCDay() : time.getDay()) + 1);
  setfield(L, "yday", Math.floor((time - new Date(time.getFullYear(), 0, 0
  /* shortcut to correct day by one */
  )) / 86400000)); // setboolfield(L, "isdst", time.get);
};

const L_MAXDATEFIELD = Number.MAX_SAFE_INTEGER / 2;

const getfield = function (L, key, d, delta) {
  let t = lua_getfield(L, -1, to_luastring(key, true));
  /* get field and its type */

  let res = lua_tointegerx(L, -1);

  if (res === false) {
    /* field is not an integer? */
    if (t !== LUA_TNIL)
      /* some other value? */
      return luaL_error(L, to_luastring("field '%s' is not an integer"), key);else if (d < 0)
      /* absent field; no default? */
      return luaL_error(L, to_luastring("field '%s' missing in date table"), key);
    res = d;
  } else {
    if (!(-L_MAXDATEFIELD <= res && res <= L_MAXDATEFIELD)) return luaL_error(L, to_luastring("field '%s' is out-of-bound"), key);
    res -= delta;
  }

  lua_pop(L, 1);
  return res;
};

const locale = {
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"].map(s => to_luastring(s)),
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map(s => to_luastring(s)),
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"].map(s => to_luastring(s)),
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"].map(s => to_luastring(s)),
  AM: to_luastring("AM"),
  PM: to_luastring("PM"),
  am: to_luastring("am"),
  pm: to_luastring("pm"),
  formats: {
    c: to_luastring("%a %b %e %H:%M:%S %Y"),
    D: to_luastring("%m/%d/%y"),
    F: to_luastring("%Y-%m-%d"),
    R: to_luastring("%H:%M"),
    r: to_luastring("%I:%M:%S %p"),
    T: to_luastring("%H:%M:%S"),
    X: to_luastring("%T"),
    x: to_luastring("%D")
  }
};

const week_number = function (date, start_of_week) {
  // This works by shifting the weekday back by one day if we
  // are treating Monday as the first day of the week.
  let weekday = date.getDay();

  if (start_of_week === 'monday') {
    if (weekday === 0) // Sunday
      weekday = 6;else weekday--;
  }

  let yday = (date - new Date(date.getFullYear(), 0, 1)) / 86400000;
  return Math.floor((yday + 7 - weekday) / 7);
};

const push_pad_2 = function (b, n, pad) {
  if (n < 10) luaL_addchar(b, pad);
  luaL_addstring(b, to_luastring(String(n)));
};

const strftime = function (L, b, s, date) {
  let i = 0;

  while (i < s.length) {
    if (s[i] !== 37
    /* % */
    ) {
        /* not a conversion specifier? */
        luaL_addchar(b, s[i++]);
      } else {
      i++;
      /* skip '%' */

      let len = checkoption(L, s, i);
      /* each `case` has an example output above it for the UTC epoch */

      switch (s[i]) {
        // '%'
        case 37
        /* % */
        :
          luaL_addchar(b, 37);
          break;
        // 'Thursday'

        case 65
        /* A */
        :
          luaL_addstring(b, locale.days[date.getDay()]);
          break;
        // 'January'

        case 66
        /* B */
        :
          luaL_addstring(b, locale.months[date.getMonth()]);
          break;
        // '19'

        case 67
        /* C */
        :
          push_pad_2(b, Math.floor(date.getFullYear() / 100), 48
          /* 0 */
          );
          break;
        // '01/01/70'

        case 68
        /* D */
        :
          strftime(L, b, locale.formats.D, date);
          break;
        // '1970-01-01'

        case 70
        /* F */
        :
          strftime(L, b, locale.formats.F, date);
          break;
        // '00'

        case 72
        /* H */
        :
          push_pad_2(b, date.getHours(), 48
          /* 0 */
          );
          break;
        // '12'

        case 73
        /* I */
        :
          push_pad_2(b, (date.getHours() + 11) % 12 + 1, 48
          /* 0 */
          );
          break;
        // '00'

        case 77
        /* M */
        :
          push_pad_2(b, date.getMinutes(), 48
          /* 0 */
          );
          break;
        // 'am'

        case 80
        /* P */
        :
          luaL_addstring(b, date.getHours() < 12 ? locale.am : locale.pm);
          break;
        // '00:00'

        case 82
        /* R */
        :
          strftime(L, b, locale.formats.R, date);
          break;
        // '00'

        case 83
        /* S */
        :
          push_pad_2(b, date.getSeconds(), 48
          /* 0 */
          );
          break;
        // '00:00:00'

        case 84
        /* T */
        :
          strftime(L, b, locale.formats.T, date);
          break;
        // '00'

        case 85
        /* U */
        :
          push_pad_2(b, week_number(date, "sunday"), 48
          /* 0 */
          );
          break;
        // '00'

        case 87
        /* W */
        :
          push_pad_2(b, week_number(date, "monday"), 48
          /* 0 */
          );
          break;
        // '16:00:00'

        case 88
        /* X */
        :
          strftime(L, b, locale.formats.X, date);
          break;
        // '1970'

        case 89
        /* Y */
        :
          luaL_addstring(b, to_luastring(String(date.getFullYear())));
          break;
        // 'GMT'

        case 90
        /* Z */
        :
          {
            let tzString = date.toString().match(/\(([\w\s]+)\)/);
            if (tzString) luaL_addstring(b, to_luastring(tzString[1]));
            break;
          }
        // 'Thu'

        case 97
        /* a */
        :
          luaL_addstring(b, locale.shortDays[date.getDay()]);
          break;
        // 'Jan'

        case 98
        /* b */
        :
        case 104
        /* h */
        :
          luaL_addstring(b, locale.shortMonths[date.getMonth()]);
          break;
        // ''

        case 99
        /* c */
        :
          strftime(L, b, locale.formats.c, date);
          break;
        // '01'

        case 100
        /* d */
        :
          push_pad_2(b, date.getDate(), 48
          /* 0 */
          );
          break;
        // ' 1'

        case 101
        /* e */
        :
          push_pad_2(b, date.getDate(), 32
          /* space */
          );
          break;
        // '000'

        case 106
        /* j */
        :
          {
            let yday = Math.floor((date - new Date(date.getFullYear(), 0, 1)) / 86400000);

            if (yday < 100) {
              if (yday < 10) luaL_addchar(b, 48
              /* 0 */
              );
              luaL_addchar(b, 48
              /* 0 */
              );
            }

            luaL_addstring(b, to_luastring(String(yday)));
            break;
          }
        // ' 0'

        case 107
        /* k */
        :
          push_pad_2(b, date.getHours(), 32
          /* space */
          );
          break;
        // '12'

        case 108
        /* l */
        :
          push_pad_2(b, (date.getHours() + 11) % 12 + 1, 32
          /* space */
          );
          break;
        // '01'

        case 109
        /* m */
        :
          push_pad_2(b, date.getMonth() + 1, 48
          /* 0 */
          );
          break;
        // '\n'

        case 110
        /* n */
        :
          luaL_addchar(b, 10);
          break;
        // 'AM'

        case 112
        /* p */
        :
          luaL_addstring(b, date.getHours() < 12 ? locale.AM : locale.PM);
          break;
        // '12:00:00 AM'

        case 114
        /* r */
        :
          strftime(L, b, locale.formats.r, date);
          break;
        // '0'

        case 115
        /* s */
        :
          luaL_addstring(b, to_luastring(String(Math.floor(date / 1000))));
          break;
        // '\t'

        case 116
        /* t */
        :
          luaL_addchar(b, 8);
          break;
        // '4'

        case 117
        /* u */
        :
          {
            let day = date.getDay();
            luaL_addstring(b, to_luastring(String(day === 0 ? 7 : day)));
            break;
          }
        // '4'

        case 119
        /* w */
        :
          luaL_addstring(b, to_luastring(String(date.getDay())));
          break;
        // '12/31/69'

        case 120
        /* x */
        :
          strftime(L, b, locale.formats.x, date);
          break;
        // '70'

        case 121
        /* y */
        :
          push_pad_2(b, date.getFullYear() % 100, 48
          /* 0 */
          );
          break;
        // '+0000'

        case 122
        /* z */
        :
          {
            let off = date.getTimezoneOffset();

            if (off > 0) {
              luaL_addchar(b, 45
              /* - */
              );
            } else {
              off = -off;
              luaL_addchar(b, 43
              /* + */
              );
            }

            push_pad_2(b, Math.floor(off / 60), 48
            /* 0 */
            );
            push_pad_2(b, off % 60, 48
            /* 0 */
            );
            break;
          }
      }

      i += len;
    }
  }
};

const checkoption = function (L, conv, i) {
  let option = LUA_STRFTIMEOPTIONS;
  let o = 0;
  let oplen = 1;
  /* length of options being checked */

  for (; o < option.length && oplen <= conv.length - i; o += oplen) {
    if (option[o] === '|'.charCodeAt(0))
      /* next block? */
      oplen++;
      /* will check options with next length (+1) */
    else if (luastring_eq(conv.subarray(i, i + oplen), option.subarray(o, o + oplen))) {
        /* match? */
        return oplen;
        /* return length */
      }
  }

  luaL_argerror(L, 1, lua_pushfstring(L, to_luastring("invalid conversion specifier '%%%s'"), conv));
};
/* maximum size for an individual 'strftime' item */
// const SIZETIMEFMT = 250;


const os_date = function (L) {
  let s = luaL_optlstring(L, 1, "%c");
  let stm = lua_isnoneornil(L, 2) ? new Date() : new Date(l_checktime(L, 2) * 1000);
  let utc = false;
  let i = 0;

  if (s[i] === '!'.charCodeAt(0)) {
    /* UTC? */
    utc = true;
    i++;
    /* skip '!' */
  }

  if (s[i] === "*".charCodeAt(0) && s[i + 1] === "t".charCodeAt(0)) {
    lua_createtable(L, 0, 9);
    /* 9 = number of fields */

    setallfields(L, stm, utc);
  } else {
    let cc = new Uint8Array(4);
    cc[0] = "%".charCodeAt(0);
    let b = new luaL_Buffer();
    luaL_buffinit(L, b);
    strftime(L, b, s, stm);
    luaL_pushresult(b);
  }

  return 1;
};

const os_time = function (L) {
  let t;
  if (lua_isnoneornil(L, 1))
    /* called without args? */
    t = new Date();
    /* get current time */
  else {
      luaL_checktype(L, 1, LUA_TTABLE);
      lua_settop(L, 1);
      /* make sure table is at the top */

      t = new Date(getfield(L, "year", -1, 0), getfield(L, "month", -1, 1), getfield(L, "day", -1, 0), getfield(L, "hour", 12, 0), getfield(L, "min", 0, 0), getfield(L, "sec", 0, 0));
      setallfields(L, t);
    }
  lua_pushinteger(L, Math.floor(t / 1000));
  return 1;
};

const l_checktime = function (L, arg) {
  let t = luaL_checkinteger(L, arg); // luaL_argcheck(L, t, arg, "time out-of-bounds");

  return t;
};

const os_difftime = function (L) {
  let t1 = l_checktime(L, 1);
  let t2 = l_checktime(L, 2);
  lua_pushnumber(L, t1 - t2);
  return 1;
};

const syslib = {
  "date": os_date,
  "difftime": os_difftime,
  "time": os_time
};

if (true) {
  syslib.clock = function (L) {
    lua_pushnumber(L, performance.now() / 1000);
    return 1;
  };
} else {}

const luaopen_os = function (L) {
  luaL_newlib(L, syslib);
  return 1;
};

module.exports.luaopen_os = luaopen_os;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  sprintf
} = __webpack_require__(67);

const {
  LUA_INTEGER_FMT,
  LUA_INTEGER_FRMLEN,
  LUA_MININTEGER,
  LUA_NUMBER_FMT,
  LUA_NUMBER_FRMLEN,
  frexp,
  lua_getlocaledecpoint
} = __webpack_require__(4);

const {
  LUA_TBOOLEAN,
  LUA_TFUNCTION,
  LUA_TNIL,
  LUA_TNUMBER,
  LUA_TSTRING,
  LUA_TTABLE,
  lua_call,
  lua_createtable,
  lua_dump,
  lua_gettable,
  lua_gettop,
  lua_isinteger,
  lua_isstring,
  lua_pop,
  lua_pushcclosure,
  lua_pushinteger,
  lua_pushlightuserdata,
  lua_pushliteral,
  lua_pushlstring,
  lua_pushnil,
  lua_pushnumber,
  lua_pushstring,
  lua_pushvalue,
  lua_remove,
  lua_setfield,
  lua_setmetatable,
  lua_settop,
  lua_toboolean,
  lua_tointeger,
  lua_tonumber,
  lua_tostring,
  lua_touserdata,
  lua_type,
  lua_upvalueindex
} = __webpack_require__(2);

const {
  luaL_Buffer,
  luaL_addchar,
  luaL_addlstring,
  luaL_addsize,
  luaL_addstring,
  luaL_addvalue,
  luaL_argcheck,
  luaL_argerror,
  luaL_buffinit,
  luaL_buffinitsize,
  luaL_checkinteger,
  luaL_checknumber,
  luaL_checkstack,
  luaL_checkstring,
  luaL_checktype,
  luaL_error,
  luaL_newlib,
  luaL_optinteger,
  luaL_optstring,
  luaL_prepbuffsize,
  luaL_pushresult,
  luaL_pushresultsize,
  luaL_tolstring,
  luaL_typename
} = __webpack_require__(8);

const lualib = __webpack_require__(18);

const {
  luastring_eq,
  luastring_indexOf,
  to_jsstring,
  to_luastring
} = __webpack_require__(6);

const sL_ESC = '%';
const L_ESC = sL_ESC.charCodeAt(0);
/*
** maximum number of captures that a pattern can do during
** pattern-matching. This limit is arbitrary, but must fit in
** an unsigned char.
*/

const LUA_MAXCAPTURES = 32; // (sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))

const MAXSIZE = 2147483647;
/* Give natural (i.e. strings end at the first \0) length of a string represented by an array of bytes */

const strlen = function (s) {
  let len = luastring_indexOf(s, 0);
  return len > -1 ? len : s.length;
};
/* translate a relative string position: negative means back from end */


const posrelat = function (pos, len) {
  if (pos >= 0) return pos;else if (0 - pos > len) return 0;else return len + pos + 1;
};

const str_sub = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let start = posrelat(luaL_checkinteger(L, 2), l);
  let end = posrelat(luaL_optinteger(L, 3, -1), l);
  if (start < 1) start = 1;
  if (end > l) end = l;
  if (start <= end) lua_pushstring(L, s.subarray(start - 1, start - 1 + (end - start + 1)));else lua_pushliteral(L, "");
  return 1;
};

const str_len = function (L) {
  lua_pushinteger(L, luaL_checkstring(L, 1).length);
  return 1;
};

const str_char = function (L) {
  let n = lua_gettop(L);
  /* number of arguments */

  let b = new luaL_Buffer();
  let p = luaL_buffinitsize(L, b, n);

  for (let i = 1; i <= n; i++) {
    let c = luaL_checkinteger(L, i);
    luaL_argcheck(L, c >= 0 && c <= 255, "value out of range"); // Strings are 8-bit clean

    p[i - 1] = c;
  }

  luaL_pushresultsize(b, n);
  return 1;
};

const writer = function (L, b, size, B) {
  luaL_addlstring(B, b, size);
  return 0;
};

const str_dump = function (L) {
  let b = new luaL_Buffer();
  let strip = lua_toboolean(L, 2);
  luaL_checktype(L, 1, LUA_TFUNCTION);
  lua_settop(L, 1);
  luaL_buffinit(L, b);
  if (lua_dump(L, writer, b, strip) !== 0) return luaL_error(L, to_luastring("unable to dump given function"));
  luaL_pushresult(b);
  return 1;
};

const SIZELENMOD = LUA_NUMBER_FRMLEN.length + 1;
const L_NBFD = 1;

const num2straux = function (x) {
  /* if 'inf' or 'NaN', format it like '%g' */
  if (Object.is(x, Infinity)) return to_luastring('inf');else if (Object.is(x, -Infinity)) return to_luastring('-inf');else if (Number.isNaN(x)) return to_luastring('nan');else if (x === 0) {
    /* can be -0... */

    /* create "0" or "-0" followed by exponent */
    let zero = sprintf(LUA_NUMBER_FMT + "x0p+0", x);
    if (Object.is(x, -0)) zero = "-" + zero;
    return to_luastring(zero);
  } else {
    let buff = "";
    let fe = frexp(x);
    /* 'x' fraction and exponent */

    let m = fe[0];
    let e = fe[1];

    if (m < 0) {
      /* is number negative? */
      buff += '-';
      /* add signal */

      m = -m;
      /* make it positive */
    }

    buff += "0x";
    /* add "0x" */

    buff += (m * (1 << L_NBFD)).toString(16);
    e -= L_NBFD;
    /* this digit goes before the radix point */

    buff += sprintf("p%+d", e);
    /* add exponent */

    return to_luastring(buff);
  }
};

const lua_number2strx = function (L, fmt, x) {
  let buff = num2straux(x);

  if (fmt[SIZELENMOD] === 65
  /* 'A'.charCodeAt(0) */
  ) {
      for (let i = 0; i < buff.length; i++) {
        let c = buff[i];
        if (c >= 97)
          /* toupper */
          buff[i] = c & 0xdf;
      }
    } else if (fmt[SIZELENMOD] !== 97
  /* 'a'.charCodeAt(0) */
  ) luaL_error(L, to_luastring("modifiers for format '%%a'/'%%A' not implemented"));

  return buff;
};
/*
** Maximum size of each formatted item. This maximum size is produced
** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',
** and '\0') + number of decimal digits to represent maxfloat (which
** is maximum exponent + 1). (99+3+1 then rounded to 120 for "extra
** expenses", such as locale-dependent stuff)
*/
// const MAX_ITEM   = 120;// TODO: + l_mathlim(MAX_10_EXP);

/* valid flags in a format specification */


const FLAGS = to_luastring("-+ #0");
/*
** maximum size of each format specification (such as "%-099.99d")
*/
// const MAX_FORMAT = 32;

const isalpha = e => 97 <= e && e <= 122 || 65 <= e && e <= 90;

const isdigit = e => 48 <= e && e <= 57;

const iscntrl = e => 0x00 <= e && e <= 0x1f || e === 0x7f;

const isgraph = e => 33 <= e && e <= 126;

const islower = e => 97 <= e && e <= 122;

const isupper = e => 65 <= e && e <= 90;

const isalnum = e => 97 <= e && e <= 122 || 65 <= e && e <= 90 || 48 <= e && e <= 57;

const ispunct = e => isgraph(e) && !isalnum(e);

const isspace = e => e === 32 || e >= 9 && e <= 13;

const isxdigit = e => 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;

const addquoted = function (b, s, len) {
  luaL_addchar(b, 34
  /* '"'.charCodeAt(0) */
  );
  let i = 0;

  while (len--) {
    if (s[i] === 34
    /* '"'.charCodeAt(0) */
    || s[i] === 92
    /* '\\'.charCodeAt(0) */
    || s[i] === 10
    /* '\n'.charCodeAt(0) */
    ) {
        luaL_addchar(b, 92
        /* '\\'.charCodeAt(0) */
        );
        luaL_addchar(b, s[i]);
      } else if (iscntrl(s[i])) {
      let buff = '' + s[i];
      if (isdigit(s[i + 1])) buff = '0'.repeat(3 - buff.length) + buff;
      /* pad to 3 '0's */

      luaL_addstring(b, to_luastring("\\" + buff));
    } else luaL_addchar(b, s[i]);

    i++;
  }

  luaL_addchar(b, 34
  /* '"'.charCodeAt(0) */
  );
};
/*
** Ensures the 'buff' string uses a dot as the radix character.
*/


const checkdp = function (buff) {
  if (luastring_indexOf(buff, 46
  /* ('.').charCodeAt(0) */
  ) < 0) {
    /* no dot? */
    let point = lua_getlocaledecpoint();
    /* try locale point */

    let ppoint = luastring_indexOf(buff, point);
    if (ppoint) buff[ppoint] = 46
    /* ('.').charCodeAt(0) */
    ;
    /* change it to a dot */
  }
};

const addliteral = function (L, b, arg) {
  switch (lua_type(L, arg)) {
    case LUA_TSTRING:
      {
        let s = lua_tostring(L, arg);
        addquoted(b, s, s.length);
        break;
      }

    case LUA_TNUMBER:
      {
        let buff;

        if (!lua_isinteger(L, arg)) {
          /* float? */
          let n = lua_tonumber(L, arg);
          /* write as hexa ('%a') */

          buff = lua_number2strx(L, to_luastring(`%${LUA_INTEGER_FRMLEN}a`), n);
          checkdp(buff);
          /* ensure it uses a dot */
        } else {
          /* integers */
          let n = lua_tointeger(L, arg);
          let format = n === LUA_MININTEGER ?
          /* corner case? */
          "0x%" + LUA_INTEGER_FRMLEN + "x"
          /* use hexa */
          : LUA_INTEGER_FMT;
          /* else use default format */

          buff = to_luastring(sprintf(format, n));
        }

        luaL_addstring(b, buff);
        break;
      }

    case LUA_TNIL:
    case LUA_TBOOLEAN:
      {
        luaL_tolstring(L, arg);
        luaL_addvalue(b);
        break;
      }

    default:
      {
        luaL_argerror(L, arg, to_luastring("value has no literal form"));
      }
  }
};

const scanformat = function (L, strfrmt, i, form) {
  let p = i;

  while (strfrmt[p] !== 0 && luastring_indexOf(FLAGS, strfrmt[p]) >= 0) p++;
  /* skip flags */


  if (p - i >= FLAGS.length) luaL_error(L, to_luastring("invalid format (repeated flags)"));
  if (isdigit(strfrmt[p])) p++;
  /* skip width */

  if (isdigit(strfrmt[p])) p++;
  /* (2 digits at most) */

  if (strfrmt[p] === 46
  /* '.'.charCodeAt(0) */
  ) {
      p++;
      if (isdigit(strfrmt[p])) p++;
      /* skip precision */

      if (isdigit(strfrmt[p])) p++;
      /* (2 digits at most) */
    }

  if (isdigit(strfrmt[p])) luaL_error(L, to_luastring("invalid format (width or precision too long)"));
  form[0] = 37
  /* "%".charCodeAt(0) */
  ;

  for (let j = 0; j < p - i + 1; j++) form[j + 1] = strfrmt[i + j];

  return p;
};
/*
** add length modifier into formats
*/


const addlenmod = function (form, lenmod) {
  let l = form.length;
  let lm = lenmod.length;
  let spec = form[l - 1];

  for (let i = 0; i < lm; i++) form[i + l - 1] = lenmod[i];

  form[l + lm - 1] = spec; // form[l + lm] = 0;
};

const str_format = function (L) {
  let top = lua_gettop(L);
  let arg = 1;
  let strfrmt = luaL_checkstring(L, arg);
  let i = 0;
  let b = new luaL_Buffer();
  luaL_buffinit(L, b);

  while (i < strfrmt.length) {
    if (strfrmt[i] !== L_ESC) {
      luaL_addchar(b, strfrmt[i++]);
    } else if (strfrmt[++i] === L_ESC) {
      luaL_addchar(b, strfrmt[i++]);
      /* %% */
    } else {
      /* format item */
      let form = [];
      /* to store the format ('%...') */

      if (++arg > top) luaL_argerror(L, arg, to_luastring("no value"));
      i = scanformat(L, strfrmt, i, form);

      switch (String.fromCharCode(strfrmt[i++])) {
        case 'c':
          {
            // sprintf(String.fromCharCode(...form), luaL_checkinteger(L, arg));
            luaL_addchar(b, luaL_checkinteger(L, arg));
            break;
          }

        case 'd':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
        case 'X':
          {
            let n = luaL_checkinteger(L, arg);
            addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));
            luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));
            break;
          }

        case 'a':
        case 'A':
          {
            addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));
            luaL_addstring(b, lua_number2strx(L, form, luaL_checknumber(L, arg)));
            break;
          }

        case 'e':
        case 'E':
        case 'f':
        case 'g':
        case 'G':
          {
            let n = luaL_checknumber(L, arg);
            addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));
            luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));
            break;
          }

        case 'q':
          {
            addliteral(L, b, arg);
            break;
          }

        case 's':
          {
            let s = luaL_tolstring(L, arg);

            if (form.length <= 2 || form[2] === 0) {
              /* no modifiers? */
              luaL_addvalue(b);
              /* keep entire string */
            } else {
              luaL_argcheck(L, s.length === strlen(s), arg, "string contains zeros");

              if (luastring_indexOf(form, 46
              /* '.'.charCodeAt(0) */
              ) < 0 && s.length >= 100) {
                /* no precision and string is too long to be formatted */
                luaL_addvalue(b);
                /* keep entire string */
              } else {
                /* format the string into 'buff' */
                // TODO: will fail if s is not valid UTF-8
                luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), to_jsstring(s))));
                lua_pop(L, 1);
                /* remove result from 'luaL_tolstring' */
              }
            }

            break;
          }

        default:
          {
            /* also treat cases 'pnLlh' */
            return luaL_error(L, to_luastring("invalid option '%%%c' to 'format'"), strfrmt[i - 1]);
          }
      }
    }
  }

  luaL_pushresult(b);
  return 1;
};
/* value used for padding */


const LUAL_PACKPADBYTE = 0x00;
/* maximum size for the binary representation of an integer */

const MAXINTSIZE = 16;
const SZINT = 4; // Size of lua_Integer

/* number of bits in a character */

const NB = 8;
/* mask for one character (NB 1's) */

const MC = (1 << NB) - 1;
const MAXALIGN = 8;
/*
** information to pack/unpack stuff
*/

class Header {
  constructor(L) {
    this.L = L;
    this.islittle = true;
    this.maxalign = 1;
  }

}
/*
** options for pack/unpack
*/


const Kint = 0;
/* signed integers */

const Kuint = 1;
/* unsigned integers */

const Kfloat = 2;
/* floating-point numbers */

const Kchar = 3;
/* fixed-length strings */

const Kstring = 4;
/* strings with prefixed length */

const Kzstr = 5;
/* zero-terminated strings */

const Kpadding = 6;
/* padding */

const Kpaddalign = 7;
/* padding for alignment */

const Knop = 8;
/* no-op (configuration or spaces) */

const digit = isdigit;

const getnum = function (fmt, df) {
  if (fmt.off >= fmt.s.length || !digit(fmt.s[fmt.off]))
    /* no number? */
    return df;
    /* return default value */
  else {
      let a = 0;

      do {
        a = a * 10 + (fmt.s[fmt.off++] - 48
        /* '0'.charCodeAt(0) */
        );
      } while (fmt.off < fmt.s.length && digit(fmt.s[fmt.off]) && a <= (MAXSIZE - 9) / 10);

      return a;
    }
};
/*
** Read an integer numeral and raises an error if it is larger
** than the maximum size for integers.
*/


const getnumlimit = function (h, fmt, df) {
  let sz = getnum(fmt, df);
  if (sz > MAXINTSIZE || sz <= 0) luaL_error(h.L, to_luastring("integral size (%d) out of limits [1,%d]"), sz, MAXINTSIZE);
  return sz;
};
/*
** Read and classify next option. 'size' is filled with option's size.
*/


const getoption = function (h, fmt) {
  let r = {
    opt: fmt.s[fmt.off++],
    size: 0
    /* default */

  };

  switch (r.opt) {
    case 98
    /*'b'*/
    :
      r.size = 1;
      r.opt = Kint;
      return r;
    // sizeof(char): 1

    case 66
    /*'B'*/
    :
      r.size = 1;
      r.opt = Kuint;
      return r;

    case 104
    /*'h'*/
    :
      r.size = 2;
      r.opt = Kint;
      return r;
    // sizeof(short): 2

    case 72
    /*'H'*/
    :
      r.size = 2;
      r.opt = Kuint;
      return r;

    case 108
    /*'l'*/
    :
      r.size = 4;
      r.opt = Kint;
      return r;
    // sizeof(long): 4

    case 76
    /*'L'*/
    :
      r.size = 4;
      r.opt = Kuint;
      return r;

    case 106
    /*'j'*/
    :
      r.size = 4;
      r.opt = Kint;
      return r;
    // sizeof(lua_Integer): 4

    case 74
    /*'J'*/
    :
      r.size = 4;
      r.opt = Kuint;
      return r;

    case 84
    /*'T'*/
    :
      r.size = 4;
      r.opt = Kuint;
      return r;
    // sizeof(size_t): 4

    case 102
    /*'f'*/
    :
      r.size = 4;
      r.opt = Kfloat;
      return r;
    // sizeof(float): 4

    case 100
    /*'d'*/
    :
      r.size = 8;
      r.opt = Kfloat;
      return r;
    // sizeof(double): 8

    case 110
    /*'n'*/
    :
      r.size = 8;
      r.opt = Kfloat;
      return r;
    // sizeof(lua_Number): 8

    case 105
    /*'i'*/
    :
      r.size = getnumlimit(h, fmt, 4);
      r.opt = Kint;
      return r;
    // sizeof(int): 4

    case 73
    /*'I'*/
    :
      r.size = getnumlimit(h, fmt, 4);
      r.opt = Kuint;
      return r;

    case 115
    /*'s'*/
    :
      r.size = getnumlimit(h, fmt, 4);
      r.opt = Kstring;
      return r;

    case 99
    /*'c'*/
    :
      {
        r.size = getnum(fmt, -1);
        if (r.size === -1) luaL_error(h.L, to_luastring("missing size for format option 'c'"));
        r.opt = Kchar;
        return r;
      }

    case 122
    /*'z'*/
    :
      r.opt = Kzstr;
      return r;

    case 120
    /*'x'*/
    :
      r.size = 1;
      r.opt = Kpadding;
      return r;

    case 88
    /*'X'*/
    :
      r.opt = Kpaddalign;
      return r;

    case 32
    /*' '*/
    :
      break;

    case 60
    /*'<'*/
    :
      h.islittle = true;
      break;

    case 62
    /*'>'*/
    :
      h.islittle = false;
      break;

    case 61
    /*'='*/
    :
      h.islittle = true;
      break;

    case 33
    /*'!'*/
    :
      h.maxalign = getnumlimit(h, fmt, MAXALIGN);
      break;

    default:
      luaL_error(h.L, to_luastring("invalid format option '%c'"), r.opt);
  }

  r.opt = Knop;
  return r;
};
/*
** Read, classify, and fill other details about the next option.
** 'psize' is filled with option's size, 'notoalign' with its
** alignment requirements.
** Local variable 'size' gets the size to be aligned. (Kpadal option
** always gets its full alignment, other options are limited by
** the maximum alignment ('maxalign'). Kchar option needs no alignment
** despite its size.
*/


const getdetails = function (h, totalsize, fmt) {
  let r = {
    opt: NaN,
    size: NaN,
    ntoalign: NaN
  };
  let opt = getoption(h, fmt);
  r.size = opt.size;
  r.opt = opt.opt;
  let align = r.size;
  /* usually, alignment follows size */

  if (r.opt === Kpaddalign) {
    /* 'X' gets alignment from following option */
    if (fmt.off >= fmt.s.length || fmt.s[fmt.off] === 0) luaL_argerror(h.L, 1, to_luastring("invalid next option for option 'X'"));else {
      let o = getoption(h, fmt);
      align = o.size;
      o = o.opt;
      if (o === Kchar || align === 0) luaL_argerror(h.L, 1, to_luastring("invalid next option for option 'X'"));
    }
  }

  if (align <= 1 || r.opt === Kchar)
    /* need no alignment? */
    r.ntoalign = 0;else {
    if (align > h.maxalign)
      /* enforce maximum alignment */
      align = h.maxalign;
    if ((align & align - 1) !== 0)
      /* is 'align' not a power of 2? */
      luaL_argerror(h.L, 1, to_luastring("format asks for alignment not power of 2"));
    r.ntoalign = align - (totalsize & align - 1) & align - 1;
  }
  return r;
};
/*
** Pack integer 'n' with 'size' bytes and 'islittle' endianness.
** The final 'if' handles the case when 'size' is larger than
** the size of a Lua integer, correcting the extra sign-extension
** bytes if necessary (by default they would be zeros).
*/


const packint = function (b, n, islittle, size, neg) {
  let buff = luaL_prepbuffsize(b, size);
  buff[islittle ? 0 : size - 1] = n & MC;
  /* first byte */

  for (let i = 1; i < size; i++) {
    n >>= NB;
    buff[islittle ? i : size - 1 - i] = n & MC;
  }

  if (neg && size > SZINT) {
    /* negative number need sign extension? */
    for (let i = SZINT; i < size; i++)
    /* correct extra bytes */
    buff[islittle ? i : size - 1 - i] = MC;
  }

  luaL_addsize(b, size);
  /* add result to buffer */
};

const str_pack = function (L) {
  let b = new luaL_Buffer();
  let h = new Header(L);
  let fmt = {
    s: luaL_checkstring(L, 1),

    /* format string */
    off: 0
  };
  let arg = 1;
  /* current argument to pack */

  let totalsize = 0;
  /* accumulate total size of result */

  lua_pushnil(L);
  /* mark to separate arguments from string buffer */

  luaL_buffinit(L, b);

  while (fmt.off < fmt.s.length) {
    let details = getdetails(h, totalsize, fmt);
    let opt = details.opt;
    let size = details.size;
    let ntoalign = details.ntoalign;
    totalsize += ntoalign + size;

    while (ntoalign-- > 0) luaL_addchar(b, LUAL_PACKPADBYTE);
    /* fill alignment */


    arg++;

    switch (opt) {
      case Kint:
        {
          /* signed integers */
          let n = luaL_checkinteger(L, arg);

          if (size < SZINT) {
            /* need overflow check? */
            let lim = 1 << size * 8 - 1;
            luaL_argcheck(L, -lim <= n && n < lim, arg, "integer overflow");
          }

          packint(b, n, h.islittle, size, n < 0);
          break;
        }

      case Kuint:
        {
          /* unsigned integers */
          let n = luaL_checkinteger(L, arg);
          if (size < SZINT) luaL_argcheck(L, n >>> 0 < 1 << size * NB, arg, "unsigned overflow");
          packint(b, n >>> 0, h.islittle, size, false);
          break;
        }

      case Kfloat:
        {
          /* floating-point options */
          let buff = luaL_prepbuffsize(b, size);
          let n = luaL_checknumber(L, arg);
          /* get argument */

          let dv = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
          if (size === 4) dv.setFloat32(0, n, h.islittle);else dv.setFloat64(0, n, h.islittle);
          luaL_addsize(b, size);
          break;
        }

      case Kchar:
        {
          /* fixed-size string */
          let s = luaL_checkstring(L, arg);
          let len = s.length;
          luaL_argcheck(L, len <= size, arg, "string longer than given size");
          luaL_addlstring(b, s, len);
          /* add string */

          while (len++ < size)
          /* pad extra space */
          luaL_addchar(b, LUAL_PACKPADBYTE);

          break;
        }

      case Kstring:
        {
          /* strings with length count */
          let s = luaL_checkstring(L, arg);
          let len = s.length;
          luaL_argcheck(L, size >= 4
          /* sizeof(size_t) */
          || len < 1 << size * NB, arg, "string length does not fit in given size");
          packint(b, len, h.islittle, size, 0);
          /* pack length */

          luaL_addlstring(b, s, len);
          totalsize += len;
          break;
        }

      case Kzstr:
        {
          /* zero-terminated string */
          let s = luaL_checkstring(L, arg);
          let len = s.length;
          luaL_argcheck(L, luastring_indexOf(s, 0) < 0, arg, "strings contains zeros");
          luaL_addlstring(b, s, len);
          luaL_addchar(b, 0);
          /* add zero at the end */

          totalsize += len + 1;
          break;
        }

      case Kpadding:
        luaL_addchar(b, LUAL_PACKPADBYTE);

      /* fall through */

      case Kpaddalign:
      case Knop:
        arg--;
        /* undo increment */

        break;
    }
  }

  luaL_pushresult(b);
  return 1;
};

const str_reverse = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let r = new Uint8Array(l);

  for (let i = 0; i < l; i++) r[i] = s[l - 1 - i];

  lua_pushstring(L, r);
  return 1;
};

const str_lower = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let r = new Uint8Array(l);

  for (let i = 0; i < l; i++) {
    let c = s[i];
    if (isupper(c)) c = c | 0x20;
    r[i] = c;
  }

  lua_pushstring(L, r);
  return 1;
};

const str_upper = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let r = new Uint8Array(l);

  for (let i = 0; i < l; i++) {
    let c = s[i];
    if (islower(c)) c = c & 0xdf;
    r[i] = c;
  }

  lua_pushstring(L, r);
  return 1;
};

const str_rep = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let n = luaL_checkinteger(L, 2);
  let sep = luaL_optstring(L, 3, "");
  let lsep = sep.length;
  if (n <= 0) lua_pushliteral(L, "");else if (l + lsep < l || l + lsep > MAXSIZE / n)
    /* may overflow? */
    return luaL_error(L, to_luastring("resulting string too large"));else {
    let totallen = n * l + (n - 1) * lsep;
    let b = new luaL_Buffer();
    let p = luaL_buffinitsize(L, b, totallen);
    let pi = 0;

    while (n-- > 1) {
      /* first n-1 copies (followed by separator) */
      p.set(s, pi);
      pi += l;

      if (lsep > 0) {
        /* empty 'memcpy' is not that cheap */
        p.set(sep, pi);
        pi += lsep;
      }
    }

    p.set(s, pi);
    /* last copy (not followed by separator) */

    luaL_pushresultsize(b, totallen);
  }
  return 1;
};

const str_byte = function (L) {
  let s = luaL_checkstring(L, 1);
  let l = s.length;
  let posi = posrelat(luaL_optinteger(L, 2, 1), l);
  let pose = posrelat(luaL_optinteger(L, 3, posi), l);
  if (posi < 1) posi = 1;
  if (pose > l) pose = l;
  if (posi > pose) return 0;
  /* empty interval; return no values */

  if (pose - posi >= Number.MAX_SAFE_INTEGER)
    /* arithmetic overflow? */
    return luaL_error(L, "string slice too long");
  let n = pose - posi + 1;
  luaL_checkstack(L, n, "string slice too long");

  for (let i = 0; i < n; i++) lua_pushinteger(L, s[posi + i - 1]);

  return n;
};

const str_packsize = function (L) {
  let h = new Header(L);
  let fmt = {
    s: luaL_checkstring(L, 1),
    off: 0
  };
  let totalsize = 0;
  /* accumulate total size of result */

  while (fmt.off < fmt.s.length) {
    let details = getdetails(h, totalsize, fmt);
    let opt = details.opt;
    let size = details.size;
    let ntoalign = details.ntoalign;
    size += ntoalign;
    /* total space used by option */

    luaL_argcheck(L, totalsize <= MAXSIZE - size, 1, "format result too large");
    totalsize += size;

    switch (opt) {
      case Kstring:
      /* strings with length count */

      case Kzstr:
        /* zero-terminated string */
        luaL_argerror(L, 1, "variable-length format");

      /* call never return, but to avoid warnings: */

      /* fall through */

      default:
        break;
    }
  }

  lua_pushinteger(L, totalsize);
  return 1;
};
/*
** Unpack an integer with 'size' bytes and 'islittle' endianness.
** If size is smaller than the size of a Lua integer and integer
** is signed, must do sign extension (propagating the sign to the
** higher bits); if size is larger than the size of a Lua integer,
** it must check the unread bytes to see whether they do not cause an
** overflow.
*/


const unpackint = function (L, str, islittle, size, issigned) {
  let res = 0;
  let limit = size <= SZINT ? size : SZINT;

  for (let i = limit - 1; i >= 0; i--) {
    res <<= NB;
    res |= str[islittle ? i : size - 1 - i];
  }

  if (size < SZINT) {
    /* real size smaller than lua_Integer? */
    if (issigned) {
      /* needs sign extension? */
      let mask = 1 << size * NB - 1;
      res = (res ^ mask) - mask;
      /* do sign extension */
    }
  } else if (size > SZINT) {
    /* must check unread bytes */
    let mask = !issigned || res >= 0 ? 0 : MC;

    for (let i = limit; i < size; i++) {
      if (str[islittle ? i : size - 1 - i] !== mask) luaL_error(L, to_luastring("%d-byte integer does not fit into Lua Integer"), size);
    }
  }

  return res;
};

const unpacknum = function (L, b, islittle, size) {
  lualib.lua_assert(b.length >= size);
  let dv = new DataView(new ArrayBuffer(size));

  for (let i = 0; i < size; i++) dv.setUint8(i, b[i], islittle);

  if (size == 4) return dv.getFloat32(0, islittle);else return dv.getFloat64(0, islittle);
};

const str_unpack = function (L) {
  let h = new Header(L);
  let fmt = {
    s: luaL_checkstring(L, 1),
    off: 0
  };
  let data = luaL_checkstring(L, 2);
  let ld = data.length;
  let pos = posrelat(luaL_optinteger(L, 3, 1), ld) - 1;
  let n = 0;
  /* number of results */

  luaL_argcheck(L, pos <= ld && pos >= 0, 3, "initial position out of string");

  while (fmt.off < fmt.s.length) {
    let details = getdetails(h, pos, fmt);
    let opt = details.opt;
    let size = details.size;
    let ntoalign = details.ntoalign;
    if (
    /*ntoalign + size > ~pos ||*/
    pos + ntoalign + size > ld) luaL_argerror(L, 2, to_luastring("data string too short"));
    pos += ntoalign;
    /* skip alignment */

    /* stack space for item + next position */

    luaL_checkstack(L, 2, "too many results");
    n++;

    switch (opt) {
      case Kint:
      case Kuint:
        {
          let res = unpackint(L, data.subarray(pos), h.islittle, size, opt === Kint);
          lua_pushinteger(L, res);
          break;
        }

      case Kfloat:
        {
          let res = unpacknum(L, data.subarray(pos), h.islittle, size);
          lua_pushnumber(L, res);
          break;
        }

      case Kchar:
        {
          lua_pushstring(L, data.subarray(pos, pos + size));
          break;
        }

      case Kstring:
        {
          let len = unpackint(L, data.subarray(pos), h.islittle, size, 0);
          luaL_argcheck(L, pos + len + size <= ld, 2, "data string too short");
          lua_pushstring(L, data.subarray(pos + size, pos + size + len));
          pos += len;
          /* skip string */

          break;
        }

      case Kzstr:
        {
          let e = luastring_indexOf(data, 0, pos);
          if (e === -1) e = data.length - pos;
          lua_pushstring(L, data.subarray(pos, e));
          pos = e + 1;
          /* skip string plus final '\0' */

          break;
        }

      case Kpaddalign:
      case Kpadding:
      case Knop:
        n--;
        /* undo increment */

        break;
    }

    pos += size;
  }

  lua_pushinteger(L, pos + 1);
  /* next position */

  return n + 1;
};

const CAP_UNFINISHED = -1;
const CAP_POSITION = -2;
const MAXCCALLS = 200;
const SPECIALS = to_luastring("^$*+?.([%-");

class MatchState {
  constructor(L) {
    this.src = null;
    /* unmodified source string */

    this.src_init = null;
    /* init of source string */

    this.src_end = null;
    /* end ('\0') of source string */

    this.p = null;
    /* unmodified pattern string */

    this.p_end = null;
    /* end ('\0') of pattern */

    this.L = L;
    this.matchdepth = NaN;
    /* control for recursive depth */

    this.level = NaN;
    /* total number of captures (finished or unfinished) */

    this.capture = [];
  }

}

const check_capture = function (ms, l) {
  l = l - 49
  /* '1'.charCodeAt(0) */
  ;
  if (l < 0 || l >= ms.level || ms.capture[l].len === CAP_UNFINISHED) return luaL_error(ms.L, to_luastring("invalid capture index %%%d"), l + 1);
  return l;
};

const capture_to_close = function (ms) {
  let level = ms.level;

  for (level--; level >= 0; level--) if (ms.capture[level].len === CAP_UNFINISHED) return level;

  return luaL_error(ms.L, to_luastring("invalid pattern capture"));
};

const classend = function (ms, p) {
  switch (ms.p[p++]) {
    case L_ESC:
      {
        if (p === ms.p_end) luaL_error(ms.L, to_luastring("malformed pattern (ends with '%%')"));
        return p + 1;
      }

    case 91
    /* '['.charCodeAt(0) */
    :
      {
        if (ms.p[p] === 94
        /* '^'.charCodeAt(0) */
        ) p++;

        do {
          /* look for a ']' */
          if (p === ms.p_end) luaL_error(ms.L, to_luastring("malformed pattern (missing ']')"));
          if (ms.p[p++] === L_ESC && p < ms.p_end) p++;
          /* skip escapes (e.g. '%]') */
        } while (ms.p[p] !== 93
        /* ']'.charCodeAt(0) */
        );

        return p + 1;
      }

    default:
      {
        return p;
      }
  }
};

const match_class = function (c, cl) {
  switch (cl) {
    case 97
    /* 'a'.charCodeAt(0) */
    :
      return isalpha(c);

    case 65
    /* 'A'.charCodeAt(0) */
    :
      return !isalpha(c);

    case 99
    /* 'c'.charCodeAt(0) */
    :
      return iscntrl(c);

    case 67
    /* 'C'.charCodeAt(0) */
    :
      return !iscntrl(c);

    case 100
    /* 'd'.charCodeAt(0) */
    :
      return isdigit(c);

    case 68
    /* 'D'.charCodeAt(0) */
    :
      return !isdigit(c);

    case 103
    /* 'g'.charCodeAt(0) */
    :
      return isgraph(c);

    case 71
    /* 'G'.charCodeAt(0) */
    :
      return !isgraph(c);

    case 108
    /* 'l'.charCodeAt(0) */
    :
      return islower(c);

    case 76
    /* 'L'.charCodeAt(0) */
    :
      return !islower(c);

    case 112
    /* 'p'.charCodeAt(0) */
    :
      return ispunct(c);

    case 80
    /* 'P'.charCodeAt(0) */
    :
      return !ispunct(c);

    case 115
    /* 's'.charCodeAt(0) */
    :
      return isspace(c);

    case 83
    /* 'S'.charCodeAt(0) */
    :
      return !isspace(c);

    case 117
    /* 'u'.charCodeAt(0) */
    :
      return isupper(c);

    case 85
    /* 'U'.charCodeAt(0) */
    :
      return !isupper(c);

    case 119
    /* 'w'.charCodeAt(0) */
    :
      return isalnum(c);

    case 87
    /* 'W'.charCodeAt(0) */
    :
      return !isalnum(c);

    case 120
    /* 'x'.charCodeAt(0) */
    :
      return isxdigit(c);

    case 88
    /* 'X'.charCodeAt(0) */
    :
      return !isxdigit(c);

    case 122
    /* 'z'.charCodeAt(0) */
    :
      return c === 0;

    /* deprecated option */

    case 90
    /* 'z'.charCodeAt(0) */
    :
      return c !== 0;

    /* deprecated option */

    default:
      return cl === c;
  }
};

const matchbracketclass = function (ms, c, p, ec) {
  let sig = true;

  if (ms.p[p + 1] === 94
  /* '^'.charCodeAt(0) */
  ) {
      sig = false;
      p++;
      /* skip the '^' */
    }

  while (++p < ec) {
    if (ms.p[p] === L_ESC) {
      p++;
      if (match_class(c, ms.p[p])) return sig;
    } else if (ms.p[p + 1] === 45
    /* '-'.charCodeAt(0) */
    && p + 2 < ec) {
      p += 2;
      if (ms.p[p - 2] <= c && c <= ms.p[p]) return sig;
    } else if (ms.p[p] === c) return sig;
  }

  return !sig;
};

const singlematch = function (ms, s, p, ep) {
  if (s >= ms.src_end) return false;else {
    let c = ms.src[s];

    switch (ms.p[p]) {
      case 46
      /* '.'.charCodeAt(0) */
      :
        return true;

      /* matches any char */

      case L_ESC:
        return match_class(c, ms.p[p + 1]);

      case 91
      /* '['.charCodeAt(0) */
      :
        return matchbracketclass(ms, c, p, ep - 1);

      default:
        return ms.p[p] === c;
    }
  }
};

const matchbalance = function (ms, s, p) {
  if (p >= ms.p_end - 1) luaL_error(ms.L, to_luastring("malformed pattern (missing arguments to '%%b'"));
  if (ms.src[s] !== ms.p[p]) return null;else {
    let b = ms.p[p];
    let e = ms.p[p + 1];
    let cont = 1;

    while (++s < ms.src_end) {
      if (ms.src[s] === e) {
        if (--cont === 0) return s + 1;
      } else if (ms.src[s] === b) cont++;
    }
  }
  return null;
  /* string ends out of balance */
};

const max_expand = function (ms, s, p, ep) {
  let i = 0;
  /* counts maximum expand for item */

  while (singlematch(ms, s + i, p, ep)) i++;
  /* keeps trying to match with the maximum repetitions */


  while (i >= 0) {
    let res = match(ms, s + i, ep + 1);
    if (res) return res;
    i--;
    /* else didn't match; reduce 1 repetition to try again */
  }

  return null;
};

const min_expand = function (ms, s, p, ep) {
  for (;;) {
    let res = match(ms, s, ep + 1);
    if (res !== null) return res;else if (singlematch(ms, s, p, ep)) s++;
    /* try with one more repetition */
    else return null;
  }
};

const start_capture = function (ms, s, p, what) {
  let level = ms.level;
  if (level >= LUA_MAXCAPTURES) luaL_error(ms.L, to_luastring("too many captures"));
  ms.capture[level] = ms.capture[level] ? ms.capture[level] : {};
  ms.capture[level].init = s;
  ms.capture[level].len = what;
  ms.level = level + 1;
  let res;
  if ((res = match(ms, s, p)) === null)
    /* match failed? */
    ms.level--;
  /* undo capture */

  return res;
};

const end_capture = function (ms, s, p) {
  let l = capture_to_close(ms);
  ms.capture[l].len = s - ms.capture[l].init;
  /* close capture */

  let res;
  if ((res = match(ms, s, p)) === null)
    /* match failed? */
    ms.capture[l].len = CAP_UNFINISHED;
  /* undo capture */

  return res;
};
/* Compare the elements of arrays 'a' and 'b' to see if they contain the same elements */


const array_cmp = function (a, ai, b, bi, len) {
  return luastring_eq(a.subarray(ai, ai + len), b.subarray(bi, bi + len));
};

const match_capture = function (ms, s, l) {
  l = check_capture(ms, l);
  let len = ms.capture[l].len;
  if (ms.src_end - s >= len && array_cmp(ms.src, ms.capture[l].init, ms.src, s, len)) return s + len;else return null;
};

const match = function (ms, s, p) {
  let gotodefault = false;
  let gotoinit = true;
  if (ms.matchdepth-- === 0) luaL_error(ms.L, to_luastring("pattern too complex"));

  while (gotoinit || gotodefault) {
    gotoinit = false;

    if (p !== ms.p_end) {
      /* end of pattern? */
      switch (gotodefault ? void 0 : ms.p[p]) {
        case 40
        /* '('.charCodeAt(0) */
        :
          {
            /* start capture */
            if (ms.p[p + 1] === 41
            /* ')'.charCodeAt(0) */
            )
              /* position capture? */
              s = start_capture(ms, s, p + 2, CAP_POSITION);else s = start_capture(ms, s, p + 1, CAP_UNFINISHED);
            break;
          }

        case 41
        /* ')'.charCodeAt(0) */
        :
          {
            /* end capture */
            s = end_capture(ms, s, p + 1);
            break;
          }

        case 36
        /* '$'.charCodeAt(0) */
        :
          {
            if (p + 1 !== ms.p_end) {
              /* is the '$' the last char in pattern? */
              gotodefault = true;
              /* no; go to default */

              break;
            }

            s = ms.src.length - s === 0 ? s : null;
            /* check end of string */

            break;
          }

        case L_ESC:
          {
            /* escaped sequences not in the format class[*+?-]? */
            switch (ms.p[p + 1]) {
              case 98
              /* 'b'.charCodeAt(0) */
              :
                {
                  /* balanced string? */
                  s = matchbalance(ms, s, p + 2);

                  if (s !== null) {
                    p += 4;
                    gotoinit = true;
                  }

                  break;
                }

              case 102
              /* 'f'.charCodeAt(0) */
              :
                {
                  /* frontier? */
                  p += 2;
                  if (ms.p[p] !== 91
                  /* '['.charCodeAt(0) */
                  ) luaL_error(ms.L, to_luastring("missing '[' after '%%f' in pattern"));
                  let ep = classend(ms, p);
                  /* points to what is next */

                  let previous = s === ms.src_init ? 0 : ms.src[s - 1];

                  if (!matchbracketclass(ms, previous, p, ep - 1) && matchbracketclass(ms, s === ms.src_end ? 0 : ms.src[s], p, ep - 1)) {
                    p = ep;
                    gotoinit = true;
                    break;
                  }

                  s = null;
                  /* match failed */

                  break;
                }

              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                {
                  /* capture results (%0-%9)? */
                  s = match_capture(ms, s, ms.p[p + 1]);

                  if (s !== null) {
                    p += 2;
                    gotoinit = true;
                  }

                  break;
                }

              default:
                gotodefault = true;
            }

            break;
          }

        default:
          {
            /* pattern class plus optional suffix */
            gotodefault = false;
            let ep = classend(ms, p);
            /* points to optional suffix */

            /* does not match at least once? */

            if (!singlematch(ms, s, p, ep)) {
              if (ms.p[ep] === 42
              /* '*'.charCodeAt(0) */
              || ms.p[ep] === 63
              /* '?'.charCodeAt(0) */
              || ms.p[ep] === 45
              /* '-'.charCodeAt(0) */
              ) {
                  /* accept empty? */
                  p = ep + 1;
                  gotoinit = true;
                  break;
                } else
                /* '+' or no suffix */
                s = null;
              /* fail */

            } else {
              /* matched once */
              switch (ms.p[ep]) {
                /* handle optional suffix */
                case 63
                /* '?'.charCodeAt(0) */
                :
                  {
                    /* optional */
                    let res;
                    if ((res = match(ms, s + 1, ep + 1)) !== null) s = res;else {
                      p = ep + 1;
                      gotoinit = true;
                    }
                    break;
                  }

                case 43
                /* '+'.charCodeAt(0) */
                :
                  /* 1 or more repetitions */
                  s++;

                /* 1 match already done */

                /* fall through */

                case 42
                /* '*'.charCodeAt(0) */
                :
                  /* 0 or more repetitions */
                  s = max_expand(ms, s, p, ep);
                  break;

                case 45
                /* '-'.charCodeAt(0) */
                :
                  /* 0 or more repetitions (minimum) */
                  s = min_expand(ms, s, p, ep);
                  break;

                default:
                  /* no suffix */
                  s++;
                  p = ep;
                  gotoinit = true;
              }
            }

            break;
          }
      }
    }
  }

  ms.matchdepth++;
  return s;
};

const push_onecapture = function (ms, i, s, e) {
  if (i >= ms.level) {
    if (i === 0) lua_pushlstring(ms.L, ms.src.subarray(s, e), e - s);
    /* add whole match */
    else luaL_error(ms.L, to_luastring("invalid capture index %%%d"), i + 1);
  } else {
    let l = ms.capture[i].len;
    if (l === CAP_UNFINISHED) luaL_error(ms.L, to_luastring("unfinished capture"));
    if (l === CAP_POSITION) lua_pushinteger(ms.L, ms.capture[i].init - ms.src_init + 1);else lua_pushlstring(ms.L, ms.src.subarray(ms.capture[i].init), l);
  }
};

const push_captures = function (ms, s, e) {
  let nlevels = ms.level === 0 && ms.src.subarray(s) ? 1 : ms.level;
  luaL_checkstack(ms.L, nlevels, "too many captures");

  for (let i = 0; i < nlevels; i++) push_onecapture(ms, i, s, e);

  return nlevels;
  /* number of strings pushed */
};

const nospecials = function (p, l) {
  for (let i = 0; i < l; i++) {
    if (luastring_indexOf(SPECIALS, p[i]) !== -1) return false;
  }

  return true;
};

const prepstate = function (ms, L, s, ls, p, lp) {
  ms.L = L;
  ms.matchdepth = MAXCCALLS;
  ms.src = s;
  ms.src_init = 0;
  ms.src_end = ls;
  ms.p = p;
  ms.p_end = lp;
};

const reprepstate = function (ms) {
  ms.level = 0;
  lualib.lua_assert(ms.matchdepth === MAXCCALLS);
};

const find_subarray = function (arr, subarr, from_index) {
  var i = from_index >>> 0,
      sl = subarr.length;
  if (sl === 0) return i;

  for (; (i = arr.indexOf(subarr[0], i)) !== -1; i++) {
    if (luastring_eq(arr.subarray(i, i + sl), subarr)) return i;
  }

  return -1;
};

const str_find_aux = function (L, find) {
  let s = luaL_checkstring(L, 1);
  let p = luaL_checkstring(L, 2);
  let ls = s.length;
  let lp = p.length;
  let init = posrelat(luaL_optinteger(L, 3, 1), ls);
  if (init < 1) init = 1;else if (init > ls + 1) {
    /* start after string's end? */
    lua_pushnil(L);
    /* cannot find anything */

    return 1;
  }
  /* explicit request or no special characters? */

  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
    /* do a plain search */
    let f = find_subarray(s.subarray(init - 1), p, 0);

    if (f > -1) {
      lua_pushinteger(L, init + f);
      lua_pushinteger(L, init + f + lp - 1);
      return 2;
    }
  } else {
    let ms = new MatchState(L);
    let s1 = init - 1;
    let anchor = p[0] === 94
    /* '^'.charCodeAt(0) */
    ;

    if (anchor) {
      p = p.subarray(1);
      lp--;
      /* skip anchor character */
    }

    prepstate(ms, L, s, ls, p, lp);

    do {
      let res;
      reprepstate(ms);

      if ((res = match(ms, s1, 0)) !== null) {
        if (find) {
          lua_pushinteger(L, s1 + 1);
          /* start */

          lua_pushinteger(L, res);
          /* end */

          return push_captures(ms, null, 0) + 2;
        } else return push_captures(ms, s1, res);
      }
    } while (s1++ < ms.src_end && !anchor);
  }

  lua_pushnil(L);
  /* not found */

  return 1;
};

const str_find = function (L) {
  return str_find_aux(L, 1);
};

const str_match = function (L) {
  return str_find_aux(L, 0);
};
/* state for 'gmatch' */


class GMatchState {
  constructor() {
    this.src = NaN;
    /* current position */

    this.p = NaN;
    /* pattern */

    this.lastmatch = NaN;
    /* end of last match */

    this.ms = new MatchState();
    /* match state */
  }

}

const gmatch_aux = function (L) {
  let gm = lua_touserdata(L, lua_upvalueindex(3));
  gm.ms.L = L;

  for (let src = gm.src; src <= gm.ms.src_end; src++) {
    reprepstate(gm.ms);
    let e;

    if ((e = match(gm.ms, src, gm.p)) !== null && e !== gm.lastmatch) {
      gm.src = gm.lastmatch = e;
      return push_captures(gm.ms, src, e);
    }
  }

  return 0;
  /* not found */
};

const str_gmatch = function (L) {
  let s = luaL_checkstring(L, 1);
  let p = luaL_checkstring(L, 2);
  let ls = s.length;
  let lp = p.length;
  lua_settop(L, 2);
  /* keep them on closure to avoid being collected */

  let gm = new GMatchState();
  lua_pushlightuserdata(L, gm);
  prepstate(gm.ms, L, s, ls, p, lp);
  gm.src = 0;
  gm.p = 0;
  gm.lastmatch = null;
  lua_pushcclosure(L, gmatch_aux, 3);
  return 1;
};

const add_s = function (ms, b, s, e) {
  let L = ms.L;
  let news = lua_tostring(L, 3);
  let l = news.length;

  for (let i = 0; i < l; i++) {
    if (news[i] !== L_ESC) luaL_addchar(b, news[i]);else {
      i++;
      /* skip ESC */

      if (!isdigit(news[i])) {
        if (news[i] !== L_ESC) luaL_error(L, to_luastring("invalid use of '%c' in replacement string"), L_ESC);
        luaL_addchar(b, news[i]);
      } else if (news[i] === 48
      /* '0'.charCodeAt(0) */
      ) luaL_addlstring(b, ms.src.subarray(s, e), e - s);else {
        push_onecapture(ms, news[i] - 49
        /* '1'.charCodeAt(0) */
        , s, e);
        luaL_tolstring(L, -1);
        lua_remove(L, -2);
        /* remove original value */

        luaL_addvalue(b);
        /* add capture to accumulated result */
      }
    }
  }
};

const add_value = function (ms, b, s, e, tr) {
  let L = ms.L;

  switch (tr) {
    case LUA_TFUNCTION:
      {
        lua_pushvalue(L, 3);
        let n = push_captures(ms, s, e);
        lua_call(L, n, 1);
        break;
      }

    case LUA_TTABLE:
      {
        push_onecapture(ms, 0, s, e);
        lua_gettable(L, 3);
        break;
      }

    default:
      {
        /* LUA_TNUMBER or LUA_TSTRING */
        add_s(ms, b, s, e);
        return;
      }
  }

  if (!lua_toboolean(L, -1)) {
    /* nil or false? */
    lua_pop(L, 1);
    lua_pushlstring(L, ms.src.subarray(s, e), e - s);
    /* keep original text */
  } else if (!lua_isstring(L, -1)) luaL_error(L, to_luastring("invalid replacement value (a %s)"), luaL_typename(L, -1));

  luaL_addvalue(b);
  /* add result to accumulator */
};

const str_gsub = function (L) {
  let src = luaL_checkstring(L, 1);
  /* subject */

  let srcl = src.length;
  let p = luaL_checkstring(L, 2);
  /* pattern */

  let lp = p.length;
  let lastmatch = null;
  /* end of last match */

  let tr = lua_type(L, 3);
  /* replacement type */

  let max_s = luaL_optinteger(L, 4, srcl + 1);
  /* max replacements */

  let anchor = p[0] === 94
  /* '^'.charCodeAt(0) */
  ;
  let n = 0;
  /* replacement count */

  let ms = new MatchState(L);
  let b = new luaL_Buffer();
  luaL_argcheck(L, tr === LUA_TNUMBER || tr === LUA_TSTRING || tr === LUA_TFUNCTION || tr === LUA_TTABLE, 3, "string/function/table expected");
  luaL_buffinit(L, b);

  if (anchor) {
    p = p.subarray(1);
    lp--;
    /* skip anchor character */
  }

  prepstate(ms, L, src, srcl, p, lp);
  src = 0;
  p = 0;

  while (n < max_s) {
    let e;
    reprepstate(ms);

    if ((e = match(ms, src, p)) !== null && e !== lastmatch) {
      /* match? */
      n++;
      add_value(ms, b, src, e, tr);
      /* add replacement to buffer */

      src = lastmatch = e;
    } else if (src < ms.src_end)
      /* otherwise, skip one character */
      luaL_addchar(b, ms.src[src++]);else break;
    /* end of subject */


    if (anchor) break;
  }

  luaL_addlstring(b, ms.src.subarray(src, ms.src_end), ms.src_end - src);
  luaL_pushresult(b);
  lua_pushinteger(L, n);
  /* number of substitutions */

  return 2;
};

const strlib = {
  "byte": str_byte,
  "char": str_char,
  "dump": str_dump,
  "find": str_find,
  "format": str_format,
  "gmatch": str_gmatch,
  "gsub": str_gsub,
  "len": str_len,
  "lower": str_lower,
  "match": str_match,
  "pack": str_pack,
  "packsize": str_packsize,
  "rep": str_rep,
  "reverse": str_reverse,
  "sub": str_sub,
  "unpack": str_unpack,
  "upper": str_upper
};

const createmetatable = function (L) {
  lua_createtable(L, 0, 1);
  /* table to be metatable for strings */

  lua_pushliteral(L, "");
  /* dummy string */

  lua_pushvalue(L, -2);
  /* copy table */

  lua_setmetatable(L, -2);
  /* set table as metatable for strings */

  lua_pop(L, 1);
  /* pop dummy string */

  lua_pushvalue(L, -2);
  /* get string library */

  lua_setfield(L, -2, to_luastring("__index", true));
  /* metatable.__index = string */

  lua_pop(L, 1);
  /* pop metatable */
};

const luaopen_string = function (L) {
  luaL_newlib(L, strlib);
  createmetatable(L);
  return 1;
};

module.exports.luaopen_string = luaopen_string;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  lua_gettop,
  lua_pushcfunction,
  lua_pushfstring,
  lua_pushinteger,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_setfield,
  lua_tointeger
} = __webpack_require__(2);

const {
  luaL_Buffer,
  luaL_addvalue,
  luaL_argcheck,
  luaL_buffinit,
  luaL_checkinteger,
  luaL_checkstack,
  luaL_checkstring,
  luaL_error,
  luaL_newlib,
  luaL_optinteger,
  luaL_pushresult
} = __webpack_require__(8);

const {
  luastring_of,
  to_luastring
} = __webpack_require__(6);

const MAXUNICODE = 0x10FFFF;

const iscont = function (p) {
  let c = p & 0xC0;
  return c === 0x80;
};
/* translate a relative string position: negative means back from end */


const u_posrelat = function (pos, len) {
  if (pos >= 0) return pos;else if (0 - pos > len) return 0;else return len + pos + 1;
};
/*
** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.
*/


const limits = [0xFF, 0x7F, 0x7FF, 0xFFFF];

const utf8_decode = function (s, pos) {
  let c = s[pos];
  let res = 0;
  /* final result */

  if (c < 0x80)
    /* ascii? */
    res = c;else {
    let count = 0;
    /* to count number of continuation bytes */

    while (c & 0x40) {
      /* still have continuation bytes? */
      let cc = s[pos + ++count];
      /* read next byte */

      if ((cc & 0xC0) !== 0x80)
        /* not a continuation byte? */
        return null;
      /* invalid byte sequence */

      res = res << 6 | cc & 0x3F;
      /* add lower 6 bits from cont. byte */

      c <<= 1;
      /* to test next bit */
    }

    res |= (c & 0x7F) << count * 5;
    /* add first byte */

    if (count > 3 || res > MAXUNICODE || res <= limits[count]) return null;
    /* invalid byte sequence */

    pos += count;
    /* skip continuation bytes read */
  }
  return {
    code: res,
    pos: pos + 1
  };
};
/*
** utf8len(s [, i [, j]]) --> number of characters that start in the
** range [i,j], or nil + current position if 's' is not well formed in
** that interval
*/


const utflen = function (L) {
  let n = 0;
  let s = luaL_checkstring(L, 1);
  let len = s.length;
  let posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
  let posj = u_posrelat(luaL_optinteger(L, 3, -1), len);
  luaL_argcheck(L, 1 <= posi && --posi <= len, 2, "initial position out of string");
  luaL_argcheck(L, --posj < len, 3, "final position out of string");

  while (posi <= posj) {
    let dec = utf8_decode(s, posi);

    if (dec === null) {
      /* conversion error? */
      lua_pushnil(L);
      /* return nil ... */

      lua_pushinteger(L, posi + 1);
      /* ... and current position */

      return 2;
    }

    posi = dec.pos;
    n++;
  }

  lua_pushinteger(L, n);
  return 1;
};

const p_U = to_luastring("%U");

const pushutfchar = function (L, arg) {
  let code = luaL_checkinteger(L, arg);
  luaL_argcheck(L, 0 <= code && code <= MAXUNICODE, arg, "value out of range");
  lua_pushfstring(L, p_U, code);
};
/*
** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...
*/


const utfchar = function (L) {
  let n = lua_gettop(L);
  /* number of arguments */

  if (n === 1)
    /* optimize common case of single char */
    pushutfchar(L, 1);else {
    let b = new luaL_Buffer();
    luaL_buffinit(L, b);

    for (let i = 1; i <= n; i++) {
      pushutfchar(L, i);
      luaL_addvalue(b);
    }

    luaL_pushresult(b);
  }
  return 1;
};
/*
** offset(s, n, [i])  -> index where n-th character counting from
**   position 'i' starts; 0 means character at 'i'.
*/


const byteoffset = function (L) {
  let s = luaL_checkstring(L, 1);
  let n = luaL_checkinteger(L, 2);
  let posi = n >= 0 ? 1 : s.length + 1;
  posi = u_posrelat(luaL_optinteger(L, 3, posi), s.length);
  luaL_argcheck(L, 1 <= posi && --posi <= s.length, 3, "position out of range");

  if (n === 0) {
    /* find beginning of current byte sequence */
    while (posi > 0 && iscont(s[posi])) posi--;
  } else {
    if (iscont(s[posi])) luaL_error(L, "initial position is a continuation byte");

    if (n < 0) {
      while (n < 0 && posi > 0) {
        /* move back */
        do {
          /* find beginning of previous character */
          posi--;
        } while (posi > 0 && iscont(s[posi]));

        n++;
      }
    } else {
      n--;
      /* do not move for 1st character */

      while (n > 0 && posi < s.length) {
        do {
          /* find beginning of next character */
          posi++;
        } while (iscont(s[posi]));
        /* (cannot pass final '\0') */


        n--;
      }
    }
  }

  if (n === 0)
    /* did it find given character? */
    lua_pushinteger(L, posi + 1);else
    /* no such character */
    lua_pushnil(L);
  return 1;
};
/*
** codepoint(s, [i, [j]])  -> returns codepoints for all characters
** that start in the range [i,j]
*/


const codepoint = function (L) {
  let s = luaL_checkstring(L, 1);
  let posi = u_posrelat(luaL_optinteger(L, 2, 1), s.length);
  let pose = u_posrelat(luaL_optinteger(L, 3, posi), s.length);
  luaL_argcheck(L, posi >= 1, 2, "out of range");
  luaL_argcheck(L, pose <= s.length, 3, "out of range");
  if (posi > pose) return 0;
  /* empty interval; return no values */

  if (pose - posi >= Number.MAX_SAFE_INTEGER) return luaL_error(L, "string slice too long");
  let n = pose - posi + 1;
  luaL_checkstack(L, n, "string slice too long");
  n = 0;

  for (posi -= 1; posi < pose;) {
    let dec = utf8_decode(s, posi);
    if (dec === null) return luaL_error(L, "invalid UTF-8 code");
    lua_pushinteger(L, dec.code);
    posi = dec.pos;
    n++;
  }

  return n;
};

const iter_aux = function (L) {
  let s = luaL_checkstring(L, 1);
  let len = s.length;
  let n = lua_tointeger(L, 2) - 1;
  if (n < 0)
    /* first iteration? */
    n = 0;
    /* start from here */
  else if (n < len) {
      n++;
      /* skip current byte */

      while (iscont(s[n])) n++;
      /* and its continuations */

    }
  if (n >= len) return 0;
  /* no more codepoints */
  else {
      let dec = utf8_decode(s, n);
      if (dec === null || iscont(s[dec.pos])) return luaL_error(L, to_luastring("invalid UTF-8 code"));
      lua_pushinteger(L, n + 1);
      lua_pushinteger(L, dec.code);
      return 2;
    }
};

const iter_codes = function (L) {
  luaL_checkstring(L, 1);
  lua_pushcfunction(L, iter_aux);
  lua_pushvalue(L, 1);
  lua_pushinteger(L, 0);
  return 3;
};

const funcs = {
  "char": utfchar,
  "codepoint": codepoint,
  "codes": iter_codes,
  "len": utflen,
  "offset": byteoffset
};
/* pattern to match a single UTF-8 character */

const UTF8PATT = luastring_of(91, 0, 45, 127, 194, 45, 244, 93, 91, 128, 45, 191, 93, 42);

const luaopen_utf8 = function (L) {
  luaL_newlib(L, funcs);
  lua_pushstring(L, UTF8PATT);
  lua_setfield(L, -2, to_luastring("charpattern", true));
  return 1;
};

module.exports.luaopen_utf8 = luaopen_utf8;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_OPLT,
  LUA_TNUMBER,
  lua_compare,
  lua_gettop,
  lua_isinteger,
  lua_isnoneornil,
  lua_pushboolean,
  lua_pushinteger,
  lua_pushliteral,
  lua_pushnil,
  lua_pushnumber,
  lua_pushvalue,
  lua_setfield,
  lua_settop,
  lua_tointeger,
  lua_tointegerx,
  lua_type
} = __webpack_require__(2);

const {
  luaL_argcheck,
  luaL_argerror,
  luaL_checkany,
  luaL_checkinteger,
  luaL_checknumber,
  luaL_error,
  luaL_newlib,
  luaL_optnumber
} = __webpack_require__(8);

const {
  LUA_MAXINTEGER,
  LUA_MININTEGER,
  lua_numbertointeger
} = __webpack_require__(4);

const {
  to_luastring
} = __webpack_require__(6);

let rand_state;
/* use same parameters as glibc LCG */

const l_rand = function () {
  rand_state = 1103515245 * rand_state + 12345 & 0x7fffffff;
  return rand_state;
};

const l_srand = function (x) {
  rand_state = x | 0;
  if (rand_state === 0) rand_state = 1;
};

const math_random = function (L) {
  let low, up;
  /* use Math.random until randomseed is called */

  let r = rand_state === void 0 ? Math.random() : l_rand() / 0x80000000;

  switch (lua_gettop(L)) {
    /* check number of arguments */
    case 0:
      lua_pushnumber(L, r);
      /* Number between 0 and 1 */

      return 1;

    case 1:
      {
        low = 1;
        up = luaL_checkinteger(L, 1);
        break;
      }

    case 2:
      {
        low = luaL_checkinteger(L, 1);
        up = luaL_checkinteger(L, 2);
        break;
      }

    default:
      return luaL_error(L, "wrong number of arguments");
  }
  /* random integer in the interval [low, up] */


  luaL_argcheck(L, low <= up, 1, "interval is empty");
  luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1, "interval too large");
  r *= up - low + 1;
  lua_pushinteger(L, Math.floor(r) + low);
  return 1;
};

const math_randomseed = function (L) {
  l_srand(luaL_checknumber(L, 1));
  l_rand();
  /* discard first value to avoid undesirable correlations */

  return 0;
};

const math_abs = function (L) {
  if (lua_isinteger(L, 1)) {
    let n = lua_tointeger(L, 1);
    if (n < 0) n = -n | 0;
    lua_pushinteger(L, n);
  } else lua_pushnumber(L, Math.abs(luaL_checknumber(L, 1)));

  return 1;
};

const math_sin = function (L) {
  lua_pushnumber(L, Math.sin(luaL_checknumber(L, 1)));
  return 1;
};

const math_cos = function (L) {
  lua_pushnumber(L, Math.cos(luaL_checknumber(L, 1)));
  return 1;
};

const math_tan = function (L) {
  lua_pushnumber(L, Math.tan(luaL_checknumber(L, 1)));
  return 1;
};

const math_asin = function (L) {
  lua_pushnumber(L, Math.asin(luaL_checknumber(L, 1)));
  return 1;
};

const math_acos = function (L) {
  lua_pushnumber(L, Math.acos(luaL_checknumber(L, 1)));
  return 1;
};

const math_atan = function (L) {
  let y = luaL_checknumber(L, 1);
  let x = luaL_optnumber(L, 2, 1);
  lua_pushnumber(L, Math.atan2(y, x));
  return 1;
};

const math_toint = function (L) {
  let n = lua_tointegerx(L, 1);
  if (n !== false) lua_pushinteger(L, n);else {
    luaL_checkany(L, 1);
    lua_pushnil(L);
    /* value is not convertible to integer */
  }
  return 1;
};

const pushnumint = function (L, d) {
  let n = lua_numbertointeger(d);
  if (n !== false)
    /* does 'd' fit in an integer? */
    lua_pushinteger(L, n);
    /* result is integer */
  else lua_pushnumber(L, d);
  /* result is float */
};

const math_floor = function (L) {
  if (lua_isinteger(L, 1)) lua_settop(L, 1);else pushnumint(L, Math.floor(luaL_checknumber(L, 1)));
  return 1;
};

const math_ceil = function (L) {
  if (lua_isinteger(L, 1)) lua_settop(L, 1);else pushnumint(L, Math.ceil(luaL_checknumber(L, 1)));
  return 1;
};

const math_sqrt = function (L) {
  lua_pushnumber(L, Math.sqrt(luaL_checknumber(L, 1)));
  return 1;
};

const math_ult = function (L) {
  let a = luaL_checkinteger(L, 1);
  let b = luaL_checkinteger(L, 2);
  lua_pushboolean(L, a >= 0 ? b < 0 || a < b : b < 0 && a < b);
  return 1;
};

const math_log = function (L) {
  let x = luaL_checknumber(L, 1);
  let res;
  if (lua_isnoneornil(L, 2)) res = Math.log(x);else {
    let base = luaL_checknumber(L, 2);
    if (base === 2) res = Math.log2(x);else if (base === 10) res = Math.log10(x);else res = Math.log(x) / Math.log(base);
  }
  lua_pushnumber(L, res);
  return 1;
};

const math_exp = function (L) {
  lua_pushnumber(L, Math.exp(luaL_checknumber(L, 1)));
  return 1;
};

const math_deg = function (L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) * (180 / Math.PI));
  return 1;
};

const math_rad = function (L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) * (Math.PI / 180));
  return 1;
};

const math_min = function (L) {
  let n = lua_gettop(L);
  /* number of arguments */

  let imin = 1;
  /* index of current minimum value */

  luaL_argcheck(L, n >= 1, 1, "value expected");

  for (let i = 2; i <= n; i++) {
    if (lua_compare(L, i, imin, LUA_OPLT)) imin = i;
  }

  lua_pushvalue(L, imin);
  return 1;
};

const math_max = function (L) {
  let n = lua_gettop(L);
  /* number of arguments */

  let imax = 1;
  /* index of current minimum value */

  luaL_argcheck(L, n >= 1, 1, "value expected");

  for (let i = 2; i <= n; i++) {
    if (lua_compare(L, imax, i, LUA_OPLT)) imax = i;
  }

  lua_pushvalue(L, imax);
  return 1;
};

const math_type = function (L) {
  if (lua_type(L, 1) === LUA_TNUMBER) {
    if (lua_isinteger(L, 1)) lua_pushliteral(L, "integer");else lua_pushliteral(L, "float");
  } else {
    luaL_checkany(L, 1);
    lua_pushnil(L);
  }

  return 1;
};

const math_fmod = function (L) {
  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {
    let d = lua_tointeger(L, 2);
    /* no special case needed for -1 in javascript */

    if (d === 0) {
      luaL_argerror(L, 2, "zero");
    } else lua_pushinteger(L, lua_tointeger(L, 1) % d | 0);
  } else {
    let a = luaL_checknumber(L, 1);
    let b = luaL_checknumber(L, 2);
    lua_pushnumber(L, a % b);
  }

  return 1;
};

const math_modf = function (L) {
  if (lua_isinteger(L, 1)) {
    lua_settop(L, 1);
    /* number is its own integer part */

    lua_pushnumber(L, 0);
    /* no fractional part */
  } else {
    let n = luaL_checknumber(L, 1);
    let ip = n < 0 ? Math.ceil(n) : Math.floor(n);
    pushnumint(L, ip);
    lua_pushnumber(L, n === ip ? 0 : n - ip);
  }

  return 2;
};

const mathlib = {
  "abs": math_abs,
  "acos": math_acos,
  "asin": math_asin,
  "atan": math_atan,
  "ceil": math_ceil,
  "cos": math_cos,
  "deg": math_deg,
  "exp": math_exp,
  "floor": math_floor,
  "fmod": math_fmod,
  "log": math_log,
  "max": math_max,
  "min": math_min,
  "modf": math_modf,
  "rad": math_rad,
  "random": math_random,
  "randomseed": math_randomseed,
  "sin": math_sin,
  "sqrt": math_sqrt,
  "tan": math_tan,
  "tointeger": math_toint,
  "type": math_type,
  "ult": math_ult
};

const luaopen_math = function (L) {
  luaL_newlib(L, mathlib);
  lua_pushnumber(L, Math.PI);
  lua_setfield(L, -2, to_luastring("pi", true));
  lua_pushnumber(L, Infinity);
  lua_setfield(L, -2, to_luastring("huge", true));
  lua_pushinteger(L, LUA_MAXINTEGER);
  lua_setfield(L, -2, to_luastring("maxinteger", true));
  lua_pushinteger(L, LUA_MININTEGER);
  lua_setfield(L, -2, to_luastring("mininteger", true));
  return 1;
};

module.exports.luaopen_math = luaopen_math;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MASKCALL,
  LUA_MASKCOUNT,
  LUA_MASKLINE,
  LUA_MASKRET,
  LUA_REGISTRYINDEX,
  LUA_TFUNCTION,
  LUA_TNIL,
  LUA_TTABLE,
  LUA_TUSERDATA,
  lua_Debug,
  lua_call,
  lua_checkstack,
  lua_gethook,
  lua_gethookcount,
  lua_gethookmask,
  lua_getinfo,
  lua_getlocal,
  lua_getmetatable,
  lua_getstack,
  lua_getupvalue,
  lua_getuservalue,
  lua_insert,
  lua_iscfunction,
  lua_isfunction,
  lua_isnoneornil,
  lua_isthread,
  lua_newtable,
  lua_pcall,
  lua_pop,
  lua_pushboolean,
  lua_pushfstring,
  lua_pushinteger,
  lua_pushlightuserdata,
  lua_pushliteral,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_rawgetp,
  lua_rawsetp,
  lua_rotate,
  lua_setfield,
  lua_sethook,
  lua_setlocal,
  lua_setmetatable,
  lua_settop,
  lua_setupvalue,
  lua_setuservalue,
  lua_tojsstring,
  lua_toproxy,
  lua_tostring,
  lua_tothread,
  lua_touserdata,
  lua_type,
  lua_upvalueid,
  lua_upvaluejoin,
  lua_xmove
} = __webpack_require__(2);

const {
  luaL_argcheck,
  luaL_argerror,
  luaL_checkany,
  luaL_checkinteger,
  luaL_checkstring,
  luaL_checktype,
  luaL_error,
  luaL_loadbuffer,
  luaL_newlib,
  luaL_optinteger,
  luaL_optstring,
  luaL_traceback,
  lua_writestringerror
} = __webpack_require__(8);

const lualib = __webpack_require__(18);

const {
  luastring_indexOf,
  to_luastring
} = __webpack_require__(6);
/*
** If L1 != L, L1 can be in any state, and therefore there are no
** guarantees about its stack space; any push in L1 must be
** checked.
*/


const checkstack = function (L, L1, n) {
  if (L !== L1 && !lua_checkstack(L1, n)) luaL_error(L, to_luastring("stack overflow", true));
};

const db_getregistry = function (L) {
  lua_pushvalue(L, LUA_REGISTRYINDEX);
  return 1;
};

const db_getmetatable = function (L) {
  luaL_checkany(L, 1);

  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    /* no metatable */
  }

  return 1;
};

const db_setmetatable = function (L) {
  const t = lua_type(L, 2);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table expected");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
  /* return 1st argument */
};

const db_getuservalue = function (L) {
  if (lua_type(L, 1) !== LUA_TUSERDATA) lua_pushnil(L);else lua_getuservalue(L, 1);
  return 1;
};

const db_setuservalue = function (L) {
  luaL_checktype(L, 1, LUA_TUSERDATA);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_setuservalue(L, 1);
  return 1;
};
/*
** Auxiliary function used by several library functions: check for
** an optional thread as function's first argument and set 'arg' with
** 1 if this argument is present (so that functions can skip it to
** access their other arguments)
*/


const getthread = function (L) {
  if (lua_isthread(L, 1)) {
    return {
      arg: 1,
      thread: lua_tothread(L, 1)
    };
  } else {
    return {
      arg: 0,
      thread: L
    };
    /* function will operate over current thread */
  }
};
/*
** Variations of 'lua_settable', used by 'db_getinfo' to put results
** from 'lua_getinfo' into result table. Key is always a string;
** value can be a string, an int, or a boolean.
*/


const settabss = function (L, k, v) {
  lua_pushstring(L, v);
  lua_setfield(L, -2, k);
};

const settabsi = function (L, k, v) {
  lua_pushinteger(L, v);
  lua_setfield(L, -2, k);
};

const settabsb = function (L, k, v) {
  lua_pushboolean(L, v);
  lua_setfield(L, -2, k);
};
/*
** In function 'db_getinfo', the call to 'lua_getinfo' may push
** results on the stack; later it creates the result table to put
** these objects. Function 'treatstackoption' puts the result from
** 'lua_getinfo' on top of the result table so that it can call
** 'lua_setfield'.
*/


const treatstackoption = function (L, L1, fname) {
  if (L == L1) lua_rotate(L, -2, 1);
  /* exchange object and table */
  else lua_xmove(L1, L, 1);
  /* move object to the "main" stack */

  lua_setfield(L, -2, fname);
  /* put object into table */
};
/*
** Calls 'lua_getinfo' and collects all results in a new table.
** L1 needs stack space for an optional input (function) plus
** two optional outputs (function and line table) from function
** 'lua_getinfo'.
*/


const db_getinfo = function (L) {
  let ar = new lua_Debug();
  let thread = getthread(L);
  let arg = thread.arg;
  let L1 = thread.thread;
  let options = luaL_optstring(L, arg + 2, "flnStu");
  checkstack(L, L1, 3);

  if (lua_isfunction(L, arg + 1)) {
    /* info about a function? */
    options = lua_pushfstring(L, to_luastring(">%s"), options);
    /* add '>' to 'options' */

    lua_pushvalue(L, arg + 1);
    /* move function to 'L1' stack */

    lua_xmove(L, L1, 1);
  } else {
    /* stack level */
    if (!lua_getstack(L1, luaL_checkinteger(L, arg + 1), ar)) {
      lua_pushnil(L);
      /* level out of range */

      return 1;
    }
  }

  if (!lua_getinfo(L1, options, ar)) luaL_argerror(L, arg + 2, "invalid option");
  lua_newtable(L);
  /* table to collect results */

  if (luastring_indexOf(options, 83
  /* 'S'.charCodeAt(0) */
  ) > -1) {
    settabss(L, to_luastring("source", true), ar.source);
    settabss(L, to_luastring("short_src", true), ar.short_src);
    settabsi(L, to_luastring("linedefined", true), ar.linedefined);
    settabsi(L, to_luastring("lastlinedefined", true), ar.lastlinedefined);
    settabss(L, to_luastring("what", true), ar.what);
  }

  if (luastring_indexOf(options, 108
  /* 'l'.charCodeAt(0) */
  ) > -1) settabsi(L, to_luastring("currentline", true), ar.currentline);

  if (luastring_indexOf(options, 117
  /* 'u'.charCodeAt(0) */
  ) > -1) {
    settabsi(L, to_luastring("nups", true), ar.nups);
    settabsi(L, to_luastring("nparams", true), ar.nparams);
    settabsb(L, to_luastring("isvararg", true), ar.isvararg);
  }

  if (luastring_indexOf(options, 110
  /* 'n'.charCodeAt(0) */
  ) > -1) {
    settabss(L, to_luastring("name", true), ar.name);
    settabss(L, to_luastring("namewhat", true), ar.namewhat);
  }

  if (luastring_indexOf(options, 116
  /* 't'.charCodeAt(0) */
  ) > -1) settabsb(L, to_luastring("istailcall", true), ar.istailcall);
  if (luastring_indexOf(options, 76
  /* 'L'.charCodeAt(0) */
  ) > -1) treatstackoption(L, L1, to_luastring("activelines", true));
  if (luastring_indexOf(options, 102
  /* 'f'.charCodeAt(0) */
  ) > -1) treatstackoption(L, L1, to_luastring("func", true));
  return 1;
  /* return table */
};

const db_getlocal = function (L) {
  let thread = getthread(L);
  let L1 = thread.thread;
  let arg = thread.arg;
  let ar = new lua_Debug();
  let nvar = luaL_checkinteger(L, arg + 2);
  /* local-variable index */

  if (lua_isfunction(L, arg + 1)) {
    lua_pushvalue(L, arg + 1);
    /* push function */

    lua_pushstring(L, lua_getlocal(L, null, nvar));
    /* push local name */

    return 1;
    /* return only name (there is no value) */
  } else {
    /* stack-level argument */
    let level = luaL_checkinteger(L, arg + 1);
    if (!lua_getstack(L1, level, ar))
      /* out of range? */
      return luaL_argerror(L, arg + 1, "level out of range");
    checkstack(L, L1, 1);
    let name = lua_getlocal(L1, ar, nvar);

    if (name) {
      lua_xmove(L1, L, 1);
      /* move local value */

      lua_pushstring(L, name);
      /* push name */

      lua_rotate(L, -2, 1);
      /* re-order */

      return 2;
    } else {
      lua_pushnil(L);
      /* no name (nor value) */

      return 1;
    }
  }
};

const db_setlocal = function (L) {
  let thread = getthread(L);
  let L1 = thread.thread;
  let arg = thread.arg;
  let ar = new lua_Debug();
  let level = luaL_checkinteger(L, arg + 1);
  let nvar = luaL_checkinteger(L, arg + 2);
  if (!lua_getstack(L1, level, ar))
    /* out of range? */
    return luaL_argerror(L, arg + 1, "level out of range");
  luaL_checkany(L, arg + 3);
  lua_settop(L, arg + 3);
  checkstack(L, L1, 1);
  lua_xmove(L, L1, 1);
  let name = lua_setlocal(L1, ar, nvar);
  if (name === null) lua_pop(L1, 1);
  /* pop value (if not popped by 'lua_setlocal') */

  lua_pushstring(L, name);
  return 1;
};
/*
** get (if 'get' is true) or set an upvalue from a closure
*/


const auxupvalue = function (L, get) {
  let n = luaL_checkinteger(L, 2);
  /* upvalue index */

  luaL_checktype(L, 1, LUA_TFUNCTION);
  /* closure */

  let name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
  if (name === null) return 0;
  lua_pushstring(L, name);
  lua_insert(L, -(get + 1));
  /* no-op if get is false */

  return get + 1;
};

const db_getupvalue = function (L) {
  return auxupvalue(L, 1);
};

const db_setupvalue = function (L) {
  luaL_checkany(L, 3);
  return auxupvalue(L, 0);
};
/*
** Check whether a given upvalue from a given closure exists and
** returns its index
*/


const checkupval = function (L, argf, argnup) {
  let nup = luaL_checkinteger(L, argnup);
  /* upvalue index */

  luaL_checktype(L, argf, LUA_TFUNCTION);
  /* closure */

  luaL_argcheck(L, lua_getupvalue(L, argf, nup) !== null, argnup, "invalid upvalue index");
  return nup;
};

const db_upvalueid = function (L) {
  let n = checkupval(L, 1, 2);
  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
  return 1;
};

const db_upvaluejoin = function (L) {
  let n1 = checkupval(L, 1, 2);
  let n2 = checkupval(L, 3, 4);
  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
  lua_upvaluejoin(L, 1, n1, 3, n2);
  return 0;
};
/*
** The hook table at registry[HOOKKEY] maps threads to their current
** hook function. (We only need the unique address of 'HOOKKEY'.)
*/


const HOOKKEY = to_luastring("__hooks__", true);
const hooknames = ["call", "return", "line", "count", "tail call"].map(e => to_luastring(e));
/*
** Call hook function registered at hook table for the current
** thread (if there is one)
*/

const hookf = function (L, ar) {
  lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);
  let hooktable = lua_touserdata(L, -1);
  let proxy = hooktable.get(L);

  if (proxy) {
    /* is there a hook function? */
    proxy(L);
    lua_pushstring(L, hooknames[ar.event]);
    /* push event name */

    if (ar.currentline >= 0) lua_pushinteger(L, ar.currentline);
    /* push current line */
    else lua_pushnil(L);
    lualib.lua_assert(lua_getinfo(L, to_luastring("lS"), ar));
    lua_call(L, 2, 0);
    /* call hook function */
  }
};
/*
** Convert a string mask (for 'sethook') into a bit mask
*/


const makemask = function (smask, count) {
  let mask = 0;
  if (luastring_indexOf(smask, 99
  /* 'c'.charCodeAt(0) */
  ) > -1) mask |= LUA_MASKCALL;
  if (luastring_indexOf(smask, 114
  /* 'r'.charCodeAt(0) */
  ) > -1) mask |= LUA_MASKRET;
  if (luastring_indexOf(smask, 108
  /* 'l'.charCodeAt(0) */
  ) > -1) mask |= LUA_MASKLINE;
  if (count > 0) mask |= LUA_MASKCOUNT;
  return mask;
};
/*
** Convert a bit mask (for 'gethook') into a string mask
*/


const unmakemask = function (mask, smask) {
  let i = 0;
  if (mask & LUA_MASKCALL) smask[i++] = 99
  /* 'c'.charCodeAt(0) */
  ;
  if (mask & LUA_MASKRET) smask[i++] = 114
  /* 'r'.charCodeAt(0) */
  ;
  if (mask & LUA_MASKLINE) smask[i++] = 108
  /* 'l'.charCodeAt(0) */
  ;
  return smask.subarray(0, i);
};

const db_sethook = function (L) {
  let mask, count, func;
  let thread = getthread(L);
  let L1 = thread.thread;
  let arg = thread.arg;

  if (lua_isnoneornil(L, arg + 1)) {
    /* no hook? */
    lua_settop(L, arg + 1);
    func = null;
    mask = 0;
    count = 0;
    /* turn off hooks */
  } else {
    const smask = luaL_checkstring(L, arg + 2);
    luaL_checktype(L, arg + 1, LUA_TFUNCTION);
    count = luaL_optinteger(L, arg + 3, 0);
    func = hookf;
    mask = makemask(smask, count);
  }
  /* as weak tables are not supported; use a JS weak-map */


  let hooktable;

  if (lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY) === LUA_TNIL) {
    hooktable = new WeakMap();
    lua_pushlightuserdata(L, hooktable);
    lua_rawsetp(L, LUA_REGISTRYINDEX, HOOKKEY);
    /* set it in position */
  } else {
    hooktable = lua_touserdata(L, -1);
  }

  let proxy = lua_toproxy(L, arg + 1);
  /* value (hook function) */

  hooktable.set(L1, proxy);
  lua_sethook(L1, func, mask, count);
  return 0;
};

const db_gethook = function (L) {
  let thread = getthread(L);
  let L1 = thread.thread;
  let buff = new Uint8Array(5);
  let mask = lua_gethookmask(L1);
  let hook = lua_gethook(L1);
  if (hook === null)
    /* no hook? */
    lua_pushnil(L);else if (hook !== hookf)
    /* external hook? */
    lua_pushliteral(L, "external hook");else {
    /* hook table must exist */
    lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);
    let hooktable = lua_touserdata(L, -1);
    let proxy = hooktable.get(L1);
    proxy(L);
  }
  lua_pushstring(L, unmakemask(mask, buff));
  /* 2nd result = mask */

  lua_pushinteger(L, lua_gethookcount(L1));
  /* 3rd result = count */

  return 3;
};

const db_traceback = function (L) {
  let thread = getthread(L);
  let L1 = thread.thread;
  let arg = thread.arg;
  let msg = lua_tostring(L, arg + 1);
  if (msg === null && !lua_isnoneornil(L, arg + 1))
    /* non-string 'msg'? */
    lua_pushvalue(L, arg + 1);
    /* return it untouched */
  else {
      let level = luaL_optinteger(L, arg + 2, L === L1 ? 1 : 0);
      luaL_traceback(L, L1, msg, level);
    }
  return 1;
};

const dblib = {
  "gethook": db_gethook,
  "getinfo": db_getinfo,
  "getlocal": db_getlocal,
  "getmetatable": db_getmetatable,
  "getregistry": db_getregistry,
  "getupvalue": db_getupvalue,
  "getuservalue": db_getuservalue,
  "sethook": db_sethook,
  "setlocal": db_setlocal,
  "setmetatable": db_setmetatable,
  "setupvalue": db_setupvalue,
  "setuservalue": db_setuservalue,
  "traceback": db_traceback,
  "upvalueid": db_upvalueid,
  "upvaluejoin": db_upvaluejoin
};
let getinput;

if (false) {} else if (typeof window !== "undefined") {
  /* if in browser use window.prompt. Doesn't work from web workers.
     See https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt
  */
  getinput = function () {
    let input = prompt("lua_debug>", "");
    return input !== null ? input : "";
  };
}

if (getinput) {
  dblib.debug = function (L) {
    for (;;) {
      let input = getinput();
      if (input === "cont") return 0;
      if (input.length === 0) continue;
      let buffer = to_luastring(input);

      if (luaL_loadbuffer(L, buffer, buffer.length, to_luastring("=(debug command)", true)) || lua_pcall(L, 0, 0, 0)) {
        lua_writestringerror(lua_tojsstring(L, -1), "\n");
      }

      lua_settop(L, 0);
      /* remove eventual returns */
    }
  };
}

const luaopen_debug = function (L) {
  luaL_newlib(L, dblib);
  return 1;
};

module.exports.luaopen_debug = luaopen_debug;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_DIRSEP,
  LUA_EXEC_DIR,
  LUA_JSPATH_DEFAULT,
  LUA_PATH_DEFAULT,
  LUA_PATH_MARK,
  LUA_PATH_SEP
} = __webpack_require__(4);

const {
  LUA_OK,
  LUA_REGISTRYINDEX,
  LUA_TNIL,
  LUA_TTABLE,
  lua_callk,
  lua_createtable,
  lua_getfield,
  lua_insert,
  lua_isfunction,
  lua_isnil,
  lua_isstring,
  lua_newtable,
  lua_pop,
  lua_pushboolean,
  lua_pushcclosure,
  lua_pushcfunction,
  lua_pushfstring,
  lua_pushglobaltable,
  lua_pushlightuserdata,
  lua_pushliteral,
  lua_pushlstring,
  lua_pushnil,
  lua_pushstring,
  lua_pushvalue,
  lua_rawgeti,
  lua_rawgetp,
  lua_rawseti,
  lua_rawsetp,
  lua_remove,
  lua_setfield,
  lua_setmetatable,
  lua_settop,
  lua_toboolean,
  lua_tostring,
  lua_touserdata,
  lua_upvalueindex
} = __webpack_require__(2);

const {
  LUA_LOADED_TABLE,
  LUA_PRELOAD_TABLE,
  luaL_Buffer,
  luaL_addvalue,
  luaL_buffinit,
  luaL_checkstring,
  luaL_error,
  luaL_getsubtable,
  luaL_gsub,
  luaL_len,
  luaL_loadfile,
  luaL_newlib,
  luaL_optstring,
  luaL_pushresult,
  luaL_setfuncs
} = __webpack_require__(8);

const lualib = __webpack_require__(18);

const {
  luastring_indexOf,
  to_jsstring,
  to_luastring,
  to_uristring
} = __webpack_require__(6);

const fengari = __webpack_require__(29);

const global_env = function () {
  if (false) {} else if (typeof window !== "undefined") {
    /* browser window */
    return window;
  } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
    /* web worker */
    return self;
  } else {
    /* unknown global env */
    return (0, eval)('this');
    /* use non-strict mode to get global env */
  }
}();

const JSLIBS = to_luastring("__JSLIBS__");
const LUA_PATH_VAR = "LUA_PATH";
const LUA_JSPATH_VAR = "LUA_JSPATH";
const LUA_IGMARK = "-";
/*
** LUA_CSUBSEP is the character that replaces dots in submodule names
** when searching for a JS loader.
** LUA_LSUBSEP is the character that replaces dots in submodule names
** when searching for a Lua loader.
*/

const LUA_CSUBSEP = LUA_DIRSEP;
const LUA_LSUBSEP = LUA_DIRSEP;
/* prefix for open functions in JS libraries */

const LUA_POF = to_luastring("luaopen_");
/* separator for open functions in JS libraries */

const LUA_OFSEP = to_luastring("_");
const LIB_FAIL = "open";
const AUXMARK = to_luastring("\x01");
/*
** load JS library in file 'path'. If 'seeglb', load with all names in
** the library global.
** Returns the library; in case of error, returns NULL plus an
** error string in the stack.
*/

let lsys_load;

if (true) {
  lsys_load = function (L, path, seeglb) {
    path = to_uristring(path);
    let xhr = new XMLHttpRequest();
    xhr.open("GET", path, false);
    xhr.send();

    if (xhr.status < 200 || xhr.status >= 300) {
      lua_pushstring(L, to_luastring(`${xhr.status}: ${xhr.statusText}`));
      return null;
    }

    let code = xhr.response;
    /* Add sourceURL comment to get path in debugger+tracebacks */

    if (!/\/\/[#@] sourceURL=/.test(code)) code += " //# sourceURL=" + path;
    let func;

    try {
      func = Function("fengari", code);
    } catch (e) {
      lua_pushstring(L, to_luastring(`${e.name}: ${e.message}`));
      return null;
    }

    let res = func(fengari);

    if (typeof res === "function" || typeof res === "object" && res !== null) {
      return res;
    } else if (res === void 0) {
      /* assume library added symbols to global environment */
      return global_env;
    } else {
      lua_pushstring(L, to_luastring(`library returned unexpected type (${typeof res})`));
      return null;
    }
  };
} else {}
/*
** Try to find a function named 'sym' in library 'lib'.
** Returns the function; in case of error, returns NULL plus an
** error string in the stack.
*/


const lsys_sym = function (L, lib, sym) {
  let f = lib[to_jsstring(sym)];
  if (f && typeof f === 'function') return f;else {
    lua_pushfstring(L, to_luastring("undefined symbol: %s"), sym);
    return null;
  }
};
/*
** return registry.LUA_NOENV as a boolean
*/


const noenv = function (L) {
  lua_getfield(L, LUA_REGISTRYINDEX, to_luastring("LUA_NOENV"));
  let b = lua_toboolean(L, -1);
  lua_pop(L, 1);
  /* remove value */

  return b;
};

let readable;

if (false) {} else {
  readable = function (path) {
    path = to_uristring(path);
    let xhr = new XMLHttpRequest();
    /* Following GET request done by searcher_Web will be cached */

    xhr.open("GET", path, false);
    xhr.send();
    return xhr.status >= 200 && xhr.status <= 299;
  };
}
/* error codes for 'lookforfunc' */


const ERRLIB = 1;
const ERRFUNC = 2;
/*
** Look for a C function named 'sym' in a dynamically loaded library
** 'path'.
** First, check whether the library is already loaded; if not, try
** to load it.
** Then, if 'sym' is '*', return true (as library has been loaded).
** Otherwise, look for symbol 'sym' in the library and push a
** C function with that symbol.
** Return 0 and 'true' or a function in the stack; in case of
** errors, return an error code and an error message in the stack.
*/

const lookforfunc = function (L, path, sym) {
  let reg = checkjslib(L, path);
  /* check loaded JS libraries */

  if (reg === null) {
    /* must load library? */
    reg = lsys_load(L, path, sym[0] === '*'.charCodeAt(0));
    /* a global symbols if 'sym'=='*' */

    if (reg === null) return ERRLIB;
    /* unable to load library */

    addtojslib(L, path, reg);
  }

  if (sym[0] === '*'.charCodeAt(0)) {
    /* loading only library (no function)? */
    lua_pushboolean(L, 1);
    /* return 'true' */

    return 0;
    /* no errors */
  } else {
    let f = lsys_sym(L, reg, sym);
    if (f === null) return ERRFUNC;
    /* unable to find function */

    lua_pushcfunction(L, f);
    /* else create new function */

    return 0;
    /* no errors */
  }
};

const ll_loadlib = function (L) {
  let path = luaL_checkstring(L, 1);
  let init = luaL_checkstring(L, 2);
  let stat = lookforfunc(L, path, init);
  if (stat === 0)
    /* no errors? */
    return 1;
    /* return the loaded function */
  else {
      /* error; error message is on stack top */
      lua_pushnil(L);
      lua_insert(L, -2);
      lua_pushliteral(L, stat === ERRLIB ? LIB_FAIL : "init");
      return 3;
      /* return nil, error message, and where */
    }
};

const env = function () {
  if (false) {} else {
    return global_env;
  }
}();
/*
** Set a path
*/


const setpath = function (L, fieldname, envname, dft) {
  let nver = `${envname}${lualib.LUA_VERSUFFIX}`;
  lua_pushstring(L, to_luastring(nver));
  let path = env[nver];
  /* use versioned name */

  if (path === undefined)
    /* no environment variable? */
    path = env[envname];
  /* try unversioned name */

  if (path === undefined || noenv(L))
    /* no environment variable? */
    lua_pushstring(L, dft);
    /* use default */
  else {
      /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
      path = luaL_gsub(L, to_luastring(path), to_luastring(LUA_PATH_SEP + LUA_PATH_SEP, true), to_luastring(LUA_PATH_SEP + to_jsstring(AUXMARK) + LUA_PATH_SEP, true));
      luaL_gsub(L, path, AUXMARK, dft);
      lua_remove(L, -2);
      /* remove result from 1st 'gsub' */
    }
  lua_setfield(L, -3, fieldname);
  /* package[fieldname] = path value */

  lua_pop(L, 1);
  /* pop versioned variable name */
};
/*
** return registry.JSLIBS[path]
*/


const checkjslib = function (L, path) {
  lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);
  lua_getfield(L, -1, path);
  let plib = lua_touserdata(L, -1);
  /* plib = JSLIBS[path] */

  lua_pop(L, 2);
  /* pop JSLIBS table and 'plib' */

  return plib;
};
/*
** registry.JSLIBS[path] = plib        -- for queries
** registry.JSLIBS[#JSLIBS + 1] = plib  -- also keep a list of all libraries
*/


const addtojslib = function (L, path, plib) {
  lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);
  lua_pushlightuserdata(L, plib);
  lua_pushvalue(L, -1);
  lua_setfield(L, -3, path);
  /* JSLIBS[path] = plib */

  lua_rawseti(L, -2, luaL_len(L, -2) + 1);
  /* JSLIBS[#JSLIBS + 1] = plib */

  lua_pop(L, 1);
  /* pop JSLIBS table */
};

const pushnexttemplate = function (L, path) {
  while (path[0] === LUA_PATH_SEP.charCodeAt(0)) path = path.subarray(1);
  /* skip separators */


  if (path.length === 0) return null;
  /* no more templates */

  let l = luastring_indexOf(path, LUA_PATH_SEP.charCodeAt(0));
  /* find next separator */

  if (l < 0) l = path.length;
  lua_pushlstring(L, path, l);
  /* template */

  return path.subarray(l);
};

const searchpath = function (L, name, path, sep, dirsep) {
  let msg = new luaL_Buffer();
  /* to build error message */

  luaL_buffinit(L, msg);
  if (sep[0] !== 0)
    /* non-empty separator? */
    name = luaL_gsub(L, name, sep, dirsep);
  /* replace it by 'dirsep' */

  while ((path = pushnexttemplate(L, path)) !== null) {
    let filename = luaL_gsub(L, lua_tostring(L, -1), to_luastring(LUA_PATH_MARK, true), name);
    lua_remove(L, -2);
    /* remove path template */

    if (readable(filename))
      /* does file exist and is readable? */
      return filename;
    /* return that file name */

    lua_pushfstring(L, to_luastring("\n\tno file '%s'"), filename);
    lua_remove(L, -2);
    /* remove file name */

    luaL_addvalue(msg);
  }

  luaL_pushresult(msg);
  /* create error message */

  return null;
  /* not found */
};

const ll_searchpath = function (L) {
  let f = searchpath(L, luaL_checkstring(L, 1), luaL_checkstring(L, 2), luaL_optstring(L, 3, "."), luaL_optstring(L, 4, LUA_DIRSEP));
  if (f !== null) return 1;else {
    /* error message is on top of the stack */
    lua_pushnil(L);
    lua_insert(L, -2);
    return 2;
    /* return nil + error message */
  }
};

const findfile = function (L, name, pname, dirsep) {
  lua_getfield(L, lua_upvalueindex(1), pname);
  let path = lua_tostring(L, -1);
  if (path === null) luaL_error(L, to_luastring("'package.%s' must be a string"), pname);
  return searchpath(L, name, path, to_luastring("."), dirsep);
};

const checkload = function (L, stat, filename) {
  if (stat) {
    /* module loaded successfully? */
    lua_pushstring(L, filename);
    /* will be 2nd argument to module */

    return 2;
    /* return open function and file name */
  } else return luaL_error(L, to_luastring("error loading module '%s' from file '%s':\n\t%s"), lua_tostring(L, 1), filename, lua_tostring(L, -1));
};

const searcher_Lua = function (L) {
  let name = luaL_checkstring(L, 1);
  let filename = findfile(L, name, to_luastring("path", true), to_luastring(LUA_LSUBSEP, true));
  if (filename === null) return 1;
  /* module not found in this path */

  return checkload(L, luaL_loadfile(L, filename) === LUA_OK, filename);
};
/*
** Try to find a load function for module 'modname' at file 'filename'.
** First, change '.' to '_' in 'modname'; then, if 'modname' has
** the form X-Y (that is, it has an "ignore mark"), build a function
** name "luaopen_X" and look for it. (For compatibility, if that
** fails, it also tries "luaopen_Y".) If there is no ignore mark,
** look for a function named "luaopen_modname".
*/


const loadfunc = function (L, filename, modname) {
  let openfunc;
  modname = luaL_gsub(L, modname, to_luastring("."), LUA_OFSEP);
  let mark = luastring_indexOf(modname, LUA_IGMARK.charCodeAt(0));

  if (mark >= 0) {
    openfunc = lua_pushlstring(L, modname, mark);
    openfunc = lua_pushfstring(L, to_luastring("%s%s"), LUA_POF, openfunc);
    let stat = lookforfunc(L, filename, openfunc);
    if (stat !== ERRFUNC) return stat;
    modname = mark + 1;
    /* else go ahead and try old-style name */
  }

  openfunc = lua_pushfstring(L, to_luastring("%s%s"), LUA_POF, modname);
  return lookforfunc(L, filename, openfunc);
};

const searcher_C = function (L) {
  let name = luaL_checkstring(L, 1);
  let filename = findfile(L, name, to_luastring("jspath", true), to_luastring(LUA_CSUBSEP, true));
  if (filename === null) return 1;
  /* module not found in this path */

  return checkload(L, loadfunc(L, filename, name) === 0, filename);
};

const searcher_Croot = function (L) {
  let name = luaL_checkstring(L, 1);
  let p = luastring_indexOf(name, '.'.charCodeAt(0));
  let stat;
  if (p < 0) return 0;
  /* is root */

  lua_pushlstring(L, name, p);
  let filename = findfile(L, lua_tostring(L, -1), to_luastring("jspath", true), to_luastring(LUA_CSUBSEP, true));
  if (filename === null) return 1;
  /* root not found */

  if ((stat = loadfunc(L, filename, name)) !== 0) {
    if (stat != ERRFUNC) return checkload(L, 0, filename);
    /* real error */
    else {
        /* open function not found */
        lua_pushstring(L, to_luastring("\n\tno module '%s' in file '%s'"), name, filename);
        return 1;
      }
  }

  lua_pushstring(L, filename);
  /* will be 2nd argument to module */

  return 2;
};

const searcher_preload = function (L) {
  let name = luaL_checkstring(L, 1);
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
  if (lua_getfield(L, -1, name) === LUA_TNIL)
    /* not found? */
    lua_pushfstring(L, to_luastring("\n\tno field package.preload['%s']"), name);
  return 1;
};

const findloader = function (L, name, ctx, k) {
  let msg = new luaL_Buffer();
  /* to build error message */

  luaL_buffinit(L, msg);
  /* push 'package.searchers' to index 3 in the stack */

  if (lua_getfield(L, lua_upvalueindex(1), to_luastring("searchers", true)) !== LUA_TTABLE) luaL_error(L, to_luastring("'package.searchers' must be a table"));
  let ctx2 = {
    name: name,
    i: 1,
    msg: msg,
    ctx: ctx,
    k: k
  };
  return findloader_cont(L, LUA_OK, ctx2);
};

const findloader_cont = function (L, status, ctx) {
  /*  iterate over available searchers to find a loader */
  for (;; ctx.i++) {
    if (status === LUA_OK) {
      if (lua_rawgeti(L, 3, ctx.i) === LUA_TNIL) {
        /* no more searchers? */
        lua_pop(L, 1);
        /* remove nil */

        luaL_pushresult(ctx.msg);
        /* create error message */

        luaL_error(L, to_luastring("module '%s' not found:%s"), ctx.name, lua_tostring(L, -1));
      }

      lua_pushstring(L, ctx.name);
      lua_callk(L, 1, 2, ctx, findloader_cont);
      /* call it */
    } else {
      status = LUA_OK;
    }

    if (lua_isfunction(L, -2))
      /* did it find a loader? */
      break;
      /* module loader found */
    else if (lua_isstring(L, -2)) {
        /* searcher returned error message? */
        lua_pop(L, 1);
        /* remove extra return */

        luaL_addvalue(ctx.msg);
        /* concatenate error message */
      } else lua_pop(L, 2);
    /* remove both returns */
  }

  return ctx.k(L, LUA_OK, ctx.ctx);
};

const ll_require = function (L) {
  let name = luaL_checkstring(L, 1);
  lua_settop(L, 1);
  /* LOADED table will be at index 2 */

  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_getfield(L, 2, name);
  /* LOADED[name] */

  if (lua_toboolean(L, -1))
    /* is it there? */
    return 1;
  /* package is already loaded */

  /* else must load package */

  lua_pop(L, 1);
  /* remove 'getfield' result */

  let ctx = name;
  return findloader(L, name, ctx, ll_require_cont);
};

const ll_require_cont = function (L, status, ctx) {
  let name = ctx;
  lua_pushstring(L, name);
  /* pass name as argument to module loader */

  lua_insert(L, -2);
  /* name is 1st argument (before search data) */

  lua_callk(L, 2, 1, ctx, ll_require_cont2);
  return ll_require_cont2(L, LUA_OK, ctx);
  /* run loader to load module */
};

const ll_require_cont2 = function (L, status, ctx) {
  let name = ctx;
  if (!lua_isnil(L, -1))
    /* non-nil return? */
    lua_setfield(L, 2, name);
  /* LOADED[name] = returned value */

  if (lua_getfield(L, 2, name) == LUA_TNIL) {
    /* module set no value? */
    lua_pushboolean(L, 1);
    /* use true as result */

    lua_pushvalue(L, -1);
    /* extra copy to be returned */

    lua_setfield(L, 2, name);
    /* LOADED[name] = true */
  }

  return 1;
};

const pk_funcs = {
  "loadlib": ll_loadlib,
  "searchpath": ll_searchpath
};
const ll_funcs = {
  "require": ll_require
};

const createsearcherstable = function (L) {
  let searchers = [searcher_preload, searcher_Lua, searcher_C, searcher_Croot, null];
  /* create 'searchers' table */

  lua_createtable(L);
  /* fill it with predefined searchers */

  for (let i = 0; searchers[i]; i++) {
    lua_pushvalue(L, -2);
    /* set 'package' as upvalue for all searchers */

    lua_pushcclosure(L, searchers[i], 1);
    lua_rawseti(L, -2, i + 1);
  }

  lua_setfield(L, -2, to_luastring("searchers", true));
  /* put it in field 'searchers' */
};
/*
** create table JSLIBS to keep track of loaded JS libraries,
** setting a finalizer to close all libraries when closing state.
*/


const createjslibstable = function (L) {
  lua_newtable(L);
  /* create JSLIBS table */

  lua_createtable(L, 0, 1);
  /* create metatable for JSLIBS */

  lua_setmetatable(L, -2);
  lua_rawsetp(L, LUA_REGISTRYINDEX, JSLIBS);
  /* set JSLIBS table in registry */
};

const luaopen_package = function (L) {
  createjslibstable(L);
  luaL_newlib(L, pk_funcs);
  /* create 'package' table */

  createsearcherstable(L);
  /* set paths */

  setpath(L, to_luastring("path", true), LUA_PATH_VAR, LUA_PATH_DEFAULT);
  setpath(L, to_luastring("jspath", true), LUA_JSPATH_VAR, LUA_JSPATH_DEFAULT);
  /* store config information */

  lua_pushliteral(L, LUA_DIRSEP + "\n" + LUA_PATH_SEP + "\n" + LUA_PATH_MARK + "\n" + LUA_EXEC_DIR + "\n" + LUA_IGMARK + "\n");
  lua_setfield(L, -2, to_luastring("config", true));
  /* set field 'loaded' */

  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_setfield(L, -2, to_luastring("loaded", true));
  /* set field 'preload' */

  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
  lua_setfield(L, -2, to_luastring("preload", true));
  lua_pushglobaltable(L);
  lua_pushvalue(L, -2);
  /* set 'package' as upvalue for next lib */

  luaL_setfuncs(L, ll_funcs, 1);
  /* open lib into global table */

  lua_pop(L, 1);
  /* pop global table */

  return 1;
  /* return 'package' table */
};

module.exports.luaopen_package = luaopen_package;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

const {
  lua_pushinteger,
  lua_pushliteral,
  lua_setfield
} = __webpack_require__(2);

const {
  luaL_newlib
} = __webpack_require__(8);

const {
  FENGARI_AUTHORS,
  FENGARI_COPYRIGHT,
  FENGARI_RELEASE,
  FENGARI_VERSION,
  FENGARI_VERSION_MAJOR,
  FENGARI_VERSION_MINOR,
  FENGARI_VERSION_NUM,
  FENGARI_VERSION_RELEASE,
  to_luastring
} = __webpack_require__(6);

const luaopen_fengari = function (L) {
  luaL_newlib(L, {});
  lua_pushliteral(L, FENGARI_AUTHORS);
  lua_setfield(L, -2, to_luastring("AUTHORS"));
  lua_pushliteral(L, FENGARI_COPYRIGHT);
  lua_setfield(L, -2, to_luastring("COPYRIGHT"));
  lua_pushliteral(L, FENGARI_RELEASE);
  lua_setfield(L, -2, to_luastring("RELEASE"));
  lua_pushliteral(L, FENGARI_VERSION);
  lua_setfield(L, -2, to_luastring("VERSION"));
  lua_pushliteral(L, FENGARI_VERSION_MAJOR);
  lua_setfield(L, -2, to_luastring("VERSION_MAJOR"));
  lua_pushliteral(L, FENGARI_VERSION_MINOR);
  lua_setfield(L, -2, to_luastring("VERSION_MINOR"));
  lua_pushinteger(L, FENGARI_VERSION_NUM);
  lua_setfield(L, -2, to_luastring("VERSION_NUM"));
  lua_pushliteral(L, FENGARI_VERSION_RELEASE);
  lua_setfield(L, -2, to_luastring("VERSION_RELEASE"));
  return 1;
};

module.exports.luaopen_fengari = luaopen_fengari;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

const {
  lua,
  lauxlib,
  lualib,
  to_luastring
} = __webpack_require__(29);

const binary = __webpack_require__(3);

const isUtf8 = __webpack_require__(28);
/**
 * Interop module to help encoding and decoding data to and from Lua/JavaScript.
 */


const interop = {
  /**
   * Pushes the given data into the Lua VM, encoding into the appropriate type.
   *
   * @param {lua_State} vm Lua VM state
   * @param {any} val Any data object
   */
  push(vm, val) {
    switch (typeof val) {
      case 'undefined':
        lua.lua_pushnil(vm);
        break;

      case 'boolean':
        lua.lua_pushboolean(vm, val);
        break;

      case 'number':
        lua.lua_pushnumber(vm, val);
        break;

      case 'string':
        lua.lua_pushstring(vm, to_luastring(val));
        break;

      case 'symbol':
        lua.lua_pushlightuserdata(vm, val);
        break;

      case 'function':
        if (val instanceof LuaProxy) {
          this.push(vm, this.wrap(val));
        } else {
          lua.lua_pushjsfunction(vm, val);
        }

        break;

      case 'object':
      default:
        if (val === null) {
          lua.lua_pushnil(vm);
          break;
        }

        if (binary.is(val)) {
          lua.lua_pushstring(vm, val);
          break;
        }

        if (val instanceof JSProxy) {
          const d = lua.lua_newuserdata(vm);
          d.data = val.data;
          break;
        }

        this.pushTable(vm, val);
        break;
    }
  },

  /**
   * Pushes the given Array, Map or Object into the Lua VM, encoded as a lua Table.
   *
   * @param {lua_State} vm Lua VM state
   * @param {Array|Map|Object} val Data object
   */
  pushTable(vm, val) {
    lua.lua_createtable(vm, 0, 0);
    const base = lua.lua_gettop(vm);

    if (Array.isArray(val)) {
      val.forEach((v, i) => {
        this.pushTableField(vm, i + 1, v);
        lua.lua_settop(vm, base);
      });
    } else if (val instanceof Map) {
      for (let [k, v] of val) {
        this.pushTableField(vm, k, v);
        lua.lua_settop(vm, base);
      }
    } else {
      for (let k in val) {
        this.pushTableField(vm, k, val[k]);
        lua.lua_settop(vm, base);
      }
    }
  },

  /**
   * Pushes the given data into the Lua VM as a table field at the given path.
   *
   * @param {lua_State} vm Lua VM state
   * @param {String} key Table field name
   * @param {any} val Any data object
   */
  pushTableField(vm, key, val) {
    this.push(vm, val);

    if (Number.isInteger(key)) {
      lua.lua_seti(vm, -2, key);
    } else {
      lua.lua_setfield(vm, -2, to_luastring(key));
    }
  },

  /**
   * Gets the data from the Lua VM stack at the given index, and returns a
   * decoded JavaScript object.
   *
   * @param {lua_State} vm Lua VM state
   * @param {Integer} i Lua stack index
   * @return {any}
   */
  tojs(vm, i) {
    const type = lua.lua_type(vm, i);

    switch (type) {
      case lua.LUA_TNONE:
        // -1
        return void 0;

      case lua.LUA_TNIL:
        // 0
        return null;

      case lua.LUA_TBOOLEAN:
        // 1
        return lua.lua_toboolean(vm, i);

      case lua.LUA_TLIGHTUSERDATA:
        // 2
        return lua.lua_touserdata(vm, i);

      case lua.LUA_TNUMBER:
        // 3
        return lua.lua_tonumber(vm, i);

      case lua.LUA_TSTRING:
        // 4
        let buf = lua.lua_tolstring(vm, i);
        if (!binary.is(buf)) buf = binary.from(buf);
        return isUtf8(buf) ? binary.to(buf) : buf;

      case lua.LUA_TTABLE:
        // 5
        return this.toMap(vm, lua.lua_toproxy(vm, i));

      case lua.LUA_TFUNCTION:
        // 6
        return this.toFunction(vm, lua.lua_toproxy(vm, i));

      case lua.LUA_TUSERDATA:
        // 7
        let u = lua.lua_touserdata(vm, i);
        return u ? u.data : void 0;

      case lua.LUA_TTHREAD: // 8

      /* fall through */

      default:
        return lua.lua_toproxy(vm, i);
    }
  },

  /**
   * Converts the given Lua proxy into a JavaScript Map.
   *
   * @param {lua_State} vm Lua VM state
   * @param proxy Lua proxy object
   * @return {Map}
   */
  toMap(vm, proxy) {
    // get main thread
    lua.lua_rawgeti(vm, lua.LUA_REGISTRYINDEX, lua.LUA_RIDX_MAINTHREAD);
    const L = lua.lua_tothread(vm, -1);
    lua.lua_pop(vm, 1);
    const js = {};

    if (typeof Symbol === 'function') {
      js[Symbol.iterator] = _ => jsiterator(L, proxy);
    } // Build map


    const map = new Map();

    for (let [k, v] of js) {
      map.set(k, v);
    } // Convert to array if all keys are integers


    if (Array.from(map.keys()).every(Number.isInteger)) {
      return Array.from(map.keys()).sort().map(k => map.get(k));
    }

    return map;
  },

  /**
   * Converts the given Lua proxy into a JavaScript Function.
   *
   * @param {lua_State} vm Lua VM state
   * @param proxy Lua proxy object
   * @return {Function}
   */
  toFunction(vm, proxy) {
    // get main thread
    lua.lua_rawgeti(vm, lua.LUA_REGISTRYINDEX, lua.LUA_RIDX_MAINTHREAD);
    const L = lua.lua_tothread(vm, -1);
    lua.lua_pop(vm, 1);
    return new LuaProxy(L, proxy);
  },

  /**
   * Wraps the given data so it will not be encoded for Lua.
   *
   * @param any data Any data
   * @return JSProxy
   */
  wrap(data) {
    return new JSProxy(data);
  }

};
/**
 * Wraps any arbirary JavaScript value in a proxy before pushing into the Lua
 * state. No encoding or decoding occurs, so if/when the proxy is passed back
 * the JavaScript the original value is preserved.
 * @ignore
 */

function JSProxy(val) {
  this.data = val;
}
/**
 * Wraps a Lua function in a proxy so it can be invoked from JavaScript.
 * @ignore
 */


function LuaProxy(vm, proxy) {
  const fn = (...args) => invokeAsync(vm, proxy, args);

  Object.setPrototypeOf(fn, LuaProxy.prototype);

  fn.invoke = (...args) => invoke(vm, proxy, args);

  fn.invokeAsync = (...args) => invokeAsync(vm, proxy, args);

  fn.proxy = proxy;
  return fn;
}
/**
 * Invokes a Lua function synchronously.
 * @ignore
 */


const invoke = function (L, proxy, args) {
  const base = lua.lua_gettop(L);
  proxy(L);
  lauxlib.luaL_checkstack(L, args.length, null);
  args.forEach(a => interop.push(L, a));

  switch (lua.lua_pcall(L, args.length, lua.LUA_MULTRET, 0)) {
    case lua.LUA_OK:
      let nres = lua.lua_gettop(L) - base;
      let res = [];

      for (let i = 0; i < nres; i++) {
        res[i] = interop.tojs(L, base + i + 1);
      }

      lua.lua_settop(L, base);
      return nres > 1 ? res : res[0];

    default:
      let err = interop.tojs(L, -1);
      lua.lua_settop(L, base);
      throw new Error(`Lua Error: ${err}`);
  }
};
/**
 * Invokes a Lua function asynchronously.
 * @ignore
 */


const invokeAsync = async function (L, proxy, args) {
  const base = lua.lua_gettop(L);
  lua.lua_getglobal(L, to_luastring('coroutine'));
  lua.lua_getfield(L, -1, to_luastring('create'));
  proxy(L);
  lua.lua_pcall(L, 1, 1, 0);
  const vm = lua.lua_tothread(L, -1);
  lua.lua_settop(L, base);
  return new Promise((resolve, reject) => {
    lauxlib.luaL_checkstack(vm, args.length, null);
    args.forEach(a => interop.push(vm, a));
    lua.lua_resume(vm, null, args.length);

    const pollThread = function (time) {
      const status = lua.lua_status(vm);

      switch (status) {
        case lua.LUA_YIELD:
          setTimeout(pollThread);
          break;

        case lua.LUA_OK:
          let nres = lua.lua_gettop(vm);
          let res = [];

          for (let i = 0; i < nres; i++) {
            res[i] = interop.tojs(vm, -nres + i);
          }

          lua.lua_settop(vm, base);
          resolve(nres > 1 ? res : res[0]);
          break;

        default:
          const err = interop.tojs(vm, -1);
          lua.lua_settop(vm, base);
          reject(new Error(`Lua Error: ${err}`));
          break;
      }
    };

    setTimeout(pollThread);
  });
};
/**
 * The following functions are extracted from fengari-interop
 * https://github.com/fengari-lua/fengari-interop
 * - jsiterator()
 * - iter_next()
 * @copyright Copyright (c) 2017-2019 Daurnimator
 */

/* make iteration use pairs() */


const jsiterator = function (L, p) {
  lauxlib.luaL_checkstack(L, 1, null);
  lua.lua_pushcfunction(L, function (L) {
    lauxlib.luaL_requiref(L, to_luastring("_G"), lualib.luaopen_base, 0);
    lua.lua_getfield(L, -1, to_luastring("pairs"));
    p(L);
    lua.lua_call(L, 1, 3);
    return 3;
  });

  switch (lua.lua_pcall(L, 0, lua.LUA_MULTRET, 0)) {
    case lua.LUA_OK:
      {
        let iter = lua.lua_toproxy(L, -3);
        let state = lua.lua_toproxy(L, -2);
        let last = lua.lua_toproxy(L, -1);
        lua.lua_pop(L, 3);
        return {
          L: L,
          iter: iter,
          state: state,
          last: last,
          next: iter_next
        };
      }

    default:
      {
        let r = interop.tojs(L, -1);
        lua.lua_pop(L, 1);
        throw r;
      }
  }
};
/* implements lua's "Generic For" protocol */


const iter_next = function () {
  let L = this.L;
  lauxlib.luaL_checkstack(L, 3, null);
  let top = lua.lua_gettop(L);
  this.iter(L);
  this.state(L);
  this.last(L);

  switch (lua.lua_pcall(L, 2, lua.LUA_MULTRET, 0)) {
    case lua.LUA_OK:
      {
        this.last = lua.lua_toproxy(L, top + 1);
        let r;

        if (lua.lua_isnil(L, -1)) {
          r = {
            done: true,
            value: void 0
          };
        } else {
          let n_results = lua.lua_gettop(L) - top;
          let result = new Array(n_results);

          for (let i = 0; i < n_results; i++) {
            result[i] = interop.tojs(L, top + i + 1);
          }

          r = {
            done: false,
            value: result
          };
        }

        lua.lua_settop(L, top);
        return r;
      }

    default:
      {
        let e = interop.tojs(L, -1);
        lua.lua_pop(L, 1);
        throw e;
      }
  }
};

module.exports = interop;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

const Bob = __webpack_require__(85);

const OpApi = __webpack_require__(86);

const NoCache = __webpack_require__(87);

const allowedKeys = ['tape_adapter', 'op_adapter', 'cache', 'extensions', 'aliases', 'strict'];
const defaultAliases = {
  'meta': 'ec869026',
  // Metanet
  '15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva': 'a3a83843',
  // AIP
  '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut': '6232de04',
  // B://
  '13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC': 'a575f641',
  // Bitkey
  '1L8eNuA8ToLGK5aV4d5d9rXUAbRZUxKrhF': 'c8bca1c8',
  // Bit.sv
  '1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3': 'ed469ce8',
  // HAIP
  '1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5': 'b7f56e90',
  // MAP
  '19dbzMDDg4jZ4pvYzLb291nT8uCqDa61zH': '5ad609a8',
  // Preev
  '1LtyME6b5AnMopQrBPLk4FGN8UBuhxKqrn': '5ad609a8' // WeatherSV

};
/**
 * Agent configuration.
 */

const config = {
  tape_adapter: Bob,
  op_adapter: OpApi,
  cache: NoCache,
  extensions: [],
  aliases: {},
  strict: true,

  /**
   * Merges the given attributes with the config.
   *
   * @param {Object} opts Options
   * @return {this}
   */
  update(opts = {}) {
    Object.keys(opts).filter(k => allowedKeys.includes(k)).forEach(k => {
      this[k] = opts[k];
    });
    return this;
  },

  /**
   * Apply default aliases for common Bitcom protocols
   *
   * @return {this}
   */
  quickStartAliases() {
    Object.keys(defaultAliases).forEach(k => {
      this.aliases[k] = this.aliases[k] || defaultAliases[k];
    });
    return this;
  }

};
module.exports = config;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ref: https://github.com/tc39/proposal-global

var getGlobal = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  throw new Error('unable to locate global object');
};

var global = getGlobal();
module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

exports.default = global.fetch.bind(global);
exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

const Agent = __webpack_require__(50);

const config = __webpack_require__(46);

const util = __webpack_require__(24);

const pkg = __webpack_require__(89);
/**
 * Load and run Operate programs (known as "tapes") encoded in Bitcoin SV
 * transactions.
 *
 * Operate is a toolset to help developers build applications, games and
 * services on top of Bitcoin (SV). It lets you write functions, called "Ops",
 * and enables transactions to become small but powerful programs, capable of
 * delivering new classes of services layered over Bitcoin.
 *
 * @class
 * @hideconstructor
 */


class Operate {
  /** 
   * Loads a tape from the given txid.
   *
   * Fetches the tape transaction output as well as all of the required
   * functions, and returns a Promise.
   *
   * Any configuration option can be overridden.
   *
   * @param {String} txid Transaction id
   * @param {Object} opts Options
   * @return {Promise(Tape)}
   */
  static loadTape(txid, opts = {}) {
    return new Agent(opts).loadTape(txid);
  }
  /** 
   * Loads a tape from the given query.
   *
   * The expected format of the query will depend on the Adapter in use.
   * The transactions as well as all required functions are loaded and a Proise
   * is returned resolving in a list of Tapes.
   *
   * Any configuration option can be overridden.
   *
   * @param {Object} query Query object
   * @param {Object} opts Options
   * @return {Promise(Array)}
   */


  static loadTapesBy(query, opts = {}) {
    return new Agent(opts).loadTapesBy(query);
  }
  /**
   * Runs the given tape executing each of the tape's cells and returns Tape.
   *
   * @param {Tape} tape Tape instance
   * @param {Object} opts Options
   * @return {Promise(any)}
   */


  static runTape(tape, opts = {}) {
    return new Agent(opts).runTape(tape, opts);
  }

}
/**
 * Returns the Agent class.
 * @static
 */


Operate.Agent = Agent;
/**
 * Returns the config.
 * @static
 */

Operate.config = config;
/**
 * Returns the util helper module.
 * @static
 */

Operate.util = util;
/**
 * Returns version number.
 * @static
 */

Operate.version = pkg.version;
module.exports = Operate;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

const Adapter = __webpack_require__(27);

const Tape = __webpack_require__(51);

const VM = __webpack_require__(63);

const defaultConfig = __webpack_require__(46);
/**
 * The Agent module responsible for loading and running tapes.
 *
 * @class
 */


class Agent {
  /**
   * Creates an Agent instance.
   *
   * @param {Object} opts Configuration options
   * @return {Agent}
   */
  constructor(opts = {}) {
    this.config = { ...defaultConfig,
      ...opts
    };
  }
  /**
   * Loads a tape from the given txid.
   *
   * Fetches the tape transaction output as well as all of the required
   * functions, and returns a Promise.
   *
   * @param {String} txid Transaction id
   * @param {Object} opts Options
   * @return {Promise(Tape)}
   */


  async loadTape(txid, opts = {}) {
    const config = { ...this.config,
      ...opts
    };
    let index;
    [txid, index] = txid.split('/');

    const [cache, cacheConfig] = this._adapterWithOpts(config.cache);

    const adapter = this._adapterWithOpts(config.tape_adapter);

    const tx = await cache.fetchTx(txid, cacheConfig, adapter);
    return await this._prepTape(tx, index, config);
  }
  /**
   * Loads a tape from the given query.
   *
   * The expected format of the query will depend on the Adapter in use.
   * The transactions as well as all required functions are loaded and a Promise
   * is returned resolving in a list of Tapes.
   *
   * @param {Object} query Query object
   * @param {Object} opts Options
   * @return {Promise(Array)}
   */


  async loadTapesBy(query, opts = {}) {
    const config = { ...this.config,
      ...opts
    };

    const [cache, cacheConfig] = this._adapterWithOpts(config.cache);

    const adapter = this._adapterWithOpts(config.tape_adapter);

    const txns = await cache.fetchTxBy(query, cacheConfig, adapter);
    return await this._prepTapes(txns, config);
  }
  /**
   * Runs the given tape executing each of the tape's cells and returns a tape.
   *
   * @param {Tape} tape Tape instance
   * @return {Promise(any)}
   */


  async runTape(tape, opts = {}) {
    const config = { ...this.config,
      ...opts
    };
    const vm = new VM({
      agent: this,
      extensions: config.extensions
    }),
          state = config.state,
          execOpts = {
      state,
      strict: config.strict
    };
    return await tape.run(vm, execOpts);
  }
  /**
   * Takes a transaction, loads its required Ops and returns a tape.
   * @private
   */


  async _prepTape(tx, index, opts = {}) {
    const config = { ...this.config,
      ...opts
    };
    let tape;

    try {
      tape = Tape.fromBPU(tx, index);
      const refs = tape.getOpRefs(config.aliases);

      let [cache, cacheConfig] = this._adapterWithOpts(config.cache);

      const adapter = this._adapterWithOpts(config.op_adapter);

      const ops = await cache.fetchOps(refs, cacheConfig, adapter);
      tape.setCellOps(ops, config.aliases);
    } catch (error) {
      if (this.config.strict) throw error;
    }

    return tape;
  }
  /**
   * Iterates over an array of transactions, preparing each and returns an array
   * of tapes.
   * @private
   */


  async _prepTapes(txns, opts = {}) {
    const config = { ...this.config,
      ...opts
    };
    let tape;
    const tapes = [];

    for (let i = 0; i < txns.length; i++) {
      tape = await this._prepTape(txns[i], undefined, config);
      if (tape) tapes.push(tape);
    }

    return tapes;
  }
  /**
   * Returns the adapter and options in a tuple pair.
   * @private
   */


  _adapterWithOpts(adapter) {
    return Array.isArray(adapter) ? adapter : [adapter, {}];
  }

}

module.exports = Agent;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

const Cell = __webpack_require__(52);
/**
 * Class for working with Operate tapes.
 *
 * An Operate program is a tape made up of one or more cells, where each cell
 * contains a single atomic procedure call (known as an "Op").
 *
 * When a tape is run, each cell is executed in turn, with the result from each
 * cell is passed to the next cell. This is known as the "state". Each cell
 * returns a new state, until the final cell in the tape returns the result of
 * the tape.
 *
 * @class
 */


class Tape {
  /**
   * Creates a Tape instance.
   *
   * @param {Object} attrs Attributes
   * @return {Tape}
   */
  constructor(attrs = {}) {
    this.tx = attrs.tx;
    this.index = attrs.index;
    this.cells = attrs.cells || [];
    this.result = null;
    this.error = null;
  }
  /**
   * Converts the given BPU Transaction into an Operate Tape.
   *
   * @static
   * @param {Object} attrs BPU Transaction
   * @return {Tape}
   */


  static fromBPU(tx, index) {
    if (typeof index === 'undefined' || index === null) {
      const i = tx.out.findIndex(o => this._isOpReturnOutput(o));
      return this.fromBPU(tx, i);
    }

    let cells;

    if (index > -1 && tx.out[index] && this._isOpReturnOutput(tx.out[index])) {
      cells = tx.out[index].tape.filter(c => !this._isOpReturnCell(c)).map(c => Cell.fromBPU(c));
    } else {
      throw new Error('No tape found in transaction.');
    }

    return new this({
      tx,
      index,
      cells
    });
  }
  /**
   * Runs the tape in the given VM state.
   *
   * @param {VM} vm VM state
   * @param {Object} opts Options
   * @return {Promise(any)}
   */


  async run(vm, opts = {}) {
    const state = opts.state,
          strict = typeof opts.strict === 'undefined' ? true : opts.strict;
    vm.set('ctx.tx', this.tx || null);
    vm.set('ctx.tape_index', this.index || 0);
    const result = await this.cells.reduce(async (prevState, cell) => {
      const state = await prevState;
      return cell.exec(vm, {
        state
      }).catch(e => {
        if (strict) {
          this.error = e;
          throw e;
        } else {
          return state;
        }
      });
    }, Promise.resolve(state));
    this.result = result;
    return result;
  }
  /**
   * Sets the given Ops into the cells of the tape. If an aliases object is
   * specifed, this is used to reverse map any procedure scripts onto aliased
   * cells.
   *
   * @param {Array} ops Op functions
   * @param {Object} aliases Aliases
   * @return {Tape}
   */


  setCellOps(ops, aliases = {}) {
    ops.forEach(op => {
      const refs = Object.keys(aliases).filter(k => aliases[k] === op.ref);
      if (!refs.length) refs.push(op.ref);
      this.cells.forEach(cell => {
        if (refs.includes(cell.ref)) cell.op = op.fn;
      });
      return this;
    });
  }
  /**
   * Returns a list of Op references from the tape's cells. If an aliases object
   * is specifed, this is used to alias references to alternative values.
   *
   * @param {Object} aliases Aliases
   * @return {Array}
   */


  getOpRefs(aliases = {}) {
    return this.cells.map(c => c.ref).filter((v, i, a) => a.indexOf(v) === i).map(ref => aliases[ref] || ref);
  }
  /**
   * Validates the given tape. Returns true if all the tape's cells are valid.
   * @return {Boolean}
   */


  get isValid() {
    return this.cells.every(c => c.isValid);
  }
  /**
   * Returns true if the BPU Script is an OP_RETURN script.
   * @private
   */


  static _isOpReturnOutput({
    tape
  }) {
    return this._isOpReturnCell(tape[0]);
  }
  /**
   * Returns true if the BPU Cell is an OP_RETURN cell.
   * @private
   */


  static _isOpReturnCell({
    cell
  }) {
    return cell.some(c => c.op === 106);
  }

}

module.exports = Tape;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const isUtf8 = __webpack_require__(28);
/**
 * Class for working with Operate tape cells.
 *
 * A cell represents a single atomic procedure call. A Cell contains the Op
 * script and parameters. When the cell is executed it returns a result.
 *
 * @class
 */


class Cell {
  /**
   * Creates a Cell instance.
   *
   * @param {Object} attrs Attributes
   * @return {Cell}
   */
  constructor(attrs = {}) {
    this.ref = attrs.ref;
    this.params = attrs.params || [];
    this.op = attrs.op;
    this.index = attrs.index;
    this.dataIndex = attrs.dataIndex;
  }
  /**
   * Converts the given BPU Cell into an Operate Cell.
   *
   * @static
   * @param {Object} attrs BPU Cell
   * @return {Cell}
   */


  static fromBPU({
    cell,
    i
  }) {
    const head = cell.shift(),
          ref = this._decodeRef(head),
          params = cell.map(c => this._normalizeParam(c));

    return new this({
      ref,
      params,
      index: i,
      dataIndex: head.ii
    });
  }
  /**
   * Executes the Cell in the given VM state.
   *
   * @param {VM} vm VM state
   * @param {Object} opts Options
   * @return {Promise(any)}
   */


  async exec(vm, opts = {}) {
    //if (!this.isValid) throw new Error('Cannot execute invalid cell.');
    if (this.index) vm.set('ctx.cell_index', this.index);
    if (this.dataIndex) vm.set('ctx.data_index', this.dataIndex);
    return vm.eval(this.op).invokeAsync(opts.state, ...this.params);
  }
  /**
   * Validates the given cell. Returns true if the cell has a reference and
   * script.
   *
   * @return {Boolean}
   */


  get isValid() {
    return ['ref', 'op'].every(a => this[a] && this[a].length);
  }
  /**
   * Normalizes the reference. Handles decoding if it is in raw binary.
   * @private
   */


  static _decodeRef({
    b
  }) {
    // TODO - in future use h attribute of BOB2
    const buf = binary.from(b, 'base64');

    if (buf.length === 4 && binary.to(buf) !== 'meta') {
      return binary.to(buf, 'hex');
    } else {
      return binary.to(buf);
    }
  }
  /**
   * Normalizes the cell param.
   * @private
   */


  static _normalizeParam({
    b,
    lb
  }) {
    let data = lb || b;

    if (data) {
      const buf = binary.from(data, 'base64');
      return isUtf8(buf) ? binary.to(buf) : buf;
    }
  }

}

module.exports = Cell;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = from;

var base64 = __webpack_require__(31);

var decoders = {
  hex: from_hex,
  utf8: from_utf,
  base64: from_base64
};

function from(source, encoding) {
  if (Array.isArray(source)) {
    return new Uint8Array(source);
  }

  return decoders[encoding || 'utf8'](source);
}

function from_hex(str) {
  var size = str.length / 2,
      buf = new Uint8Array(size),
      character = '';

  for (var i = 0, len = str.length; i < len; ++i) {
    character += str.charAt(i);

    if (i > 0 && i % 2 === 1) {
      buf[i >>> 1] = parseInt(character, 16);
      character = '';
    }
  }

  return buf;
}

function from_utf(str) {
  var arr = [],
      code;

  for (var i = 0, len = str.length; i < len; ++i) {
    code = fixed_cca(str, i);

    if (code === false) {
      continue;
    }

    if (code < 0x80) {
      arr[arr.length] = code;
      continue;
    }

    codepoint_to_bytes(arr, code);
  }

  return new Uint8Array(arr);
}

function codepoint_to_bytes(arr, code) {
  // find MSB, use that to determine byte count
  var copy_code = code,
      bit_count = 0,
      byte_count,
      prefix,
      _byte,
      pos;

  do {
    ++bit_count;
  } while (copy_code >>>= 1);

  byte_count = Math.ceil((bit_count - 1) / 5) | 0;
  prefix = [0, 0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc][byte_count];
  pos = [0, 0, 3, 4, 5, 6, 7][byte_count];
  _byte |= prefix;
  bit_count = 7 - pos + 6 * (byte_count - 1);

  while (bit_count) {
    _byte |= +!!(code & 1 << bit_count) << 7 - pos;
    ++pos;

    if (pos % 8 === 0) {
      arr[arr.length] = _byte;
      _byte = 0x80;
      pos = 2;
    }

    --bit_count;
  }

  if (pos) {
    _byte |= +!!(code & 1) << 7 - pos;
    arr[arr.length] = _byte;
  }
}

function pad(str) {
  while (str.length < 8) {
    str = '0' + str;
  }

  return str;
}

function fixed_cca(str, idx) {
  idx = idx || 0;
  var code = str.charCodeAt(idx),
      lo,
      hi;

  if (0xD800 <= code && code <= 0xDBFF) {
    lo = str.charCodeAt(idx + 1);
    hi = code;

    if (isNaN(lo)) {
      throw new Error('High surrogate not followed by low surrogate');
    }

    return (hi - 0xD800) * 0x400 + (lo - 0xDC00) + 0x10000;
  }

  if (0xDC00 <= code && code <= 0xDFFF) {
    return false;
  }

  return code;
}

function from_base64(str) {
  return new Uint8Array(base64.toByteArray(str));
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = to;

var base64 = __webpack_require__(31),
    toutf8 = __webpack_require__(55);

var encoders = {
  hex: to_hex,
  utf8: to_utf,
  base64: to_base64
};

function to(buf, encoding) {
  return encoders[encoding || 'utf8'](buf);
}

function to_hex(buf) {
  var str = '',
      byt;

  for (var i = 0, len = buf.length; i < len; ++i) {
    byt = buf[i];
    str += ((byt & 0xF0) >>> 4).toString(16);
    str += (byt & 0x0F).toString(16);
  }

  return str;
}

function to_utf(buf) {
  return toutf8(buf);
}

function to_base64(buf) {
  return base64.fromByteArray(buf);
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = to_utf8;
var out = [],
    col = [],
    fcc = String.fromCharCode,
    mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01],
    unmask = [0x00, 0x01, 0x02 | 0x01, 0x04 | 0x02 | 0x01, 0x08 | 0x04 | 0x02 | 0x01, 0x10 | 0x08 | 0x04 | 0x02 | 0x01, 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01, 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01];

function to_utf8(bytes, start, end) {
  start = start === undefined ? 0 : start;
  end = end === undefined ? bytes.length : end;
  var idx = 0,
      hi = 0x80,
      collecting = 0,
      pos,
      by;
  col.length = out.length = 0;

  while (idx < bytes.length) {
    by = bytes[idx];

    if (!collecting && by & hi) {
      pos = find_pad_position(by);
      collecting += pos;

      if (pos < 8) {
        col[col.length] = by & unmask[6 - pos];
      }
    } else if (collecting) {
      col[col.length] = by & unmask[6];
      --collecting;

      if (!collecting && col.length) {
        out[out.length] = fcc(reduced(col, pos));
        col.length = 0;
      }
    } else {
      out[out.length] = fcc(by);
    }

    ++idx;
  }

  if (col.length && !collecting) {
    out[out.length] = fcc(reduced(col, pos));
    col.length = 0;
  }

  return out.join('');
}

function find_pad_position(byt) {
  for (var i = 0; i < 7; ++i) {
    if (!(byt & mask[i])) {
      break;
    }
  }

  return i;
}

function reduced(list) {
  var out = 0;

  for (var i = 0, len = list.length; i < len; ++i) {
    out |= list[i] << (len - i - 1) * 6;
  }

  return out;
}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function (buffer) {
  return buffer instanceof Uint8Array;
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = subarray;

function subarray(buf, from, to) {
  return buf.subarray(from || 0, to || buf.length);
}

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = join;

function join(targets, hint) {
  if (!targets.length) {
    return new Uint8Array(0);
  }

  var len = hint !== undefined ? hint : get_length(targets),
      out = new Uint8Array(len),
      cur = targets[0],
      curlen = cur.length,
      curidx = 0,
      curoff = 0,
      i = 0;

  while (i < len) {
    if (curoff === curlen) {
      curoff = 0;
      ++curidx;
      cur = targets[curidx];
      curlen = cur && cur.length;
      continue;
    }

    out[i++] = cur[curoff++];
  }

  return out;
}

function get_length(targets) {
  var size = 0;

  for (var i = 0, len = targets.length; i < len; ++i) {
    size += targets[i].byteLength;
  }

  return size;
}

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = copy;
var slice = [].slice;

function copy(source, target, target_start, source_start, source_end) {
  target_start = arguments.length < 3 ? 0 : target_start;
  source_start = arguments.length < 4 ? 0 : source_start;
  source_end = arguments.length < 5 ? source.length : source_end;

  if (source_end === source_start) {
    return;
  }

  if (target.length === 0 || source.length === 0) {
    return;
  }

  if (source_end > source.length) {
    source_end = source.length;
  }

  if (target.length - target_start < source_end - source_start) {
    source_end = target.length - target_start + source_start;
  }

  if (source.buffer !== target.buffer) {
    return fast_copy(source, target, target_start, source_start, source_end);
  }

  return slow_copy(source, target, target_start, source_start, source_end);
}

function fast_copy(source, target, target_start, source_start, source_end) {
  var len = source_end - source_start + target_start;

  for (var i = target_start, j = source_start; i < len; ++i, ++j) {
    target[i] = source[j];
  }
}

function slow_copy(from, to, j, i, jend) {
  // the buffers could overlap.
  var iend = jend + i,
      tmp = new Uint8Array(slice.call(from, i, iend)),
      x = 0;

  for (; i < iend; ++i, ++x) {
    to[j++] = tmp[x];
  }
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function (size) {
  return new Uint8Array(size);
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  readUInt8: read_uint8,
  readInt8: read_int8,
  readUInt16LE: read_uint16_le,
  readUInt32LE: read_uint32_le,
  readInt16LE: read_int16_le,
  readInt32LE: read_int32_le,
  readFloatLE: read_float_le,
  readDoubleLE: read_double_le,
  readUInt16BE: read_uint16_be,
  readUInt32BE: read_uint32_be,
  readInt16BE: read_int16_be,
  readInt32BE: read_int32_be,
  readFloatBE: read_float_be,
  readDoubleBE: read_double_be
};

var map = __webpack_require__(32);

function read_uint8(target, at) {
  return target[at];
}

function read_int8(target, at) {
  var v = target[at];
  return v < 0x80 ? v : v - 0x100;
}

function read_uint16_le(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, true);
}

function read_uint32_le(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, true);
}

function read_int16_le(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, true);
}

function read_int32_le(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, true);
}

function read_float_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, true);
}

function read_double_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, true);
}

function read_uint16_be(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, false);
}

function read_uint32_be(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, false);
}

function read_int16_be(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, false);
}

function read_int32_be(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, false);
}

function read_float_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, false);
}

function read_double_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, false);
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  writeUInt8: write_uint8,
  writeInt8: write_int8,
  writeUInt16LE: write_uint16_le,
  writeUInt32LE: write_uint32_le,
  writeInt16LE: write_int16_le,
  writeInt32LE: write_int32_le,
  writeFloatLE: write_float_le,
  writeDoubleLE: write_double_le,
  writeUInt16BE: write_uint16_be,
  writeUInt32BE: write_uint32_be,
  writeInt16BE: write_int16_be,
  writeInt32BE: write_int32_be,
  writeFloatBE: write_float_be,
  writeDoubleBE: write_double_be
};

var map = __webpack_require__(32);

function write_uint8(target, value, at) {
  return target[at] = value;
}

function write_int8(target, value, at) {
  return target[at] = value < 0 ? value + 0x100 : value;
}

function write_uint16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, true);
}

function write_uint32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, true);
}

function write_int16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, true);
}

function write_int32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, true);
}

function write_float_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, true);
}

function write_double_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, true);
}

function write_uint16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, false);
}

function write_uint32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, false);
}

function write_int16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, false);
}

function write_int32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, false);
}

function write_float_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, false);
}

function write_double_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, false);
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

const {
  lua,
  lauxlib,
  lualib,
  to_luastring
} = __webpack_require__(29);

const interop = __webpack_require__(45);

const defaultExtensions = [__webpack_require__(69), __webpack_require__(70), __webpack_require__(71), __webpack_require__(72), __webpack_require__(84)];
/**
 * Operate VM module. Responsible for initalizing the VM state and evaluating
 * and executing Lua code in the VM.
 *
 * @class
 */

class VM {
  /**
   * Initliazes a new VM state.
   *
   * @return {VM}
   */
  constructor(opts = {}) {
    const extensions = opts.extensions || [];
    this.agent = opts.agent;
    this._vm = lauxlib.luaL_newstate();
    lualib.luaL_openlibs(this._vm);
    defaultExtensions.concat(extensions).forEach(ext => this.extend(ext));
  }
  /**
   * Extends the VM state with the given module or modules.
   *
   * @param {Extension|Array} extension Extension class or array
   * @return {VM}
   */


  extend(extension) {
    if (Array.isArray(extension)) {
      extension.forEach(ext => this.extend(ext));
    }

    extension.extend(this);
    return this;
  }
  /**
   * Returns the value from the specified path on the VM state.
   *
   * @param {String|Array} path Lua path
   * @return {String|Number|Object|Array|Function}
   */


  get(path, opts = {}) {
    if (typeof path === 'string') {
      return this.get(path.split('.'), opts);
    }

    path.forEach((p, i) => {
      let type;

      if (i === 0) {
        type = lua.lua_getglobal(this._vm, to_luastring(p));
      } else {
        type = lua.lua_getfield(this._vm, -1, to_luastring(p));
      }

      if (type < 0) this._throwError();
    });
    return interop.tojs(this._vm, -1);
  }
  /**
   * Sets the value at the specified path on the VM state.
   *
   * @param {String|Array} path Lua path
   * @param {String|Number|Object|Array} value Value
   * @param {Object} opts Options
   * @return {VM}
   */


  set(path, value, opts = {}) {
    if (opts.force) return this.setDeep(path, value);

    if (typeof path === 'string') {
      return this.set(path.split('.'), value);
    }

    path.forEach((p, i) => {
      let type;

      if (i === path.length - 1) {
        if (value && typeof value === 'object' && Object.keys(value).length === 0) {
          lua.lua_createtable(this._vm, 0, 0);
        } else {
          interop.push(this._vm, value);
        }
      }

      if (i === 0) {
        if (path.length === 1) {
          lua.lua_setglobal(this._vm, to_luastring(p));
        } else {
          type = lua.lua_getglobal(this._vm, to_luastring(p));
        }
      } else {
        if (i === path.length - 1) {
          lua.lua_setfield(this._vm, -2, to_luastring(p));
        } else {
          type = lua.lua_getfield(this._vm, -1, to_luastring(p));
        }
      }

      if (i < path.length - 1 && ![5, 7].includes(type)) {
        throw new Error('Invalid Lua path.');
      } else if (type <= 0) {
        this._throwError();
      }
    });
    lua.lua_settop(this._vm, 0);
    return this;
  }
  /**
   * Sets the value at the specified deeply nested path on the VM state.
   *
   * @param {String|Array} path Lua path
   * @param {String|Number|Object|Array} value Value
   * @return {VM}
   */


  setDeep(path, value) {
    if (typeof path === 'string') {
      return this.setDeep(path.split('.'), value);
    }

    for (const [i, p] of path.entries()) {
      let type;

      if (i === path.length - 1) {
        return this.set(path, value);
      }

      lua.lua_createtable(this._vm, 0, 0);

      if (i === 0) {
        lua.lua_setglobal(this._vm, to_luastring(p));
        type = lua.lua_getglobal(this._vm, to_luastring(p));
      } else if (i < path.length - 1) {
        lua.lua_setfield(this._vm, -2, to_luastring(p));
        type = lua.lua_getfield(this._vm, -1, to_luastring(p));
      }

      if (type <= 0) this._throwError();
    }
  }
  /**
   * Sets a JavaScript function at the specified path on the VM state.
   * Automatically detects if the function is an `AsyncFunction`, and if so
   * handles yielding and resuming from Lua.
   *
   * @param {String|Array} path Lua path
   * @param {Function} callback JavaScript function
   * @param {Object} opts Options
   * @return {VM}
   */


  setFunction(path, callback, opts = {}) {
    this.set(path, function (vm) {
      let nargs = lua.lua_gettop(vm);
      let args = new Array(Math.max(0, nargs));

      if (nargs > 0) {
        for (let i = 0; i < nargs; i++) {
          args[i] = interop.tojs(vm, i + 1);
        }
      } // If AsyncFunction attempt to pause and resume Lua execution


      if (opts.async || callback.constructor.name === 'AsyncFunction') {
        Promise.resolve(callback(...args)).then(r => {
          interop.push(vm, r);
          lua.lua_resume(vm, null, 1);
        }).catch(err => {
          lauxlib.luaL_error(vm, to_luastring(err.message));
        });
        lua.lua_yield(vm, 0); // Otherwise, just call the function
      } else {
        const r = callback(...args);
        interop.push(vm, r);
        return 1;
      }
    }, opts);
    return this;
  }
  /**
   * Evaluates the given script within the VM state and returns the result.
   *
   * @param {String} code Lua code string
   * @return {String|Number|Object|Array|Function}
   */


  eval(code, opts = {}) {
    this.exec(code);
    return interop.tojs(this._vm, -1);
  }
  /**
   * Evaluates the given script within the VM state and returns the modified
   * state.
   *
   * @param {String} code Lua code string
   * @return {VM}
   */


  exec(code) {
    let status;
    lua.lua_settop(this._vm, 0);
    status = lauxlib.luaL_dostring(this._vm, to_luastring(code));
    if (status !== 0) this._throwError();
    return this;
  }
  /**
   * Calls a function within the VM state at the given lua path and returns the
   * result.
   *
   * @param {String|Array} path Lua path
   * @param {Array} args Function arguments
   * @return {String|Number|Object|Array|Function}
   */


  call(path, args = [], opts = {}) {
    if (typeof path === 'string') {
      return this.call(path.split('.'), args);
    }

    let status;
    path.forEach((p, i) => {
      let type,
          _path = to_luastring(p);

      if (i === 0) {
        type = lua.lua_getglobal(this._vm, _path);
      } else {
        type = lua.lua_getfield(this._vm, -1, _path);
      }

      if (type <= 0) this._throwError();
    });
    lauxlib.luaL_checkstack(this._vm, args.length, null);
    args.forEach(a => interop.push(this._vm, a));
    status = lua.lua_pcall(this._vm, args.length, 1, 0);
    if (status !== 0) this._throwError();
    return interop.tojs(this._vm, -1);
  }
  /**
   * Generic error handler
   * @private
   */


  _throwError() {
    const err = lua.lua_tojsstring(this._vm, -1);
    throw new Error(`Lua Error: ${err}`);
  }

}

module.exports = VM;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_MULTRET,
  LUA_OPADD,
  LUA_OPBAND,
  LUA_OPBNOT,
  LUA_OPBOR,
  LUA_OPBXOR,
  LUA_OPDIV,
  LUA_OPIDIV,
  LUA_OPMOD,
  LUA_OPSHL,
  LUA_OPSHR,
  LUA_OPUNM,
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TLIGHTUSERDATA,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TTABLE
  },
  to_luastring
} = __webpack_require__(1);

const {
  lua_assert
} = __webpack_require__(5);

const llex = __webpack_require__(30);

const lobject = __webpack_require__(7);

const lopcodes = __webpack_require__(17);

const lparser = __webpack_require__(34);

const ltable = __webpack_require__(10);

const lvm = __webpack_require__(16);

const OpCodesI = lopcodes.OpCodesI;
const TValue = lobject.TValue;
/* Maximum number of registers in a Lua function (must fit in 8 bits) */

const MAXREGS = 255;
/*
** Marks the end of a patch list. It is an invalid value both as an absolute
** address, and as a list link (would link an element to itself).
*/

const NO_JUMP = -1;
const BinOpr = {
  OPR_ADD: 0,
  OPR_SUB: 1,
  OPR_MUL: 2,
  OPR_MOD: 3,
  OPR_POW: 4,
  OPR_DIV: 5,
  OPR_IDIV: 6,
  OPR_BAND: 7,
  OPR_BOR: 8,
  OPR_BXOR: 9,
  OPR_SHL: 10,
  OPR_SHR: 11,
  OPR_CONCAT: 12,
  OPR_EQ: 13,
  OPR_LT: 14,
  OPR_LE: 15,
  OPR_NE: 16,
  OPR_GT: 17,
  OPR_GE: 18,
  OPR_AND: 19,
  OPR_OR: 20,
  OPR_NOBINOPR: 21
};
const UnOpr = {
  OPR_MINUS: 0,
  OPR_BNOT: 1,
  OPR_NOT: 2,
  OPR_LEN: 3,
  OPR_NOUNOPR: 4
};

const hasjumps = function (e) {
  return e.t !== e.f;
};
/*
** If expression is a numeric constant returns either true or a new TValue
** (depending on 'make_tvalue'). Otherwise, returns false.
*/


const tonumeral = function (e, make_tvalue) {
  let ek = lparser.expkind;
  if (hasjumps(e)) return false;
  /* not a numeral */

  switch (e.k) {
    case ek.VKINT:
      if (make_tvalue) {
        return new TValue(LUA_TNUMINT, e.u.ival);
      }

      return true;

    case ek.VKFLT:
      if (make_tvalue) {
        return new TValue(LUA_TNUMFLT, e.u.nval);
      }

      return true;

    default:
      return false;
  }
};
/*
** Create a OP_LOADNIL instruction, but try to optimize: if the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/


const luaK_nil = function (fs, from, n) {
  let previous;
  let l = from + n - 1;
  /* last register to set nil */

  if (fs.pc > fs.lasttarget) {
    /* no jumps to current position? */
    previous = fs.f.code[fs.pc - 1];

    if (previous.opcode === OpCodesI.OP_LOADNIL) {
      /* previous is LOADNIL? */
      let pfrom = previous.A;
      /* get previous range */

      let pl = pfrom + previous.B;

      if (pfrom <= from && from <= pl + 1 || from <= pfrom && pfrom <= l + 1) {
        /* can connect both? */
        if (pfrom < from) from = pfrom;
        /* from = min(from, pfrom) */

        if (pl > l) l = pl;
        /* l = max(l, pl) */

        lopcodes.SETARG_A(previous, from);
        lopcodes.SETARG_B(previous, l - from);
        return;
      }
    }
    /* else go through */

  }

  luaK_codeABC(fs, OpCodesI.OP_LOADNIL, from, n - 1, 0);
  /* else no optimization */
};

const getinstruction = function (fs, e) {
  return fs.f.code[e.u.info];
};
/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/


const getjump = function (fs, pc) {
  let offset = fs.f.code[pc].sBx;
  if (offset === NO_JUMP)
    /* point to itself represents end of list */
    return NO_JUMP;
    /* end of list */
  else return pc + 1 + offset;
  /* turn offset into absolute position */
};
/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua)
*/


const fixjump = function (fs, pc, dest) {
  let jmp = fs.f.code[pc];
  let offset = dest - (pc + 1);
  lua_assert(dest !== NO_JUMP);
  if (Math.abs(offset) > lopcodes.MAXARG_sBx) llex.luaX_syntaxerror(fs.ls, to_luastring("control structure too long", true));
  lopcodes.SETARG_sBx(jmp, offset);
};
/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/


const luaK_concat = function (fs, l1, l2) {
  if (l2 === NO_JUMP) return l1;
  /* nothing to concatenate? */
  else if (l1 === NO_JUMP)
      /* no original list? */
      l1 = l2;else {
      let list = l1;
      let next = getjump(fs, list);

      while (next !== NO_JUMP) {
        /* find last element */
        list = next;
        next = getjump(fs, list);
      }

      fixjump(fs, list, l2);
    }
  return l1;
};
/*
** Create a jump instruction and return its position, so its destination
** can be fixed later (with 'fixjump'). If there are jumps to
** this position (kept in 'jpc'), link them all together so that
** 'patchlistaux' will fix all them directly to the final destination.
*/


const luaK_jump = function (fs) {
  let jpc = fs.jpc;
  /* save list of jumps to here */

  fs.jpc = NO_JUMP;
  /* no more jumps to here */

  let j = luaK_codeAsBx(fs, OpCodesI.OP_JMP, 0, NO_JUMP);
  j = luaK_concat(fs, j, jpc);
  /* keep them on hold */

  return j;
};

const luaK_jumpto = function (fs, t) {
  return luaK_patchlist(fs, luaK_jump(fs), t);
};
/*
** Code a 'return' instruction
*/


const luaK_ret = function (fs, first, nret) {
  luaK_codeABC(fs, OpCodesI.OP_RETURN, first, nret + 1, 0);
};
/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/


const condjump = function (fs, op, A, B, C) {
  luaK_codeABC(fs, op, A, B, C);
  return luaK_jump(fs);
};
/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/


const luaK_getlabel = function (fs) {
  fs.lasttarget = fs.pc;
  return fs.pc;
};
/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself if it is
** unconditional.
*/


const getjumpcontroloffset = function (fs, pc) {
  if (pc >= 1 && lopcodes.testTMode(fs.f.code[pc - 1].opcode)) return pc - 1;else return pc;
};

const getjumpcontrol = function (fs, pc) {
  return fs.f.code[getjumpcontroloffset(fs, pc)];
};
/*
** Patch destination register for a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, return 0 ("fails").
** Otherwise, if 'reg' is not 'NO_REG', set it as the destination
** register. Otherwise, change instruction to a simple 'TEST' (produces
** no register value)
*/


const patchtestreg = function (fs, node, reg) {
  let pc = getjumpcontroloffset(fs, node);
  let i = fs.f.code[pc];
  if (i.opcode !== OpCodesI.OP_TESTSET) return false;
  /* cannot patch other instructions */

  if (reg !== lopcodes.NO_REG && reg !== i.B) lopcodes.SETARG_A(i, reg);else {
    /* no register to put value or register already has the value;
       change instruction to simple test */
    fs.f.code[pc] = lopcodes.CREATE_ABC(OpCodesI.OP_TEST, i.B, 0, i.C);
  }
  return true;
};
/*
** Traverse a list of tests ensuring no one produces a value
*/


const removevalues = function (fs, list) {
  for (; list !== NO_JUMP; list = getjump(fs, list)) patchtestreg(fs, list, lopcodes.NO_REG);
};
/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/


const patchlistaux = function (fs, list, vtarget, reg, dtarget) {
  while (list !== NO_JUMP) {
    let next = getjump(fs, list);
    if (patchtestreg(fs, list, reg)) fixjump(fs, list, vtarget);else fixjump(fs, list, dtarget);
    /* jump to default target */

    list = next;
  }
};
/*
** Ensure all pending jumps to current position are fixed (jumping
** to current position with no values) and reset list of pending
** jumps
*/


const dischargejpc = function (fs) {
  patchlistaux(fs, fs.jpc, fs.pc, lopcodes.NO_REG, fs.pc);
  fs.jpc = NO_JUMP;
};
/*
** Add elements in 'list' to list of pending jumps to "here"
** (current position)
*/


const luaK_patchtohere = function (fs, list) {
  luaK_getlabel(fs);
  /* mark "here" as a jump target */

  fs.jpc = luaK_concat(fs, fs.jpc, list);
};
/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/


const luaK_patchlist = function (fs, list, target) {
  if (target === fs.pc)
    /* 'target' is current position? */
    luaK_patchtohere(fs, list);
    /* add list to pending jumps */
  else {
      lua_assert(target < fs.pc);
      patchlistaux(fs, list, target, lopcodes.NO_REG, target);
    }
};
/*
** Path all jumps in 'list' to close upvalues up to given 'level'
** (The assertion checks that jumps either were closing nothing
** or were closing higher levels, from inner blocks.)
*/


const luaK_patchclose = function (fs, list, level) {
  level++;
  /* argument is +1 to reserve 0 as non-op */

  for (; list !== NO_JUMP; list = getjump(fs, list)) {
    let ins = fs.f.code[list];
    lua_assert(ins.opcode === OpCodesI.OP_JMP && (ins.A === 0 || ins.A >= level));
    lopcodes.SETARG_A(ins, level);
  }
};
/*
** Emit instruction 'i', checking for array sizes and saving also its
** line information. Return 'i' position.
*/


const luaK_code = function (fs, i) {
  let f = fs.f;
  dischargejpc(fs);
  /* 'pc' will change */

  /* put new instruction in code array */

  f.code[fs.pc] = i;
  f.lineinfo[fs.pc] = fs.ls.lastline;
  return fs.pc++;
};
/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/


const luaK_codeABC = function (fs, o, a, b, c) {
  lua_assert(lopcodes.getOpMode(o) === lopcodes.iABC);
  lua_assert(lopcodes.getBMode(o) !== lopcodes.OpArgN || b === 0);
  lua_assert(lopcodes.getCMode(o) !== lopcodes.OpArgN || c === 0);
  lua_assert(a <= lopcodes.MAXARG_A && b <= lopcodes.MAXARG_B && c <= lopcodes.MAXARG_C);
  return luaK_code(fs, lopcodes.CREATE_ABC(o, a, b, c));
};
/*
** Format and emit an 'iABx' instruction.
*/


const luaK_codeABx = function (fs, o, a, bc) {
  lua_assert(lopcodes.getOpMode(o) === lopcodes.iABx || lopcodes.getOpMode(o) === lopcodes.iAsBx);
  lua_assert(lopcodes.getCMode(o) === lopcodes.OpArgN);
  lua_assert(a <= lopcodes.MAXARG_A && bc <= lopcodes.MAXARG_Bx);
  return luaK_code(fs, lopcodes.CREATE_ABx(o, a, bc));
};

const luaK_codeAsBx = function (fs, o, A, sBx) {
  return luaK_codeABx(fs, o, A, sBx + lopcodes.MAXARG_sBx);
};
/*
** Emit an "extra argument" instruction (format 'iAx')
*/


const codeextraarg = function (fs, a) {
  lua_assert(a <= lopcodes.MAXARG_Ax);
  return luaK_code(fs, lopcodes.CREATE_Ax(OpCodesI.OP_EXTRAARG, a));
};
/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/


const luaK_codek = function (fs, reg, k) {
  if (k <= lopcodes.MAXARG_Bx) return luaK_codeABx(fs, OpCodesI.OP_LOADK, reg, k);else {
    let p = luaK_codeABx(fs, OpCodesI.OP_LOADKX, reg, 0);
    codeextraarg(fs, k);
    return p;
  }
};
/*
** Check register-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/


const luaK_checkstack = function (fs, n) {
  let newstack = fs.freereg + n;

  if (newstack > fs.f.maxstacksize) {
    if (newstack >= MAXREGS) llex.luaX_syntaxerror(fs.ls, to_luastring("function or expression needs too many registers", true));
    fs.f.maxstacksize = newstack;
  }
};
/*
** Reserve 'n' registers in register stack
*/


const luaK_reserveregs = function (fs, n) {
  luaK_checkstack(fs, n);
  fs.freereg += n;
};
/*
** Free register 'reg', if it is neither a constant index nor
** a local variable.
*/


const freereg = function (fs, reg) {
  if (!lopcodes.ISK(reg) && reg >= fs.nactvar) {
    fs.freereg--;
    lua_assert(reg === fs.freereg);
  }
};
/*
** Free register used by expression 'e' (if any)
*/


const freeexp = function (fs, e) {
  if (e.k === lparser.expkind.VNONRELOC) freereg(fs, e.u.info);
};
/*
** Free registers used by expressions 'e1' and 'e2' (if any) in proper
** order.
*/


const freeexps = function (fs, e1, e2) {
  let r1 = e1.k === lparser.expkind.VNONRELOC ? e1.u.info : -1;
  let r2 = e2.k === lparser.expkind.VNONRELOC ? e2.u.info : -1;

  if (r1 > r2) {
    freereg(fs, r1);
    freereg(fs, r2);
  } else {
    freereg(fs, r2);
    freereg(fs, r1);
  }
};
/*
** Add constant 'v' to prototype's list of constants (field 'k').
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with float
** keys), the caller must provide a useful 'key' for indexing the cache.
*/


const addk = function (fs, key, v) {
  let f = fs.f;
  let idx = ltable.luaH_get(fs.L, fs.ls.h, key);
  /* index scanner table */

  if (idx.ttisinteger()) {
    /* is there an index there? */
    let k = idx.value;
    /* correct value? (warning: must distinguish floats from integers!) */

    if (k < fs.nk && f.k[k].ttype() === v.ttype() && f.k[k].value === v.value) return k;
    /* reuse index */
  }
  /* constant not found; create a new entry */


  let k = fs.nk;
  ltable.luaH_setfrom(fs.L, fs.ls.h, key, new lobject.TValue(LUA_TNUMINT, k));
  f.k[k] = v;
  fs.nk++;
  return k;
};
/*
** Add a string to list of constants and return its index.
*/


const luaK_stringK = function (fs, s) {
  let o = new TValue(LUA_TLNGSTR, s);
  return addk(fs, o, o);
  /* use string itself as key */
};
/*
** Add an integer to list of constants and return its index.
** Integers use userdata as keys to avoid collision with floats with
** same value.
*/


const luaK_intK = function (fs, n) {
  let k = new TValue(LUA_TLIGHTUSERDATA, n);
  let o = new TValue(LUA_TNUMINT, n);
  return addk(fs, k, o);
};
/*
** Add a float to list of constants and return its index.
*/


const luaK_numberK = function (fs, r) {
  let o = new TValue(LUA_TNUMFLT, r);
  return addk(fs, o, o);
  /* use number itself as key */
};
/*
** Add a boolean to list of constants and return its index.
*/


const boolK = function (fs, b) {
  let o = new TValue(LUA_TBOOLEAN, b);
  return addk(fs, o, o);
  /* use boolean itself as key */
};
/*
** Add nil to list of constants and return its index.
*/


const nilK = function (fs) {
  let v = new TValue(LUA_TNIL, null);
  let k = new TValue(LUA_TTABLE, fs.ls.h);
  /* cannot use nil as key; instead use table itself to represent nil */

  return addk(fs, k, v);
};
/*
** Fix an expression to return the number of results 'nresults'.
** Either 'e' is a multi-ret expression (function call or vararg)
** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).
*/


const luaK_setreturns = function (fs, e, nresults) {
  let ek = lparser.expkind;

  if (e.k === ek.VCALL) {
    /* expression is an open function call? */
    lopcodes.SETARG_C(getinstruction(fs, e), nresults + 1);
  } else if (e.k === ek.VVARARG) {
    let pc = getinstruction(fs, e);
    lopcodes.SETARG_B(pc, nresults + 1);
    lopcodes.SETARG_A(pc, fs.freereg);
    luaK_reserveregs(fs, 1);
  } else lua_assert(nresults === LUA_MULTRET);
};

const luaK_setmultret = function (fs, e) {
  luaK_setreturns(fs, e, LUA_MULTRET);
};
/*
** Fix an expression to return one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base register of the call), while vararg expressions
** become VRELOCABLE (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/


const luaK_setoneret = function (fs, e) {
  let ek = lparser.expkind;

  if (e.k === ek.VCALL) {
    /* expression is an open function call? */

    /* already returns 1 value */
    lua_assert(getinstruction(fs, e).C === 2);
    e.k = ek.VNONRELOC;
    /* result has fixed position */

    e.u.info = getinstruction(fs, e).A;
  } else if (e.k === ek.VVARARG) {
    lopcodes.SETARG_B(getinstruction(fs, e), 2);
    e.k = ek.VRELOCABLE;
    /* can relocate its simple result */
  }
};
/*
** Ensure that expression 'e' is not a variable.
*/


const luaK_dischargevars = function (fs, e) {
  let ek = lparser.expkind;

  switch (e.k) {
    case ek.VLOCAL:
      {
        /* already in a register */
        e.k = ek.VNONRELOC;
        /* becomes a non-relocatable value */

        break;
      }

    case ek.VUPVAL:
      {
        /* move value to some (pending) register */
        e.u.info = luaK_codeABC(fs, OpCodesI.OP_GETUPVAL, 0, e.u.info, 0);
        e.k = ek.VRELOCABLE;
        break;
      }

    case ek.VINDEXED:
      {
        let op;
        freereg(fs, e.u.ind.idx);

        if (e.u.ind.vt === ek.VLOCAL) {
          /* is 't' in a register? */
          freereg(fs, e.u.ind.t);
          op = OpCodesI.OP_GETTABLE;
        } else {
          lua_assert(e.u.ind.vt === ek.VUPVAL);
          op = OpCodesI.OP_GETTABUP;
          /* 't' is in an upvalue */
        }

        e.u.info = luaK_codeABC(fs, op, 0, e.u.ind.t, e.u.ind.idx);
        e.k = ek.VRELOCABLE;
        break;
      }

    case ek.VVARARG:
    case ek.VCALL:
      {
        luaK_setoneret(fs, e);
        break;
      }

    default:
      break;

    /* there is one value available (somewhere) */
  }
};

const code_loadbool = function (fs, A, b, jump) {
  luaK_getlabel(fs);
  /* those instructions may be jump targets */

  return luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, A, b, jump);
};
/*
** Ensures expression value is in register 'reg' (and therefore
** 'e' will become a non-relocatable expression).
*/


const discharge2reg = function (fs, e, reg) {
  let ek = lparser.expkind;
  luaK_dischargevars(fs, e);

  switch (e.k) {
    case ek.VNIL:
      {
        luaK_nil(fs, reg, 1);
        break;
      }

    case ek.VFALSE:
    case ek.VTRUE:
      {
        luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, reg, e.k === ek.VTRUE, 0);
        break;
      }

    case ek.VK:
      {
        luaK_codek(fs, reg, e.u.info);
        break;
      }

    case ek.VKFLT:
      {
        luaK_codek(fs, reg, luaK_numberK(fs, e.u.nval));
        break;
      }

    case ek.VKINT:
      {
        luaK_codek(fs, reg, luaK_intK(fs, e.u.ival));
        break;
      }

    case ek.VRELOCABLE:
      {
        let pc = getinstruction(fs, e);
        lopcodes.SETARG_A(pc, reg);
        /* instruction will put result in 'reg' */

        break;
      }

    case ek.VNONRELOC:
      {
        if (reg !== e.u.info) luaK_codeABC(fs, OpCodesI.OP_MOVE, reg, e.u.info, 0);
        break;
      }

    default:
      {
        lua_assert(e.k === ek.VJMP);
        return;
        /* nothing to do... */
      }
  }

  e.u.info = reg;
  e.k = ek.VNONRELOC;
};
/*
** Ensures expression value is in any register.
*/


const discharge2anyreg = function (fs, e) {
  if (e.k !== lparser.expkind.VNONRELOC) {
    /* no fixed register yet? */
    luaK_reserveregs(fs, 1);
    /* get a register */

    discharge2reg(fs, e, fs.freereg - 1);
    /* put value there */
  }
};
/*
** check whether list has any jump that do not produce a value
** or produce an inverted value
*/


const need_value = function (fs, list) {
  for (; list !== NO_JUMP; list = getjump(fs, list)) {
    let i = getjumpcontrol(fs, list);
    if (i.opcode !== OpCodesI.OP_TESTSET) return true;
  }

  return false;
  /* not found */
};
/*
** Ensures final expression result (including results from its jump
** lists) is in register 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (for those tests
** that do not produce values).
*/


const exp2reg = function (fs, e, reg) {
  let ek = lparser.expkind;
  discharge2reg(fs, e, reg);
  if (e.k === ek.VJMP)
    /* expression itself is a test? */
    e.t = luaK_concat(fs, e.t, e.u.info);
  /* put this jump in 't' list */

  if (hasjumps(e)) {
    let final;
    /* position after whole expression */

    let p_f = NO_JUMP;
    /* position of an eventual LOAD false */

    let p_t = NO_JUMP;
    /* position of an eventual LOAD true */

    if (need_value(fs, e.t) || need_value(fs, e.f)) {
      let fj = e.k === ek.VJMP ? NO_JUMP : luaK_jump(fs);
      p_f = code_loadbool(fs, reg, 0, 1);
      p_t = code_loadbool(fs, reg, 1, 0);
      luaK_patchtohere(fs, fj);
    }

    final = luaK_getlabel(fs);
    patchlistaux(fs, e.f, final, reg, p_f);
    patchlistaux(fs, e.t, final, reg, p_t);
  }

  e.f = e.t = NO_JUMP;
  e.u.info = reg;
  e.k = ek.VNONRELOC;
};
/*
** Ensures final expression result (including results from its jump
** lists) is in next available register.
*/


const luaK_exp2nextreg = function (fs, e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, 1);
  exp2reg(fs, e, fs.freereg - 1);
};
/*
** Ensures final expression result (including results from its jump
** lists) is in some (any) register and return that register.
*/


const luaK_exp2anyreg = function (fs, e) {
  luaK_dischargevars(fs, e);

  if (e.k === lparser.expkind.VNONRELOC) {
    /* expression already has a register? */
    if (!hasjumps(e))
      /* no jumps? */
      return e.u.info;
    /* result is already in a register */

    if (e.u.info >= fs.nactvar) {
      /* reg. is not a local? */
      exp2reg(fs, e, e.u.info);
      /* put final result in it */

      return e.u.info;
    }
  }

  luaK_exp2nextreg(fs, e);
  /* otherwise, use next available register */

  return e.u.info;
};
/*
** Ensures final expression result is either in a register or in an
** upvalue.
*/


const luaK_exp2anyregup = function (fs, e) {
  if (e.k !== lparser.expkind.VUPVAL || hasjumps(e)) luaK_exp2anyreg(fs, e);
};
/*
** Ensures final expression result is either in a register or it is
** a constant.
*/


const luaK_exp2val = function (fs, e) {
  if (hasjumps(e)) luaK_exp2anyreg(fs, e);else luaK_dischargevars(fs, e);
};
/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a register or in 'k' with an index
** in the range of R/K indices).
** Returns R/K index.
*/


const luaK_exp2RK = function (fs, e) {
  let ek = lparser.expkind;
  let vk = false;
  luaK_exp2val(fs, e);

  switch (e.k) {
    /* move constants to 'k' */
    case ek.VTRUE:
      e.u.info = boolK(fs, true);
      vk = true;
      break;

    case ek.VFALSE:
      e.u.info = boolK(fs, false);
      vk = true;
      break;

    case ek.VNIL:
      e.u.info = nilK(fs);
      vk = true;
      break;

    case ek.VKINT:
      e.u.info = luaK_intK(fs, e.u.ival);
      vk = true;
      break;

    case ek.VKFLT:
      e.u.info = luaK_numberK(fs, e.u.nval);
      vk = true;
      break;

    case ek.VK:
      vk = true;
      break;

    default:
      break;
  }

  if (vk) {
    e.k = ek.VK;
    if (e.u.info <= lopcodes.MAXINDEXRK)
      /* constant fits in 'argC'? */
      return lopcodes.RKASK(e.u.info);
  }
  /* not a constant in the right range: put it in a register */


  return luaK_exp2anyreg(fs, e);
};
/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/


const luaK_storevar = function (fs, vr, ex) {
  let ek = lparser.expkind;

  switch (vr.k) {
    case ek.VLOCAL:
      {
        freeexp(fs, ex);
        exp2reg(fs, ex, vr.u.info);
        /* compute 'ex' into proper place */

        return;
      }

    case ek.VUPVAL:
      {
        let e = luaK_exp2anyreg(fs, ex);
        luaK_codeABC(fs, OpCodesI.OP_SETUPVAL, e, vr.u.info, 0);
        break;
      }

    case ek.VINDEXED:
      {
        let op = vr.u.ind.vt === ek.VLOCAL ? OpCodesI.OP_SETTABLE : OpCodesI.OP_SETTABUP;
        let e = luaK_exp2RK(fs, ex);
        luaK_codeABC(fs, op, vr.u.ind.t, vr.u.ind.idx, e);
        break;
      }
  }

  freeexp(fs, ex);
};
/*
** Emit SELF instruction (convert expression 'e' into 'e:key(e,').
*/


const luaK_self = function (fs, e, key) {
  luaK_exp2anyreg(fs, e);
  let ereg = e.u.info;
  /* register where 'e' was placed */

  freeexp(fs, e);
  e.u.info = fs.freereg;
  /* base register for op_self */

  e.k = lparser.expkind.VNONRELOC;
  /* self expression has a fixed register */

  luaK_reserveregs(fs, 2);
  /* function and 'self' produced by op_self */

  luaK_codeABC(fs, OpCodesI.OP_SELF, e.u.info, ereg, luaK_exp2RK(fs, key));
  freeexp(fs, key);
};
/*
** Negate condition 'e' (where 'e' is a comparison).
*/


const negatecondition = function (fs, e) {
  let pc = getjumpcontrol(fs, e.u.info);
  lua_assert(lopcodes.testTMode(pc.opcode) && pc.opcode !== OpCodesI.OP_TESTSET && pc.opcode !== OpCodesI.OP_TEST);
  lopcodes.SETARG_A(pc, !pc.A);
};
/*
** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'
** is true, code will jump if 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/


const jumponcond = function (fs, e, cond) {
  if (e.k === lparser.expkind.VRELOCABLE) {
    let ie = getinstruction(fs, e);

    if (ie.opcode === OpCodesI.OP_NOT) {
      fs.pc--;
      /* remove previous OP_NOT */

      return condjump(fs, OpCodesI.OP_TEST, ie.B, 0, !cond);
    }
    /* else go through */

  }

  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OpCodesI.OP_TESTSET, lopcodes.NO_REG, e.u.info, cond);
};
/*
** Emit code to go through if 'e' is true, jump otherwise.
*/


const luaK_goiftrue = function (fs, e) {
  let ek = lparser.expkind;
  let pc;
  /* pc of new jump */

  luaK_dischargevars(fs, e);

  switch (e.k) {
    case ek.VJMP:
      {
        /* condition? */
        negatecondition(fs, e);
        /* jump when it is false */

        pc = e.u.info;
        /* save jump position */

        break;
      }

    case ek.VK:
    case ek.VKFLT:
    case ek.VKINT:
    case ek.VTRUE:
      {
        pc = NO_JUMP;
        /* always true; do nothing */

        break;
      }

    default:
      {
        pc = jumponcond(fs, e, 0);
        /* jump when false */

        break;
      }
  }

  e.f = luaK_concat(fs, e.f, pc);
  /* insert new jump in false list */

  luaK_patchtohere(fs, e.t);
  /* true list jumps to here (to go through) */

  e.t = NO_JUMP;
};
/*
** Emit code to go through if 'e' is false, jump otherwise.
*/


const luaK_goiffalse = function (fs, e) {
  let ek = lparser.expkind;
  let pc;
  /* pc of new jump */

  luaK_dischargevars(fs, e);

  switch (e.k) {
    case ek.VJMP:
      {
        pc = e.u.info;
        /* already jump if true */

        break;
      }

    case ek.VNIL:
    case ek.VFALSE:
      {
        pc = NO_JUMP;
        /* always false; do nothing */

        break;
      }

    default:
      {
        pc = jumponcond(fs, e, 1);
        /* jump if true */

        break;
      }
  }

  e.t = luaK_concat(fs, e.t, pc);
  /* insert new jump in 't' list */

  luaK_patchtohere(fs, e.f);
  /* false list jumps to here (to go through) */

  e.f = NO_JUMP;
};
/*
** Code 'not e', doing constant folding.
*/


const codenot = function (fs, e) {
  let ek = lparser.expkind;
  luaK_dischargevars(fs, e);

  switch (e.k) {
    case ek.VNIL:
    case ek.VFALSE:
      {
        e.k = ek.VTRUE;
        /* true === not nil === not false */

        break;
      }

    case ek.VK:
    case ek.VKFLT:
    case ek.VKINT:
    case ek.VTRUE:
      {
        e.k = ek.VFALSE;
        /* false === not "x" === not 0.5 === not 1 === not true */

        break;
      }

    case ek.VJMP:
      {
        negatecondition(fs, e);
        break;
      }

    case ek.VRELOCABLE:
    case ek.VNONRELOC:
      {
        discharge2anyreg(fs, e);
        freeexp(fs, e);
        e.u.info = luaK_codeABC(fs, OpCodesI.OP_NOT, 0, e.u.info, 0);
        e.k = ek.VRELOCABLE;
        break;
      }
  }
  /* interchange true and false lists */


  {
    let temp = e.f;
    e.f = e.t;
    e.t = temp;
  }
  removevalues(fs, e.f);
  /* values are useless when negated */

  removevalues(fs, e.t);
};
/*
** Create expression 't[k]'. 't' must have its final result already in a
** register or upvalue.
*/


const luaK_indexed = function (fs, t, k) {
  let ek = lparser.expkind;
  lua_assert(!hasjumps(t) && (lparser.vkisinreg(t.k) || t.k === ek.VUPVAL));
  t.u.ind.t = t.u.info;
  /* register or upvalue index */

  t.u.ind.idx = luaK_exp2RK(fs, k);
  /* R/K index for key */

  t.u.ind.vt = t.k === ek.VUPVAL ? ek.VUPVAL : ek.VLOCAL;
  t.k = ek.VINDEXED;
};
/*
** Return false if folding can raise an error.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/


const validop = function (op, v1, v2) {
  switch (op) {
    case LUA_OPBAND:
    case LUA_OPBOR:
    case LUA_OPBXOR:
    case LUA_OPSHL:
    case LUA_OPSHR:
    case LUA_OPBNOT:
      {
        /* conversion errors */
        return lvm.tointeger(v1) !== false && lvm.tointeger(v2) !== false;
      }

    case LUA_OPDIV:
    case LUA_OPIDIV:
    case LUA_OPMOD:
      /* division by 0 */
      return v2.value !== 0;

    default:
      return 1;

    /* everything else is valid */
  }
};
/*
** Try to "constant-fold" an operation; return 1 iff successful.
** (In this case, 'e1' has the final result.)
*/


const constfolding = function (op, e1, e2) {
  let ek = lparser.expkind;
  let v1, v2;
  if (!(v1 = tonumeral(e1, true)) || !(v2 = tonumeral(e2, true)) || !validop(op, v1, v2)) return 0;
  /* non-numeric operands or not safe to fold */

  let res = new TValue();
  /* FIXME */

  lobject.luaO_arith(null, op, v1, v2, res);
  /* does operation */

  if (res.ttisinteger()) {
    e1.k = ek.VKINT;
    e1.u.ival = res.value;
  } else {
    /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
    let n = res.value;
    if (isNaN(n) || n === 0) return false;
    e1.k = ek.VKFLT;
    e1.u.nval = n;
  }

  return true;
};
/*
** Emit code for unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/


const codeunexpval = function (fs, op, e, line) {
  let r = luaK_exp2anyreg(fs, e);
  /* opcodes operate only on registers */

  freeexp(fs, e);
  e.u.info = luaK_codeABC(fs, op, 0, r, 0);
  /* generate opcode */

  e.k = lparser.expkind.VRELOCABLE;
  /* all those operations are relocatable */

  luaK_fixline(fs, line);
};
/*
** Emit code for binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
** Because 'luaK_exp2RK' can free registers, its calls must be
** in "stack order" (that is, first on 'e2', which may have more
** recent registers to be released).
*/


const codebinexpval = function (fs, op, e1, e2, line) {
  let rk2 = luaK_exp2RK(fs, e2);
  /* both operands are "RK" */

  let rk1 = luaK_exp2RK(fs, e1);
  freeexps(fs, e1, e2);
  e1.u.info = luaK_codeABC(fs, op, 0, rk1, rk2);
  /* generate opcode */

  e1.k = lparser.expkind.VRELOCABLE;
  /* all those operations are relocatable */

  luaK_fixline(fs, line);
};
/*
** Emit code for comparisons.
** 'e1' was already put in R/K form by 'luaK_infix'.
*/


const codecomp = function (fs, opr, e1, e2) {
  let ek = lparser.expkind;
  let rk1;
  if (e1.k === ek.VK) rk1 = lopcodes.RKASK(e1.u.info);else {
    lua_assert(e1.k === ek.VNONRELOC);
    rk1 = e1.u.info;
  }
  let rk2 = luaK_exp2RK(fs, e2);
  freeexps(fs, e1, e2);

  switch (opr) {
    case BinOpr.OPR_NE:
      {
        /* '(a ~= b)' ==> 'not (a === b)' */
        e1.u.info = condjump(fs, OpCodesI.OP_EQ, 0, rk1, rk2);
        break;
      }

    case BinOpr.OPR_GT:
    case BinOpr.OPR_GE:
      {
        /* '(a > b)' ==> '(b < a)';  '(a >= b)' ==> '(b <= a)' */
        let op = opr - BinOpr.OPR_NE + OpCodesI.OP_EQ;
        e1.u.info = condjump(fs, op, 1, rk2, rk1);
        /* invert operands */

        break;
      }

    default:
      {
        /* '==', '<', '<=' use their own opcodes */
        let op = opr - BinOpr.OPR_EQ + OpCodesI.OP_EQ;
        e1.u.info = condjump(fs, op, 1, rk1, rk2);
        break;
      }
  }

  e1.k = ek.VJMP;
};
/*
** Apply prefix operation 'op' to expression 'e'.
*/


const luaK_prefix = function (fs, op, e, line) {
  let ef = new lparser.expdesc();
  ef.k = lparser.expkind.VKINT;
  ef.u.ival = ef.u.nval = ef.u.info = 0;
  ef.t = NO_JUMP;
  ef.f = NO_JUMP;

  switch (op) {
    case UnOpr.OPR_MINUS:
    case UnOpr.OPR_BNOT:
      /* use 'ef' as fake 2nd operand */
      if (constfolding(op + LUA_OPUNM, e, ef)) break;

    /* FALLTHROUGH */

    case UnOpr.OPR_LEN:
      codeunexpval(fs, op + OpCodesI.OP_UNM, e, line);
      break;

    case UnOpr.OPR_NOT:
      codenot(fs, e);
      break;
  }
};
/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/


const luaK_infix = function (fs, op, v) {
  switch (op) {
    case BinOpr.OPR_AND:
      {
        luaK_goiftrue(fs, v);
        /* go ahead only if 'v' is true */

        break;
      }

    case BinOpr.OPR_OR:
      {
        luaK_goiffalse(fs, v);
        /* go ahead only if 'v' is false */

        break;
      }

    case BinOpr.OPR_CONCAT:
      {
        luaK_exp2nextreg(fs, v);
        /* operand must be on the 'stack' */

        break;
      }

    case BinOpr.OPR_ADD:
    case BinOpr.OPR_SUB:
    case BinOpr.OPR_MUL:
    case BinOpr.OPR_DIV:
    case BinOpr.OPR_IDIV:
    case BinOpr.OPR_MOD:
    case BinOpr.OPR_POW:
    case BinOpr.OPR_BAND:
    case BinOpr.OPR_BOR:
    case BinOpr.OPR_BXOR:
    case BinOpr.OPR_SHL:
    case BinOpr.OPR_SHR:
      {
        if (!tonumeral(v, false)) luaK_exp2RK(fs, v);
        /* else keep numeral, which may be folded with 2nd operand */

        break;
      }

    default:
      {
        luaK_exp2RK(fs, v);
        break;
      }
  }
};
/*
** Finalize code for binary operation, after reading 2nd operand.
** For '(a .. b .. c)' (which is '(a .. (b .. c))', because
** concatenation is right associative), merge second CONCAT into first
** one.
*/


const luaK_posfix = function (fs, op, e1, e2, line) {
  let ek = lparser.expkind;

  switch (op) {
    case BinOpr.OPR_AND:
      {
        lua_assert(e1.t === NO_JUMP);
        /* list closed by 'luK_infix' */

        luaK_dischargevars(fs, e2);
        e2.f = luaK_concat(fs, e2.f, e1.f);
        e1.to(e2);
        break;
      }

    case BinOpr.OPR_OR:
      {
        lua_assert(e1.f === NO_JUMP);
        /* list closed by 'luK_infix' */

        luaK_dischargevars(fs, e2);
        e2.t = luaK_concat(fs, e2.t, e1.t);
        e1.to(e2);
        break;
      }

    case BinOpr.OPR_CONCAT:
      {
        luaK_exp2val(fs, e2);
        let ins = getinstruction(fs, e2);

        if (e2.k === ek.VRELOCABLE && ins.opcode === OpCodesI.OP_CONCAT) {
          lua_assert(e1.u.info === ins.B - 1);
          freeexp(fs, e1);
          lopcodes.SETARG_B(ins, e1.u.info);
          e1.k = ek.VRELOCABLE;
          e1.u.info = e2.u.info;
        } else {
          luaK_exp2nextreg(fs, e2);
          /* operand must be on the 'stack' */

          codebinexpval(fs, OpCodesI.OP_CONCAT, e1, e2, line);
        }

        break;
      }

    case BinOpr.OPR_ADD:
    case BinOpr.OPR_SUB:
    case BinOpr.OPR_MUL:
    case BinOpr.OPR_DIV:
    case BinOpr.OPR_IDIV:
    case BinOpr.OPR_MOD:
    case BinOpr.OPR_POW:
    case BinOpr.OPR_BAND:
    case BinOpr.OPR_BOR:
    case BinOpr.OPR_BXOR:
    case BinOpr.OPR_SHL:
    case BinOpr.OPR_SHR:
      {
        if (!constfolding(op + LUA_OPADD, e1, e2)) codebinexpval(fs, op + OpCodesI.OP_ADD, e1, e2, line);
        break;
      }

    case BinOpr.OPR_EQ:
    case BinOpr.OPR_LT:
    case BinOpr.OPR_LE:
    case BinOpr.OPR_NE:
    case BinOpr.OPR_GT:
    case BinOpr.OPR_GE:
      {
        codecomp(fs, op, e1, e2);
        break;
      }
  }

  return e1;
};
/*
** Change line information associated with current position.
*/


const luaK_fixline = function (fs, line) {
  fs.f.lineinfo[fs.pc - 1] = line;
};
/*
** Emit a SETLIST instruction.
** 'base' is register that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or LUA_MULTRET to add up to stack top).
*/


const luaK_setlist = function (fs, base, nelems, tostore) {
  let c = (nelems - 1) / lopcodes.LFIELDS_PER_FLUSH + 1;
  let b = tostore === LUA_MULTRET ? 0 : tostore;
  lua_assert(tostore !== 0 && tostore <= lopcodes.LFIELDS_PER_FLUSH);
  if (c <= lopcodes.MAXARG_C) luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, c);else if (c <= lopcodes.MAXARG_Ax) {
    luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, 0);
    codeextraarg(fs, c);
  } else llex.luaX_syntaxerror(fs.ls, to_luastring("constructor too long", true));
  fs.freereg = base + 1;
  /* free registers with list values */
};

module.exports.BinOpr = BinOpr;
module.exports.NO_JUMP = NO_JUMP;
module.exports.UnOpr = UnOpr;
module.exports.getinstruction = getinstruction;
module.exports.luaK_checkstack = luaK_checkstack;
module.exports.luaK_code = luaK_code;
module.exports.luaK_codeABC = luaK_codeABC;
module.exports.luaK_codeABx = luaK_codeABx;
module.exports.luaK_codeAsBx = luaK_codeAsBx;
module.exports.luaK_codek = luaK_codek;
module.exports.luaK_concat = luaK_concat;
module.exports.luaK_dischargevars = luaK_dischargevars;
module.exports.luaK_exp2RK = luaK_exp2RK;
module.exports.luaK_exp2anyreg = luaK_exp2anyreg;
module.exports.luaK_exp2anyregup = luaK_exp2anyregup;
module.exports.luaK_exp2nextreg = luaK_exp2nextreg;
module.exports.luaK_exp2val = luaK_exp2val;
module.exports.luaK_fixline = luaK_fixline;
module.exports.luaK_getlabel = luaK_getlabel;
module.exports.luaK_goiffalse = luaK_goiffalse;
module.exports.luaK_goiftrue = luaK_goiftrue;
module.exports.luaK_indexed = luaK_indexed;
module.exports.luaK_infix = luaK_infix;
module.exports.luaK_intK = luaK_intK;
module.exports.luaK_jump = luaK_jump;
module.exports.luaK_jumpto = luaK_jumpto;
module.exports.luaK_nil = luaK_nil;
module.exports.luaK_numberK = luaK_numberK;
module.exports.luaK_patchclose = luaK_patchclose;
module.exports.luaK_patchlist = luaK_patchlist;
module.exports.luaK_patchtohere = luaK_patchtohere;
module.exports.luaK_posfix = luaK_posfix;
module.exports.luaK_prefix = luaK_prefix;
module.exports.luaK_reserveregs = luaK_reserveregs;
module.exports.luaK_ret = luaK_ret;
module.exports.luaK_self = luaK_self;
module.exports.luaK_setlist = luaK_setlist;
module.exports.luaK_setmultret = luaK_setmultret;
module.exports.luaK_setoneret = luaK_setoneret;
module.exports.luaK_setreturns = luaK_setreturns;
module.exports.luaK_storevar = luaK_storevar;
module.exports.luaK_stringK = luaK_stringK;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_SIGNATURE,
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR
  },
  thread_status: {
    LUA_ERRSYNTAX
  },
  is_luastring,
  luastring_eq,
  to_luastring
} = __webpack_require__(1);

const ldo = __webpack_require__(9);

const lfunc = __webpack_require__(14);

const lobject = __webpack_require__(7);

const {
  MAXARG_sBx,
  POS_A,
  POS_Ax,
  POS_B,
  POS_Bx,
  POS_C,
  POS_OP,
  SIZE_A,
  SIZE_Ax,
  SIZE_B,
  SIZE_Bx,
  SIZE_C,
  SIZE_OP
} = __webpack_require__(17);

const {
  lua_assert
} = __webpack_require__(5);

const {
  luaS_bless
} = __webpack_require__(11);

const {
  luaZ_read,
  ZIO
} = __webpack_require__(23);

let LUAC_DATA = [0x19, 0x93, 13, 10, 0x1a, 10];

class BytecodeParser {
  constructor(L, Z, name) {
    this.intSize = 4;
    this.size_tSize = 4;
    this.instructionSize = 4;
    this.integerSize = 4;
    this.numberSize = 8;
    lua_assert(Z instanceof ZIO, "BytecodeParser only operates on a ZIO");
    lua_assert(is_luastring(name));
    if (name[0] === 64
    /* ('@').charCodeAt(0) */
    || name[0] === 61
    /* ('=').charCodeAt(0) */
    ) this.name = name.subarray(1);else if (name[0] == LUA_SIGNATURE[0]) this.name = to_luastring("binary string", true);else this.name = name;
    this.L = L;
    this.Z = Z; // Used to do buffer to number conversions

    this.arraybuffer = new ArrayBuffer(Math.max(this.intSize, this.size_tSize, this.instructionSize, this.integerSize, this.numberSize));
    this.dv = new DataView(this.arraybuffer);
    this.u8 = new Uint8Array(this.arraybuffer);
  }

  read(size) {
    let u8 = new Uint8Array(size);
    if (luaZ_read(this.Z, u8, 0, size) !== 0) this.error("truncated");
    return u8;
  }

  LoadByte() {
    if (luaZ_read(this.Z, this.u8, 0, 1) !== 0) this.error("truncated");
    return this.u8[0];
  }

  LoadInt() {
    if (luaZ_read(this.Z, this.u8, 0, this.intSize) !== 0) this.error("truncated");
    return this.dv.getInt32(0, true);
  }

  LoadNumber() {
    if (luaZ_read(this.Z, this.u8, 0, this.numberSize) !== 0) this.error("truncated");
    return this.dv.getFloat64(0, true);
  }

  LoadInteger() {
    if (luaZ_read(this.Z, this.u8, 0, this.integerSize) !== 0) this.error("truncated");
    return this.dv.getInt32(0, true);
  }

  LoadSize_t() {
    return this.LoadInteger();
  }

  LoadString() {
    let size = this.LoadByte();
    if (size === 0xFF) size = this.LoadSize_t();
    if (size === 0) return null;
    return luaS_bless(this.L, this.read(size - 1));
  }
  /* creates a mask with 'n' 1 bits at position 'p' */


  static MASK1(n, p) {
    return ~(~0 << n) << p;
  }

  LoadCode(f) {
    let n = this.LoadInt();
    let p = BytecodeParser;

    for (let i = 0; i < n; i++) {
      if (luaZ_read(this.Z, this.u8, 0, this.instructionSize) !== 0) this.error("truncated");
      let ins = this.dv.getUint32(0, true);
      f.code[i] = {
        code: ins,
        opcode: ins >> POS_OP & p.MASK1(SIZE_OP, 0),
        A: ins >> POS_A & p.MASK1(SIZE_A, 0),
        B: ins >> POS_B & p.MASK1(SIZE_B, 0),
        C: ins >> POS_C & p.MASK1(SIZE_C, 0),
        Bx: ins >> POS_Bx & p.MASK1(SIZE_Bx, 0),
        Ax: ins >> POS_Ax & p.MASK1(SIZE_Ax, 0),
        sBx: (ins >> POS_Bx & p.MASK1(SIZE_Bx, 0)) - MAXARG_sBx
      };
    }
  }

  LoadConstants(f) {
    let n = this.LoadInt();

    for (let i = 0; i < n; i++) {
      let t = this.LoadByte();

      switch (t) {
        case LUA_TNIL:
          f.k.push(new lobject.TValue(LUA_TNIL, null));
          break;

        case LUA_TBOOLEAN:
          f.k.push(new lobject.TValue(LUA_TBOOLEAN, this.LoadByte() !== 0));
          break;

        case LUA_TNUMFLT:
          f.k.push(new lobject.TValue(LUA_TNUMFLT, this.LoadNumber()));
          break;

        case LUA_TNUMINT:
          f.k.push(new lobject.TValue(LUA_TNUMINT, this.LoadInteger()));
          break;

        case LUA_TSHRSTR:
        case LUA_TLNGSTR:
          f.k.push(new lobject.TValue(LUA_TLNGSTR, this.LoadString()));
          break;

        default:
          this.error(`unrecognized constant '${t}'`);
      }
    }
  }

  LoadProtos(f) {
    let n = this.LoadInt();

    for (let i = 0; i < n; i++) {
      f.p[i] = new lfunc.Proto(this.L);
      this.LoadFunction(f.p[i], f.source);
    }
  }

  LoadUpvalues(f) {
    let n = this.LoadInt();

    for (let i = 0; i < n; i++) {
      f.upvalues[i] = {
        name: null,
        instack: this.LoadByte(),
        idx: this.LoadByte()
      };
    }
  }

  LoadDebug(f) {
    let n = this.LoadInt();

    for (let i = 0; i < n; i++) f.lineinfo[i] = this.LoadInt();

    n = this.LoadInt();

    for (let i = 0; i < n; i++) {
      f.locvars[i] = {
        varname: this.LoadString(),
        startpc: this.LoadInt(),
        endpc: this.LoadInt()
      };
    }

    n = this.LoadInt();

    for (let i = 0; i < n; i++) {
      f.upvalues[i].name = this.LoadString();
    }
  }

  LoadFunction(f, psource) {
    f.source = this.LoadString();
    if (f.source === null)
      /* no source in dump? */
      f.source = psource;
    /* reuse parent's source */

    f.linedefined = this.LoadInt();
    f.lastlinedefined = this.LoadInt();
    f.numparams = this.LoadByte();
    f.is_vararg = this.LoadByte() !== 0;
    f.maxstacksize = this.LoadByte();
    this.LoadCode(f);
    this.LoadConstants(f);
    this.LoadUpvalues(f);
    this.LoadProtos(f);
    this.LoadDebug(f);
  }

  checkliteral(s, msg) {
    let buff = this.read(s.length);
    if (!luastring_eq(buff, s)) this.error(msg);
  }

  checkHeader() {
    this.checkliteral(LUA_SIGNATURE.subarray(1), "not a");
    /* 1st char already checked */

    if (this.LoadByte() !== 0x53) this.error("version mismatch in");
    if (this.LoadByte() !== 0) this.error("format mismatch in");
    this.checkliteral(LUAC_DATA, "corrupted");
    this.intSize = this.LoadByte();
    this.size_tSize = this.LoadByte();
    this.instructionSize = this.LoadByte();
    this.integerSize = this.LoadByte();
    this.numberSize = this.LoadByte();
    this.checksize(this.intSize, 4, "int");
    this.checksize(this.size_tSize, 4, "size_t");
    this.checksize(this.instructionSize, 4, "instruction");
    this.checksize(this.integerSize, 4, "integer");
    this.checksize(this.numberSize, 8, "number");
    if (this.LoadInteger() !== 0x5678) this.error("endianness mismatch in");
    if (this.LoadNumber() !== 370.5) this.error("float format mismatch in");
  }

  error(why) {
    lobject.luaO_pushfstring(this.L, to_luastring("%s: %s precompiled chunk"), this.name, to_luastring(why));
    ldo.luaD_throw(this.L, LUA_ERRSYNTAX);
  }

  checksize(byte, size, tname) {
    if (byte !== size) this.error(`${tname} size mismatch in`);
  }

}

const luaU_undump = function (L, Z, name) {
  let S = new BytecodeParser(L, Z, name);
  S.checkHeader();
  let cl = lfunc.luaF_newLclosure(L, S.LoadByte());
  ldo.luaD_inctop(L);
  L.stack[L.top - 1].setclLvalue(cl);
  cl.p = new lfunc.Proto(L);
  S.LoadFunction(cl.p, null);
  lua_assert(cl.nupvalues === cl.p.upvalues.length);
  /* luai_verifycode */

  return cl;
};

module.exports.luaU_undump = luaU_undump;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  LUA_SIGNATURE,
  LUA_VERSION_MAJOR,
  LUA_VERSION_MINOR,
  constant_types: {
    LUA_TBOOLEAN,
    LUA_TLNGSTR,
    LUA_TNIL,
    LUA_TNUMFLT,
    LUA_TNUMINT,
    LUA_TSHRSTR
  },
  luastring_of
} = __webpack_require__(1);

const LUAC_DATA = luastring_of(25, 147, 13, 10, 26, 10);
const LUAC_INT = 0x5678;
const LUAC_NUM = 370.5;
const LUAC_VERSION = Number(LUA_VERSION_MAJOR) * 16 + Number(LUA_VERSION_MINOR);
const LUAC_FORMAT = 0;
/* this is the official format */

class DumpState {
  constructor() {
    this.L = null;
    this.write = null;
    this.data = null;
    this.strip = NaN;
    this.status = NaN;
  }

}

const DumpBlock = function (b, size, D) {
  if (D.status === 0 && size > 0) D.status = D.writer(D.L, b, size, D.data);
};

const DumpByte = function (y, D) {
  DumpBlock(luastring_of(y), 1, D);
};

const DumpInt = function (x, D) {
  let ab = new ArrayBuffer(4);
  let dv = new DataView(ab);
  dv.setInt32(0, x, true);
  let t = new Uint8Array(ab);
  DumpBlock(t, 4, D);
};

const DumpInteger = function (x, D) {
  let ab = new ArrayBuffer(4);
  let dv = new DataView(ab);
  dv.setInt32(0, x, true);
  let t = new Uint8Array(ab);
  DumpBlock(t, 4, D);
};

const DumpNumber = function (x, D) {
  let ab = new ArrayBuffer(8);
  let dv = new DataView(ab);
  dv.setFloat64(0, x, true);
  let t = new Uint8Array(ab);
  DumpBlock(t, 8, D);
};

const DumpString = function (s, D) {
  if (s === null) DumpByte(0, D);else {
    let size = s.tsslen() + 1;
    let str = s.getstr();
    if (size < 0xFF) DumpByte(size, D);else {
      DumpByte(0xFF, D);
      DumpInteger(size, D);
    }
    DumpBlock(str, size - 1, D);
    /* no need to save '\0' */
  }
};

const DumpCode = function (f, D) {
  let s = f.code.map(e => e.code);
  DumpInt(s.length, D);

  for (let i = 0; i < s.length; i++) DumpInt(s[i], D);
};

const DumpConstants = function (f, D) {
  let n = f.k.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) {
    let o = f.k[i];
    DumpByte(o.ttype(), D);

    switch (o.ttype()) {
      case LUA_TNIL:
        break;

      case LUA_TBOOLEAN:
        DumpByte(o.value ? 1 : 0, D);
        break;

      case LUA_TNUMFLT:
        DumpNumber(o.value, D);
        break;

      case LUA_TNUMINT:
        DumpInteger(o.value, D);
        break;

      case LUA_TSHRSTR:
      case LUA_TLNGSTR:
        DumpString(o.tsvalue(), D);
        break;
    }
  }
};

const DumpProtos = function (f, D) {
  let n = f.p.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) DumpFunction(f.p[i], f.source, D);
};

const DumpUpvalues = function (f, D) {
  let n = f.upvalues.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) {
    DumpByte(f.upvalues[i].instack ? 1 : 0, D);
    DumpByte(f.upvalues[i].idx, D);
  }
};

const DumpDebug = function (f, D) {
  let n = D.strip ? 0 : f.lineinfo.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) DumpInt(f.lineinfo[i], D);

  n = D.strip ? 0 : f.locvars.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) {
    DumpString(f.locvars[i].varname, D);
    DumpInt(f.locvars[i].startpc, D);
    DumpInt(f.locvars[i].endpc, D);
  }

  n = D.strip ? 0 : f.upvalues.length;
  DumpInt(n, D);

  for (let i = 0; i < n; i++) DumpString(f.upvalues[i].name, D);
};

const DumpFunction = function (f, psource, D) {
  if (D.strip || f.source === psource) DumpString(null, D);
  /* no debug info or same source as its parent */
  else DumpString(f.source, D);
  DumpInt(f.linedefined, D);
  DumpInt(f.lastlinedefined, D);
  DumpByte(f.numparams, D);
  DumpByte(f.is_vararg ? 1 : 0, D);
  DumpByte(f.maxstacksize, D);
  DumpCode(f, D);
  DumpConstants(f, D);
  DumpUpvalues(f, D);
  DumpProtos(f, D);
  DumpDebug(f, D);
};

const DumpHeader = function (D) {
  DumpBlock(LUA_SIGNATURE, LUA_SIGNATURE.length, D);
  DumpByte(LUAC_VERSION, D);
  DumpByte(LUAC_FORMAT, D);
  DumpBlock(LUAC_DATA, LUAC_DATA.length, D);
  DumpByte(4, D); // intSize

  DumpByte(4, D); // size_tSize

  DumpByte(4, D); // instructionSize

  DumpByte(4, D); // integerSize

  DumpByte(8, D); // numberSize

  DumpInteger(LUAC_INT, D);
  DumpNumber(LUAC_NUM, D);
};
/*
** dump Lua function as precompiled chunk
*/


const luaU_dump = function (L, f, w, data, strip) {
  let D = new DumpState();
  D.L = L;
  D.writer = w;
  D.data = data;
  D.strip = strip;
  D.status = 0;
  DumpHeader(D);
  DumpByte(f.upvalues.length, D);
  DumpFunction(f, null, D);
  return D.status;
};

module.exports.luaU_dump = luaU_dump;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */
!function () {
  'use strict';

  var re = {
    not_string: /[^s]/,
    not_bool: /[^t]/,
    not_type: /[^T]/,
    not_primitive: /[^v]/,
    number: /[diefg]/,
    numeric_arg: /[bcdiefguxX]/,
    json: /[j]/,
    not_json: /[^j]/,
    text: /^[^\x25]+/,
    modulo: /^\x25{2}/,
    placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
    key: /^([a-z_][a-z_\d]*)/i,
    key_access: /^\.([a-z_][a-z_\d]*)/i,
    index_access: /^\[(\d+)\]/,
    sign: /^[+-]/
  };

  function sprintf(key) {
    // `arguments` is not an array, but should be fine for this call
    return sprintf_format(sprintf_parse(key), arguments);
  }

  function vsprintf(fmt, argv) {
    return sprintf.apply(null, [fmt].concat(argv || []));
  }

  function sprintf_format(parse_tree, argv) {
    var cursor = 1,
        tree_length = parse_tree.length,
        arg,
        output = '',
        i,
        k,
        ph,
        pad,
        pad_character,
        pad_length,
        is_positive,
        sign;

    for (i = 0; i < tree_length; i++) {
      if (typeof parse_tree[i] === 'string') {
        output += parse_tree[i];
      } else if (typeof parse_tree[i] === 'object') {
        ph = parse_tree[i]; // convenience purposes only

        if (ph.keys) {
          // keyword argument
          arg = argv[cursor];

          for (k = 0; k < ph.keys.length; k++) {
            if (arg == undefined) {
              throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
            }

            arg = arg[ph.keys[k]];
          }
        } else if (ph.param_no) {
          // positional argument (explicit)
          arg = argv[ph.param_no];
        } else {
          // positional argument (implicit)
          arg = argv[cursor++];
        }

        if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
          arg = arg();
        }

        if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
          throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
        }

        if (re.number.test(ph.type)) {
          is_positive = arg >= 0;
        }

        switch (ph.type) {
          case 'b':
            arg = parseInt(arg, 10).toString(2);
            break;

          case 'c':
            arg = String.fromCharCode(parseInt(arg, 10));
            break;

          case 'd':
          case 'i':
            arg = parseInt(arg, 10);
            break;

          case 'j':
            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
            break;

          case 'e':
            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
            break;

          case 'f':
            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
            break;

          case 'g':
            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
            break;

          case 'o':
            arg = (parseInt(arg, 10) >>> 0).toString(8);
            break;

          case 's':
            arg = String(arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;

          case 't':
            arg = String(!!arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;

          case 'T':
            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;

          case 'u':
            arg = parseInt(arg, 10) >>> 0;
            break;

          case 'v':
            arg = arg.valueOf();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;

          case 'x':
            arg = (parseInt(arg, 10) >>> 0).toString(16);
            break;

          case 'X':
            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
            break;
        }

        if (re.json.test(ph.type)) {
          output += arg;
        } else {
          if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
            sign = is_positive ? '+' : '-';
            arg = arg.toString().replace(re.sign, '');
          } else {
            sign = '';
          }

          pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
          pad_length = ph.width - (sign + arg).length;
          pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
          output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
        }
      }
    }

    return output;
  }

  var sprintf_cache = Object.create(null);

  function sprintf_parse(fmt) {
    if (sprintf_cache[fmt]) {
      return sprintf_cache[fmt];
    }

    var _fmt = fmt,
        match,
        parse_tree = [],
        arg_names = 0;

    while (_fmt) {
      if ((match = re.text.exec(_fmt)) !== null) {
        parse_tree.push(match[0]);
      } else if ((match = re.modulo.exec(_fmt)) !== null) {
        parse_tree.push('%');
      } else if ((match = re.placeholder.exec(_fmt)) !== null) {
        if (match[2]) {
          arg_names |= 1;
          var field_list = [],
              replacement_field = match[2],
              field_match = [];

          if ((field_match = re.key.exec(replacement_field)) !== null) {
            field_list.push(field_match[1]);

            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else {
                throw new SyntaxError('[sprintf] failed to parse named argument key');
              }
            }
          } else {
            throw new SyntaxError('[sprintf] failed to parse named argument key');
          }

          match[2] = field_list;
        } else {
          arg_names |= 2;
        }

        if (arg_names === 3) {
          throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
        }

        parse_tree.push({
          placeholder: match[0],
          param_no: match[1],
          keys: match[2],
          sign: match[3],
          pad_char: match[4],
          align: match[5],
          width: match[6],
          precision: match[7],
          type: match[8]
        });
      } else {
        throw new SyntaxError('[sprintf] unexpected placeholder');
      }

      _fmt = _fmt.substring(match[0].length);
    }

    return sprintf_cache[fmt] = parse_tree;
  }
  /**
   * export to either browser or node.js
   */

  /* eslint-disable quote-props */


  if (true) {
    exports['sprintf'] = sprintf;
    exports['vsprintf'] = vsprintf;
  }

  if (typeof window !== 'undefined') {
    window['sprintf'] = sprintf;
    window['vsprintf'] = vsprintf;

    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return {
          'sprintf': sprintf,
          'vsprintf': vsprintf
        };
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
  /* eslint-enable quote-props */

}(); // eslint-disable-line

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  lua_pop
} = __webpack_require__(2);

const {
  luaL_requiref
} = __webpack_require__(8);

const {
  to_luastring
} = __webpack_require__(6);

const loadedlibs = {};
/* export before requiring lualib.js */

const luaL_openlibs = function (L) {
  /* "require" functions from 'loadedlibs' and set results to global table */
  for (let lib in loadedlibs) {
    luaL_requiref(L, to_luastring(lib), loadedlibs[lib], 1);
    lua_pop(L, 1);
    /* remove lib */
  }
};

module.exports.luaL_openlibs = luaL_openlibs;

const lualib = __webpack_require__(18);

const {
  luaopen_base
} = __webpack_require__(35);

const {
  luaopen_coroutine
} = __webpack_require__(36);

const {
  luaopen_debug
} = __webpack_require__(42);

const {
  luaopen_math
} = __webpack_require__(41);

const {
  luaopen_package
} = __webpack_require__(43);

const {
  luaopen_os
} = __webpack_require__(38);

const {
  luaopen_string
} = __webpack_require__(39);

const {
  luaopen_table
} = __webpack_require__(37);

const {
  luaopen_utf8
} = __webpack_require__(40);

loadedlibs["_G"] = luaopen_base, loadedlibs[lualib.LUA_LOADLIBNAME] = luaopen_package;
loadedlibs[lualib.LUA_COLIBNAME] = luaopen_coroutine;
loadedlibs[lualib.LUA_TABLIBNAME] = luaopen_table;
loadedlibs[lualib.LUA_OSLIBNAME] = luaopen_os;
loadedlibs[lualib.LUA_STRLIBNAME] = luaopen_string;
loadedlibs[lualib.LUA_MATHLIBNAME] = luaopen_math;
loadedlibs[lualib.LUA_UTF8LIBNAME] = luaopen_utf8;
loadedlibs[lualib.LUA_DBLIBNAME] = luaopen_debug;
if (false) {}
/* Extension: fengari library */

const {
  luaopen_fengari
} = __webpack_require__(44);

loadedlibs[lualib.LUA_FENGARILIBNAME] = luaopen_fengari;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

const Extension = __webpack_require__(20);

const interop = __webpack_require__(45);

const util = __webpack_require__(24);
/**
 * Extends the VM state with functions for accessing the running agent.
 *
 * @class
 * @extends Extension
 * @category Extensions
 * @hideconstructor
 */


class AgentExtension extends Extension {
  static extend(vm) {
    vm.set('agent', []).setFunction('agent.load_tape', async (...args) => this.loadTape(vm, ...args)).setFunction('agent.load_tapes_by', async (...args) => this.loadTapesBy(vm, ...args)).setFunction('agent.local_tape', async (...args) => this.localTape(vm, ...args)).setFunction('agent.run_tape', async (...args) => this.runTape(vm, ...args));
  }
  /**
   * Loads a tape by the given txid and returns the tape.
   */


  static async loadTape(vm, txid, opts = {}) {
    const tape = await vm.agent.loadTape(txid, opts);
    return interop.wrap(tape);
  }
  /**
   * Loads a list of tapes by the given query and returns the list.
   */


  static async loadTapesBy(vm, query, opts = {}) {
    const tapes = await vm.agent.loadTapesBy(util.mapToObject(query), {} // util.mapToObject(opts)
    ).then(tapes => {
      return tapes.map(t => interop.wrap(t));
    });
    return tapes;
  }
  /**
   * Loads a tape of the current transaction by output index.
   */


  static async localTape(vm, index, opts = {}) {
    const tx = vm.get('ctx.tx');
    const tape = await vm.agent._prepTape(util.mapToObject(tx), index, util.mapToObject(opts, false));
    return interop.wrap(tape);
  }
  /**
   * Runs the given tape, and returns the result.
   */


  static async runTape(vm, tape, opts = {}) {
    if (opts instanceof Map) opts = util.mapToObject(opts, false);
    return vm.agent.runTape(tape, opts);
  }

}

module.exports = AgentExtension;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const Extension = __webpack_require__(20);
/**
 * Extends the VM state with functions for encoding and decoding hex and base64
 *
 * @class
 * @extends Extension
 * @category Extensions
 * @hideconstructor
 */


class BaseExtension extends Extension {
  static extend(vm) {
    vm.set('base', []).setFunction('base.encode16', this.encode16).setFunction('base.decode16', this.decode16).setFunction('base.encode64', this.encode64).setFunction('base.decode64', this.decode64);
  }
  /**
   * Encodes the given string into a hex string.
   */


  static encode16(str) {
    const buf = binary.from(str);
    return binary.to(buf, 'hex');
  }
  /**
   * Decodes the given hex string into a utf8 string.
   */


  static decode16(str) {
    const buf = binary.from(str, 'hex');
    return binary.to(buf);
  }
  /**
   * Encodes the given string into a base64 string.
   */


  static encode64(str) {
    const buf = binary.from(str);
    return binary.to(buf, 'base64');
  }
  /**
   * Decodes the given base64 string into a utf8 string.
   */


  static decode64(str) {
    const buf = binary.from(str, 'base64');
    return binary.to(buf);
  }

}

module.exports = BaseExtension;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const Extension = __webpack_require__(20);
/**
 * Extends the VM state with functions for accessing the transaction context.
 *
 * @class
 * @extends Extension
 * @category Extensions
 * @hideconstructor
 */


class ContextExtension extends Extension {
  static extend(vm) {
    vm.set('ctx', []).setFunction('ctx.tx_input', (...args) => this.txInput(vm, ...args)).setFunction('ctx.tx_output', (...args) => this.txOutput(vm, ...args)).setFunction('ctx.get_tape', (...args) => this.getTape(vm, ...args)).setFunction('ctx.get_cell', (...args) => this.getCell(vm, ...args));
  }
  /**
   * Fetches the input from the context tx.
   */


  static txInput(vm, index) {
    const tx = vm.get('ctx.tx');
    return tx ? tx.get('in')[index] : undefined;
  }
  /**
   * Fetches the output from the context tx.
   */


  static txOutput(vm, index) {
    const tx = vm.get('ctx.tx');
    return tx ? tx.get('out')[index] : undefined;
  }
  /**
   * Fetches the current tape from the context tx.
   */


  static getTape(vm) {
    const index = vm.get('ctx.tape_index'),
          output = this.txOutput(vm, index);

    if (output) {
      const tape = output.get('tape').reduce((acc, curr) => {
        return acc.concat(this._normalizeCells(curr.get('cell')));
      }, []);
      tape.pop();
      return tape;
    }
  }
  /**
   * Fetches the cell from the context tx.
   */


  static getCell(vm, index) {
    const cellIndex = index ? index : vm.get('ctx.cell_index'),
          tapeIndex = vm.get('ctx.tape_index'),
          output = this.txOutput(vm, tapeIndex);

    if (output) {
      const cell = output.get('tape')[cellIndex].get('cell'),
            normalizedCell = this._normalizeCells(cell);

      normalizedCell.pop();
      return normalizedCell;
    }
  }
  /**
   * Normalizes list of BPU cells into simplified objects
   * @private
   */


  static _normalizeCells(cells) {
    const mapped = cells.map(cell => {
      let b;

      if (cell.has('op')) {
        b = binary.create(1);
        binary.writeUInt8(b, cell.get('op'));
        return {
          b,
          op: cell.get('op')
        };
      } else {
        b = binary.from(cell.get('b'), 'base64');
        return {
          b: binary.to(b)
        };
      }
    });

    if (!mapped.some(cell => cell.op === 106)) {
      mapped.push({
        b: '|'
      });
    }

    return mapped;
  }

}

module.exports = ContextExtension;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

const Extension = __webpack_require__(20);

const util = __webpack_require__(24);

const {
  Hash,
  AES,
  ECDSA,
  ECIES,
  RSA,
  BitcoinMessage
} = __webpack_require__(73);
/**
 * Extends the VM state with common crypto functions.
 *
 * @class
 * @extends Extension
 * @category Extensions
 * @hideconstructor
 */


class CryptoExtension extends Extension {
  static extend(vm) {
    vm.set('crypto', []).set('crypto.aes', []).set('crypto.ecdsa', []).set('crypto.ecies', []).set('crypto.rsa', []).set('crypto.hash', []).set('crypto.bitcoin_message', []).setFunction('crypto.aes.encrypt', this.aesEncrypt).setFunction('crypto.aes.decrypt', this.aesDecrypt).setFunction('crypto.ecies.encrypt', this.eciesEncrypt).setFunction('crypto.ecies.decrypt', this.eciesDecrypt).setFunction('crypto.ecdsa.sign', this.ecdsaSign).setFunction('crypto.ecdsa.verify', this.ecdsaVerify).setFunction('crypto.rsa.encrypt', this.rsaEncrypt).setFunction('crypto.rsa.decrypt', this.rsaDecrypt).setFunction('crypto.rsa.sign', this.rsaSign).setFunction('crypto.rsa.verify', this.rsaVerify).setFunction('crypto.hash.ripemd160', this.ripemd160).setFunction('crypto.hash.sha1', async (...args) => this.hash('SHA-1', ...args)).setFunction('crypto.hash.sha256', async (...args) => this.hash('SHA-256', ...args)).setFunction('crypto.hash.sha512', async (...args) => this.hash('SHA-512', ...args)).setFunction('crypto.bitcoin_message.sign', this.bitcoinMessageSign).setFunction('crypto.bitcoin_message.verify', this.bitcoinMessageVerify);
  }
  /**
   * Hashes the given data using the specified algorithm.
   */


  static async hash(algo, data, opts) {
    return Hash.hash(algo, data, util.mapToObject(opts, false));
  }
  /**
   * Hashes the given data using the RIPEMD160 algorithm.
   */


  static async ripemd160(data, opts) {
    return Hash.ripemd160(data, util.mapToObject(opts, false));
  }
  /**
   * Encrypts the given data with the given secret using AES-GCM.
   */


  static async aesEncrypt(data, key, opts) {
    return AES.GCM.encrypt(data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Decrypts the given data with the given secret using AES-GCM.
   */


  static async aesDecrypt(data, key, opts) {
    return AES.GCM.decrypt(data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Encrypts the given data with the given ECDSA public key using ECIES.
   */


  static async eciesEncrypt(data, key, opts) {
    return ECIES.encrypt(data, key, util.mapToObject(opts, false));
  }
  /**
   * Decrypts the given data with the given ECDSA private key using ECIES.
   */


  static async eciesDecrypt(data, key, opts) {
    return ECIES.decrypt(data, key, util.mapToObject(opts, false));
  }
  /**
   * Signs the given data with the given ECDSA private key.
   */


  static async ecdsaSign(data, key, opts) {
    return ECDSA.sign(data, key, util.mapToObject(opts, false));
  }
  /**
   * Verifies the given signature and message with the given ECDSA public key.
   */


  static async ecdsaVerify(sig, data, key, opts = {}) {
    return ECDSA.verify(sig, data, key, util.mapToObject(opts, false));
  }
  /**
   * Encrypts the given data with the given RSA public or private key.
   */


  static async rsaEncrypt(data, key, opts = {}) {
    return RSA.encrypt(data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Decrypts the given data with the given RSA public or private key.
   */


  static async rsaDecrypt(data, key, opts = {}) {
    return RSA.decrypt(data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Signs the given data with the given RSA private key.
   */


  static async rsaSign(data, key, opts = {}) {
    return RSA.sign(data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Verifies the given signature and message with the given RSA public key.
   */


  static async rsaVerify(sig, data, key, opts = {}) {
    return RSA.verify(sig, data, util.mapToObject(key), util.mapToObject(opts, false));
  }
  /**
   * Signs the given Bitcoin Message with the given ECDSA private key.
   */


  static async bitcoinMessageSign(data, key, opts = {}) {
    return BitcoinMessage.sign(data, key, util.mapToObject(opts, false));
  }
  /**
   * Verifies the given signature and Bitcoin Message with the given ECDSA public key.
   */


  static async bitcoinMessageVerify(sig, data, key, opts = {}) {
    return BitcoinMessage.verify(sig, data, key, util.mapToObject(opts, false));
  }

}

module.exports = CryptoExtension;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

const AES = __webpack_require__(74);

const ECDSA = __webpack_require__(75);

const ECIES = __webpack_require__(81);

const Hash = __webpack_require__(25);

const RSA = __webpack_require__(82);

const BitcoinMessage = __webpack_require__(83);
/**
 * Collection of necessary crypto functions.
 * TODO: Eventually this should be extracted to its own repo.
 */


const Crypto = {
  AES,
  ECDSA,
  ECIES,
  Hash,
  RSA,
  BitcoinMessage
};
module.exports = Crypto;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);

const util = __webpack_require__(21);
/**
 * TODO
 */


const GCM = {
  /**
   * TODO
   */
  async encrypt(data, key, opts = {}) {
    if (!binary.is(data)) data = binary.from(data);
    const encKey = await util.importKey(key, {
      name: 'AES-GCM'
    }, ['encrypt']);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aad = opts.add ? binary.from(opts.add) : undefined;
    const encData = await crypto.subtle.encrypt({
      name: 'AES-GCM',
      iv: iv,
      additionalData: aad
    }, encKey, data);
    const buf = binary.join([iv, binary.from(encData)]);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async decrypt(data, key, opts = {}) {
    if (opts.encoding) data = util.decode(data, opts.encoding);
    const encKey = await util.importKey(key, {
      name: 'AES-GCM'
    }, ['decrypt']);
    const iv = binary.subarray(data, 0, 12);
    const encData = binary.subarray(data, 12);
    const aad = opts.add ? binary.from(opts.add) : undefined;
    const decData = await crypto.subtle.decrypt({
      name: 'AES-GCM',
      iv: iv,
      additionalData: aad
    }, encKey, encData);
    return binary.from(decData);
  }

};
module.exports = {
  GCM
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const Hash = __webpack_require__(25);

const {
  secp256k1Loader
} = __webpack_require__(26);
/**
 * TODO
 */


const ECDSA = {
  /**
   * TODO
   */
  async sign(data, privKey, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    if (!binary.is(data)) data = binary.from(data);
    if (opts.hash) data = await Hash.sha256(data);
    const sig = secp256k1.signMessageHashDER(privKey, data);
    buf = binary.from(sig);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async verify(sig, data, pubKey, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    if (opts.encoding) sig = util.decode(sig, opts.encoding);
    if (!binary.is(data)) data = binary.from(data);
    if (opts.hash) data = await Hash.sha256(data);
    return secp256k1.verifySignatureDER(sig, pubKey, data);
  }

};
module.exports = ECDSA;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(78);

var ieee754 = __webpack_require__(79);

var isArray = __webpack_require__(80);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(77)))

/***/ }),
/* 77 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 79 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);

const Hash = __webpack_require__(25);

const util = __webpack_require__(21);

const {
  secp256k1Loader
} = __webpack_require__(26);
/**
 * TODO
 */


const ECIES = {
  /**
   * TODO
   */
  async encrypt(data, pubKey, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    if (!binary.is(data)) data = binary.from(data); // Generate ephemeral keys

    const ephemeralPrivKey = new Uint8Array(32);
    crypto.getRandomValues(ephemeralPrivKey);
    const ephemeralPubKey = secp256k1.derivePublicKeyCompressed(ephemeralPrivKey); // Derive ECDH key and sha512 hash

    const sharedKey = secp256k1.mulTweakPublicKeyCompressed(pubKey, ephemeralPrivKey);
    const keyHash = await Hash.sha512(sharedKey); // iv and keyE used in AES, keyM used in HMAC

    const iv = binary.subarray(keyHash, 0, 16),
          keyE = binary.subarray(keyHash, 16, 32),
          keyM = binary.subarray(keyHash, 32); // Create cyphertext

    const encKey = await util.importKey(keyE, {
      name: 'AES-CBC'
    }, ['encrypt']);
    const cyphertext = await crypto.subtle.encrypt({
      name: 'AES-CBC',
      iv: iv
    }, encKey, data); // Concatenate encrypted data with hmac

    const encData = binary.join([binary.from('BIE1'), ephemeralPubKey, binary.from(cyphertext)]);
    const hmacKey = await util.importKey(keyM, {
      name: 'HMAC',
      hash: 'SHA-256'
    }, ['sign']);
    const mac = await crypto.subtle.sign({
      name: 'HMAC'
    }, hmacKey, encData);
    const buf = binary.join([encData, binary.from(mac)]);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async decrypt(data, privKey, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    if (opts.encoding) data = util.decode(data, opts.encoding);
    const len = data.length - 69,
          prefix = binary.subarray(data, 0, 4),
          ephemeralPubKey = binary.subarray(data, 4, 4 + 33),
          cyphertext = binary.subarray(data, 4 + 33, 4 + 33 + len),
          mac = binary.subarray(data, 4 + 33 + len); // Derive ECDH key and sha512 hash

    const pubKey = secp256k1.uncompressPublicKey(ephemeralPubKey);
    const sharedKey = secp256k1.mulTweakPublicKeyCompressed(pubKey, privKey);
    const keyHash = await Hash.sha512(sharedKey); // iv and keyE used in AES, keyM used in HMAC

    const iv = binary.subarray(keyHash, 0, 16),
          keyE = binary.subarray(keyHash, 16, 32),
          keyM = binary.subarray(keyHash, 32); // HMAC validation

    const hmacKey = await util.importKey(keyM, {
      name: 'HMAC',
      hash: 'SHA-256'
    }, ['verify']);
    const verified = await crypto.subtle.verify({
      name: 'HMAC'
    }, hmacKey, mac, binary.subarray(data, 0, -32));
    if (!verified) throw new Error('mac validation failed'); // Decrypt cyphertext

    const encKey = await util.importKey(keyE, {
      name: 'AES-CBC'
    }, ['decrypt']);
    const decData = await crypto.subtle.decrypt({
      name: 'AES-CBC',
      iv: iv
    }, encKey, cyphertext);
    return binary.from(decData);
  }

};
module.exports = ECIES;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);

const util = __webpack_require__(21);
/**
 * TODO
 */


const RSA = {
  /**
   * TODO
   */
  async encrypt(data, key, opts = {}) {
    if (!binary.is(data)) data = binary.from(data);
    const encKey = await util.importKey(key, {
      name: 'RSA-OAEP',
      hash: 'SHA-256'
    }, ['encrypt']);
    const encData = await crypto.subtle.encrypt({
      name: 'RSA-OAEP'
    }, encKey, data);
    const buf = binary.from(encData);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async decrypt(data, key, opts = {}) {
    if (opts.encoding) data = util.decode(data, opts.encoding);
    const encKey = await util.importKey(key, {
      name: 'RSA-OAEP',
      hash: 'SHA-256'
    }, ['decrypt']);
    const decData = await crypto.subtle.decrypt({
      name: 'RSA-OAEP'
    }, encKey, data);
    return binary.from(decData);
  },

  /**
   * TODO
   */
  async sign(data, key, opts = {}) {
    if (!binary.is(data)) data = binary.from(data);
    const privKey = await util.importKey(key, {
      name: 'RSA-PSS',
      hash: 'SHA-256'
    }, ['sign']);
    const sig = await crypto.subtle.sign({
      name: 'RSA-PSS',
      saltLength: 20
    }, privKey, data);
    const buf = binary.from(sig);
    return opts.encoding ? util.encode(buf, opts.encoding) : buf;
  },

  /**
   * TODO
   */
  async verify(sig, data, key, opts = {}) {
    if (opts.encoding) sig = util.decode(sig, opts.encoding);
    if (!binary.is(data)) data = binary.from(data);
    const pubKey = await util.importKey(key, {
      name: 'RSA-PSS',
      hash: 'SHA-256'
    }, ['verify']);
    return crypto.subtle.verify({
      name: 'RSA-PSS',
      saltLength: 20
    }, pubKey, sig, data);
  }

};
module.exports = RSA;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

const binary = __webpack_require__(3);

const crypto = __webpack_require__(19);

const isUtf8 = __webpack_require__(28);

const Hash = __webpack_require__(25);

const util = __webpack_require__(21);

const {
  secp256k1Loader
} = __webpack_require__(26);
/**
 * TODO
 */


const BitcoinMessage = {
  /**
   * TODO
   */
  async sign(message, key, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    if (!binary.is(message)) message = binary.from(message);
    const encoding = opts.encoding || 'base64';
    const isCompressed = opts.compressed || true;
    const hash = await this.messageDigest(message);
    const {
      recoveryId,
      signature
    } = secp256k1.signMessageHashRecoverableCompact(key, hash);
    const buf = binary.join([this.sigPrefix(recoveryId, isCompressed), binary.from(signature)]);
    return encoding ? util.encode(buf, encoding) : buf;
  },

  /**
   * TODO
   */
  async verify(signature, message, key, opts = {}) {
    const secp256k1 = await secp256k1Loader();
    const encoding = opts.encoding || 'base64';
    if (encoding) signature = util.decode(signature, encoding);
    if (!binary.is(message)) message = binary.from(message);
    const prefix = binary.readUInt8(signature, 0);
    const sig = binary.subarray(signature, 1);
    const isCompressed = prefix > 30;
    const recoveryId = prefix - (isCompressed ? 31 : 27);
    const hash = await this.messageDigest(message);

    if (typeof key === 'string') {
      try {
        key = isCompressed ? secp256k1.recoverPublicKeyCompressed(sig, recoveryId, hash) : secp256k1.recoverPublicKeyUncompressed(sig, recoveryId, hash);
      } catch (e) {
        return false;
      }
    }

    return secp256k1.verifySignatureCompact(sig, key, hash);
  },

  messageDigest(message) {
    const prefix = binary.from('Bitcoin Signed Message:\n');
    const data = binary.join([util.varIntEncode(prefix.length), prefix, util.varIntEncode(message.length), message]);
    return Hash.sha256sha256(data);
  },

  sigPrefix(recovery, isCompressed) {
    const n = isCompressed ? 31 : 27;
    const buf = binary.create(1);
    binary.writeUInt8(buf, Number(recovery) + n);
    return buf;
  }

};
module.exports = BitcoinMessage;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

const Extension = __webpack_require__(20);

const util = __webpack_require__(24);
/**
 * Extends the VM state with functions for encoding and decoding JSON.
 *
 * @class
 * @extends Extension
 * @category Extensions
 * @hideconstructor
 */


class JsonExtension extends Extension {
  static extend(vm) {
    vm.set('json', []).setFunction('json.encode', this.encode).setFunction('json.decode', this.decode);
  }
  /**
   * Encodes the given value into a JSON string
   */


  static encode(val) {
    if (val instanceof Map) val = util.mapToObject(val);
    return JSON.stringify(val);
  }
  /**
   * Decodes the given JSON string.
   */


  static decode(val) {
    val = JSON.parse(val);
    return val;
  }

}

module.exports = JsonExtension;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

const {
  URL,
  URLSearchParams
} = __webpack_require__(47);

const fetch = __webpack_require__(48);

const binary = __webpack_require__(3);

const Adapter = __webpack_require__(27);

const baseUrl = 'https://bob.planaria.network/q/1GgmC7Cg782YtQ6R9QkM58voyWeQJmJJzG/';
/**
 * Adapter module for loading tapes and Ops from [BOB](https://bob.planaria.network).
 *
 * @class
 * @extends Adapter
 * @category Adapters
 * @hideconstructor
 */

class BobAdapter extends Adapter {
  /**
   * Fetches a transaction by the given txid, and returns a Promise.
   *
   * @static
   * @param {String} txid Transaction id
   * @param {Object} opts Options
   * @return {Promise}
   */
  static fetchTx(txid, opts = {}) {
    opts = {
      apiKey: 'op_test',
      ...opts
    };

    const path = this._encodeQuery({
      "v": "3",
      "q": {
        "find": {
          "tx.h": txid,
          "out.tape": {
            "$elemMatch": {
              "i": 0,
              "cell.op": 106
            }
          }
        },
        "limit": 1
      }
    });

    const url = new URL(baseUrl + path);
    const headers = {
      key: opts.apiKey
    };
    return fetch(url, {
      headers
    }).then(r => r.json()).then(data => this._toBPU(data)[0]);
  }
  /**
   * Fetches a list of transactions by the given query object, and returns a Promise.
   *
   * The `query` parameter should be a valid Bitquery. The `project` attribute
   * cannot be used and unless otherwise specified, `limit` defaults to `10`.
   *
   * @static
   * @param {Object} query Query object
   * @param {Object} opts Options
   * @return {Promise}
   */


  static fetchTxBy(query, opts = {}) {
    opts = {
      apiKey: 'op_test',
      ...opts
    };
    delete query.project;

    const path = this._encodeQuery({
      "v": "3",
      "q": {
        "limit": 10,
        ...query
      }
    });

    const url = new URL(baseUrl + path);
    const headers = {
      key: opts.apiKey
    };
    return fetch(url, {
      headers
    }).then(r => r.json()).then(data => this._toBPU(data));
  }
  /**
   * Normalise response in standard BPU format
   * @private
   */


  static _toBPU(data) {
    return data.c.concat(data.u).map(tx => {
      tx.txid = tx.tx.h;
      delete tx.tx;
      tx.out.forEach(o => {
        if (o.e && o.e.a === "false") o.e.a = null;
      });
      return tx;
    });
  }
  /**
   * Encodes map into Fat URI path
   * @private
   */


  static _encodeQuery(query) {
    const str = JSON.stringify(query),
          buf = binary.from(str);
    return binary.to(buf, 'base64');
  }

}

module.exports = BobAdapter;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

const {
  URL,
  URLSearchParams
} = __webpack_require__(47);

const fetch = __webpack_require__(48);

const Adapter = __webpack_require__(27);

const baseUrl = 'https://api.operatebsv.org';
/**
 * Adapter module for loading Ops from the [Operate API](http://api.operatebsv.org).
 *
 * @class
 * @extends Adapter
 * @category Adapters
 * @hideconstructor
 */

class OpApiAdapter extends Adapter {
  /**
   * Fetches a list of Ops by the given list of Op references, and returns a Promise.
   *
   * @static
   * @param {Array} refs Op references
   * @param {Object} opts Options
   * @return {Promise}
   */
  static fetchOps(refs, opts = {}) {
    const url = new URL(baseUrl + '/ops');
    url.search = new URLSearchParams({
      refs,
      fn: true
    }).toString();
    return fetch(url).then(r => r.json()).then(data => data.data.map(this._toOp));
  }
  /**
   * Normalise response in standard Op format
   * @private
   */


  static _toOp(r) {
    return {
      ref: r.ref,
      hash: r.hash,
      name: r.name,
      fn: r.fn
    };
  }

}

module.exports = OpApiAdapter;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

const Cache = __webpack_require__(88);
/**
 * Cache module for implementing no caching.
 *
 * This is the default cache module, and allows Operate to run without any
 * caching, simply by forwarding and requests for tapes or ops to the
 * configured adpater module(s) skipping any cache layers.
 *
 * @class
 * @extends Cache
 * @category Caches
 * @hideconstructor
 */


class NoCache extends Cache {}

module.exports = NoCache;

/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * A cache is responsible for storing and retrieving tapes and ops from a
 * cache, and if necessary instructing an adapter to fetch items from a data
 * source.
 *
 * A cache must implement all of the following callbacks:
 *
 * * `fetchTx()`
 * * `fetchTxBy()`
 * * `fetchOps()`
 *
 * @interface
 * @hideconstructor
 */
class Cache {
  /**
   * Loads a transaction from the cache by the given txid, or delegates to job
   * to the specified adapter.
   *
   * @static
   * @param {String} txid Transaction id
   * @param {Object} opts Options
   * @return {Promise}
   */
  static fetchTx(txid, opts = {}, [adapter, adapterOpts]) {
    return adapter.fetchTx(txid, adapterOpts);
  }
  /**
   * Loads a list of transactions from the cache by the given query map, or
   * delegates to job to the specified adapter.
   *
   * @static
   * @param {Object} query Query object
   * @param {Object} opts Options
   * @return {Promise}
   */


  static fetchTxBy(query, opts = {}, [adapter, adapterOpts]) {
    return adapter.fetchTxBy(query, adapterOpts);
  }
  /**
   * Loads Ops from the cache by the given procedure referneces, or delegates
   * the job to the specified adapter.
   *
   * @static
   * @param {Array} refs Op references
   * @param {Object} opts Options
   * @return {Promise}
   */


  static fetchOps(refs, opts = {}, [adapter, adapterOpts]) {
    return adapter.fetchOps(refs, adapterOpts);
  }

}

module.exports = Cache;

/***/ }),
/* 89 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@operate/agent\",\"version\":\"0.1.0-beta.1\",\"description\":\"Operate JavaScript agent used to load and run Bitcoin programs.\",\"main\":\"lib/index.js\",\"browser\":\"dist/operate.min.js\",\"homepage\":\"https://www.operatebsv.org\",\"repository\":\"github.com:operate-bsv/op_agent-js\",\"author\":\"Chronos Labs Ltd\",\"license\":\"MIT\",\"scripts\":{\"build\":\"rimraf dist && webpack --config ./webpack.config.js\",\"docs\":\"rimraf docs && jsdoc -c ./jsdoc.config.js\",\"test\":\"mocha \\\"test/**/*.test.js\\\"\"},\"dependencies\":{\"bitcoin-ts\":\"^1.12.0\",\"bops\":\"libitx/bops\",\"fengari\":\"^0.1.4\",\"isomorphic-webcrypto\":\"^2.3.5\",\"isutf8\":\"^2.1.0\",\"node-fetch\":\"^2.6.0\"},\"devDependencies\":{\"@babel/core\":\"^7.8.6\",\"@babel/plugin-proposal-nullish-coalescing-operator\":\"^7.8.3\",\"@babel/plugin-proposal-optional-chaining\":\"^7.8.3\",\"@babel/preset-env\":\"^7.8.6\",\"@babel/preset-es2017\":\"^7.0.0-beta.53\",\"babel-loader\":\"^8.0.6\",\"better-docs\":\"^1.4.7\",\"chai\":\"^4.2.0\",\"chai-as-promised\":\"^7.1.1\",\"jsdoc\":\"^3.6.3\",\"mocha\":\"^7.0.0\",\"nock\":\"^11.7.1\",\"rimraf\":\"^3.0.2\",\"terser-webpack-plugin\":\"^2.3.5\",\"webpack\":\"^4.42.0\",\"webpack-cli\":\"^3.3.11\"}}");

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "instantiateRustWasm", function() { return /* reexport */ instantiateRustWasm; });
__webpack_require__.d(__webpack_exports__, "ripemd160Base64Bytes", function() { return /* reexport */ ripemd160Base64Bytes; });
__webpack_require__.d(__webpack_exports__, "ContextFlag", function() { return /* reexport */ ContextFlag; });
__webpack_require__.d(__webpack_exports__, "CompressionFlag", function() { return /* reexport */ CompressionFlag; });
__webpack_require__.d(__webpack_exports__, "instantiateSecp256k1WasmBytes", function() { return /* reexport */ instantiateSecp256k1WasmBytes; });
__webpack_require__.d(__webpack_exports__, "getEmbeddedSecp256k1Binary", function() { return /* reexport */ getEmbeddedSecp256k1Binary; });
__webpack_require__.d(__webpack_exports__, "instantiateSecp256k1Wasm", function() { return /* reexport */ instantiateSecp256k1Wasm; });
__webpack_require__.d(__webpack_exports__, "sha1Base64Bytes", function() { return /* reexport */ sha1Base64Bytes; });
__webpack_require__.d(__webpack_exports__, "sha256Base64Bytes", function() { return /* reexport */ sha256Base64Bytes; });
__webpack_require__.d(__webpack_exports__, "sha512Base64Bytes", function() { return /* reexport */ sha512Base64Bytes; });
__webpack_require__.d(__webpack_exports__, "instantiateSecp256k1Bytes", function() { return /* reexport */ instantiateSecp256k1Bytes; });
__webpack_require__.d(__webpack_exports__, "instantiateSecp256k1", function() { return /* reexport */ instantiateSecp256k1; });
__webpack_require__.d(__webpack_exports__, "instantiateRipemd160Bytes", function() { return /* reexport */ instantiateRipemd160Bytes; });
__webpack_require__.d(__webpack_exports__, "getEmbeddedRipemd160Binary", function() { return /* reexport */ getEmbeddedRipemd160Binary; });
__webpack_require__.d(__webpack_exports__, "instantiateRipemd160", function() { return /* reexport */ instantiateRipemd160; });
__webpack_require__.d(__webpack_exports__, "instantiateSha1Bytes", function() { return /* reexport */ instantiateSha1Bytes; });
__webpack_require__.d(__webpack_exports__, "getEmbeddedSha1Binary", function() { return /* reexport */ getEmbeddedSha1Binary; });
__webpack_require__.d(__webpack_exports__, "instantiateSha1", function() { return /* reexport */ instantiateSha1; });
__webpack_require__.d(__webpack_exports__, "instantiateSha256Bytes", function() { return /* reexport */ instantiateSha256Bytes; });
__webpack_require__.d(__webpack_exports__, "getEmbeddedSha256Binary", function() { return /* reexport */ getEmbeddedSha256Binary; });
__webpack_require__.d(__webpack_exports__, "instantiateSha256", function() { return /* reexport */ instantiateSha256; });
__webpack_require__.d(__webpack_exports__, "instantiateSha512Bytes", function() { return /* reexport */ instantiateSha512Bytes; });
__webpack_require__.d(__webpack_exports__, "getEmbeddedSha512Binary", function() { return /* reexport */ getEmbeddedSha512Binary; });
__webpack_require__.d(__webpack_exports__, "instantiateSha512", function() { return /* reexport */ instantiateSha512; });
__webpack_require__.d(__webpack_exports__, "OpcodesBTC", function() { return /* reexport */ OpcodesBTC; });
__webpack_require__.d(__webpack_exports__, "OpcodeDescriptionsUniqueBCH", function() { return /* reexport */ OpcodeDescriptionsUniqueBCH; });
__webpack_require__.d(__webpack_exports__, "OpcodeDescriptionsBCH", function() { return /* reexport */ OpcodeDescriptionsBCH; });
__webpack_require__.d(__webpack_exports__, "AuthenticationErrorBCH", function() { return /* reexport */ AuthenticationErrorBCH; });
__webpack_require__.d(__webpack_exports__, "OpcodesBCH", function() { return /* reexport */ OpcodesBCH; });
__webpack_require__.d(__webpack_exports__, "isPayToScriptHash", function() { return /* reexport */ isPayToScriptHash; });
__webpack_require__.d(__webpack_exports__, "isWitnessProgram", function() { return /* reexport */ isWitnessProgram; });
__webpack_require__.d(__webpack_exports__, "InstructionSetBCH", function() { return /* reexport */ InstructionSetBCH; });
__webpack_require__.d(__webpack_exports__, "instructionSetBCHCurrentStrict", function() { return /* reexport */ instructionSetBCHCurrentStrict; });
__webpack_require__.d(__webpack_exports__, "getFlagsForInstructionSetBCH", function() { return /* reexport */ getFlagsForInstructionSetBCH; });
__webpack_require__.d(__webpack_exports__, "createInstructionSetBCH", function() { return /* reexport */ createInstructionSetBCH; });
__webpack_require__.d(__webpack_exports__, "OpcodeAlternateNamesBCH", function() { return /* reexport */ OpcodeAlternateNamesBCH; });
__webpack_require__.d(__webpack_exports__, "opCat", function() { return /* reexport */ opCat; });
__webpack_require__.d(__webpack_exports__, "opSplit", function() { return /* reexport */ opSplit; });
__webpack_require__.d(__webpack_exports__, "padMinimallyEncodedScriptNumber", function() { return /* reexport */ padMinimallyEncodedScriptNumber; });
__webpack_require__.d(__webpack_exports__, "opNum2Bin", function() { return /* reexport */ opNum2Bin; });
__webpack_require__.d(__webpack_exports__, "opBin2Num", function() { return /* reexport */ opBin2Num; });
__webpack_require__.d(__webpack_exports__, "bitwiseOperation", function() { return /* reexport */ bitwiseOperation; });
__webpack_require__.d(__webpack_exports__, "opAnd", function() { return /* reexport */ opAnd; });
__webpack_require__.d(__webpack_exports__, "opOr", function() { return /* reexport */ opOr; });
__webpack_require__.d(__webpack_exports__, "opXor", function() { return /* reexport */ opXor; });
__webpack_require__.d(__webpack_exports__, "opDiv", function() { return /* reexport */ opDiv; });
__webpack_require__.d(__webpack_exports__, "opMod", function() { return /* reexport */ opMod; });
__webpack_require__.d(__webpack_exports__, "isValidSignatureEncodingBCHRaw", function() { return /* reexport */ isValidSignatureEncodingBCHRaw; });
__webpack_require__.d(__webpack_exports__, "opCheckDataSig", function() { return /* reexport */ opCheckDataSig; });
__webpack_require__.d(__webpack_exports__, "opCheckDataSigVerify", function() { return /* reexport */ opCheckDataSigVerify; });
__webpack_require__.d(__webpack_exports__, "bitcoinCashOperations", function() { return /* reexport */ bitcoinCashOperations; });
__webpack_require__.d(__webpack_exports__, "ConsensusBCH", function() { return /* reexport */ ConsensusBCH; });
__webpack_require__.d(__webpack_exports__, "createTestAuthenticationProgramBCH", function() { return /* reexport */ createTestAuthenticationProgramBCH; });
__webpack_require__.d(__webpack_exports__, "bitcoinABCOpcodes", function() { return /* reexport */ bitcoinABCOpcodes; });
__webpack_require__.d(__webpack_exports__, "assembleBitcoinABCScript", function() { return /* reexport */ assembleBitcoinABCScript; });
__webpack_require__.d(__webpack_exports__, "instantiateVirtualMachineBCH", function() { return /* reexport */ instantiateVirtualMachineBCH; });
__webpack_require__.d(__webpack_exports__, "op1Add", function() { return /* reexport */ op1Add; });
__webpack_require__.d(__webpack_exports__, "op1Sub", function() { return /* reexport */ op1Sub; });
__webpack_require__.d(__webpack_exports__, "opNegate", function() { return /* reexport */ opNegate; });
__webpack_require__.d(__webpack_exports__, "opAbs", function() { return /* reexport */ opAbs; });
__webpack_require__.d(__webpack_exports__, "opNot", function() { return /* reexport */ opNot; });
__webpack_require__.d(__webpack_exports__, "op0NotEqual", function() { return /* reexport */ op0NotEqual; });
__webpack_require__.d(__webpack_exports__, "opAdd", function() { return /* reexport */ opAdd; });
__webpack_require__.d(__webpack_exports__, "opSub", function() { return /* reexport */ opSub; });
__webpack_require__.d(__webpack_exports__, "opBoolAnd", function() { return /* reexport */ opBoolAnd; });
__webpack_require__.d(__webpack_exports__, "opBoolOr", function() { return /* reexport */ opBoolOr; });
__webpack_require__.d(__webpack_exports__, "opNumEqual", function() { return /* reexport */ opNumEqual; });
__webpack_require__.d(__webpack_exports__, "opNumEqualVerify", function() { return /* reexport */ opNumEqualVerify; });
__webpack_require__.d(__webpack_exports__, "opNumNotEqual", function() { return /* reexport */ opNumNotEqual; });
__webpack_require__.d(__webpack_exports__, "opLessThan", function() { return /* reexport */ opLessThan; });
__webpack_require__.d(__webpack_exports__, "opLessThanOrEqual", function() { return /* reexport */ opLessThanOrEqual; });
__webpack_require__.d(__webpack_exports__, "opGreaterThan", function() { return /* reexport */ opGreaterThan; });
__webpack_require__.d(__webpack_exports__, "opGreaterThanOrEqual", function() { return /* reexport */ opGreaterThanOrEqual; });
__webpack_require__.d(__webpack_exports__, "opMin", function() { return /* reexport */ opMin; });
__webpack_require__.d(__webpack_exports__, "opMax", function() { return /* reexport */ opMax; });
__webpack_require__.d(__webpack_exports__, "opWithin", function() { return /* reexport */ opWithin; });
__webpack_require__.d(__webpack_exports__, "arithmeticOperations", function() { return /* reexport */ arithmeticOperations; });
__webpack_require__.d(__webpack_exports__, "opEqual", function() { return /* reexport */ opEqual; });
__webpack_require__.d(__webpack_exports__, "opEqualVerify", function() { return /* reexport */ opEqualVerify; });
__webpack_require__.d(__webpack_exports__, "bitwiseOperations", function() { return /* reexport */ bitwiseOperations; });
__webpack_require__.d(__webpack_exports__, "incrementOperationCount", function() { return /* reexport */ incrementOperationCount; });
__webpack_require__.d(__webpack_exports__, "conditionallyEvaluate", function() { return /* reexport */ conditionallyEvaluate; });
__webpack_require__.d(__webpack_exports__, "mapOverOperations", function() { return /* reexport */ mapOverOperations; });
__webpack_require__.d(__webpack_exports__, "useOneStackItem", function() { return /* reexport */ useOneStackItem; });
__webpack_require__.d(__webpack_exports__, "useTwoStackItems", function() { return /* reexport */ useTwoStackItems; });
__webpack_require__.d(__webpack_exports__, "useThreeStackItems", function() { return /* reexport */ useThreeStackItems; });
__webpack_require__.d(__webpack_exports__, "useFourStackItems", function() { return /* reexport */ useFourStackItems; });
__webpack_require__.d(__webpack_exports__, "useSixStackItems", function() { return /* reexport */ useSixStackItems; });
__webpack_require__.d(__webpack_exports__, "useOneScriptNumber", function() { return /* reexport */ useOneScriptNumber; });
__webpack_require__.d(__webpack_exports__, "useTwoScriptNumbers", function() { return /* reexport */ useTwoScriptNumbers; });
__webpack_require__.d(__webpack_exports__, "useThreeScriptNumbers", function() { return /* reexport */ useThreeScriptNumbers; });
__webpack_require__.d(__webpack_exports__, "pushToStack", function() { return /* reexport */ pushToStack; });
__webpack_require__.d(__webpack_exports__, "combineOperations", function() { return /* reexport */ combineOperations; });
__webpack_require__.d(__webpack_exports__, "opRipemd160", function() { return /* reexport */ opRipemd160; });
__webpack_require__.d(__webpack_exports__, "opSha1", function() { return /* reexport */ opSha1; });
__webpack_require__.d(__webpack_exports__, "opSha256", function() { return /* reexport */ opSha256; });
__webpack_require__.d(__webpack_exports__, "opHash160", function() { return /* reexport */ opHash160; });
__webpack_require__.d(__webpack_exports__, "opHash256", function() { return /* reexport */ opHash256; });
__webpack_require__.d(__webpack_exports__, "opCodeSeparator", function() { return /* reexport */ opCodeSeparator; });
__webpack_require__.d(__webpack_exports__, "opCheckSig", function() { return /* reexport */ opCheckSig; });
__webpack_require__.d(__webpack_exports__, "opCheckMultiSig", function() { return /* reexport */ opCheckMultiSig; });
__webpack_require__.d(__webpack_exports__, "opCheckSigVerify", function() { return /* reexport */ opCheckSigVerify; });
__webpack_require__.d(__webpack_exports__, "opCheckMultiSigVerify", function() { return /* reexport */ opCheckMultiSigVerify; });
__webpack_require__.d(__webpack_exports__, "cryptoOperations", function() { return /* reexport */ cryptoOperations; });
__webpack_require__.d(__webpack_exports__, "OpcodeDescriptionsCommon", function() { return /* reexport */ OpcodeDescriptionsCommon; });
__webpack_require__.d(__webpack_exports__, "isValidUncompressedPublicKeyEncoding", function() { return /* reexport */ isValidUncompressedPublicKeyEncoding; });
__webpack_require__.d(__webpack_exports__, "isValidCompressedPublicKeyEncoding", function() { return /* reexport */ isValidCompressedPublicKeyEncoding; });
__webpack_require__.d(__webpack_exports__, "isValidPublicKeyEncoding", function() { return /* reexport */ isValidPublicKeyEncoding; });
__webpack_require__.d(__webpack_exports__, "isValidSignatureEncodingDER", function() { return /* reexport */ isValidSignatureEncodingDER; });
__webpack_require__.d(__webpack_exports__, "isValidSignatureEncodingBCHTransaction", function() { return /* reexport */ isValidSignatureEncodingBCHTransaction; });
__webpack_require__.d(__webpack_exports__, "decodeBitcoinSignature", function() { return /* reexport */ decodeBitcoinSignature; });
__webpack_require__.d(__webpack_exports__, "AuthenticationErrorCommon", function() { return /* reexport */ AuthenticationErrorCommon; });
__webpack_require__.d(__webpack_exports__, "applyError", function() { return /* reexport */ applyError; });
__webpack_require__.d(__webpack_exports__, "opVerify", function() { return /* reexport */ opVerify; });
__webpack_require__.d(__webpack_exports__, "reservedOperation", function() { return /* reexport */ reservedOperation; });
__webpack_require__.d(__webpack_exports__, "opReturn", function() { return /* reexport */ opReturn; });
__webpack_require__.d(__webpack_exports__, "conditionalFlowControlOperations", function() { return /* reexport */ conditionalFlowControlOperations; });
__webpack_require__.d(__webpack_exports__, "opIf", function() { return /* reexport */ opIf; });
__webpack_require__.d(__webpack_exports__, "opNotIf", function() { return /* reexport */ opNotIf; });
__webpack_require__.d(__webpack_exports__, "opEndIf", function() { return /* reexport */ opEndIf; });
__webpack_require__.d(__webpack_exports__, "opElse", function() { return /* reexport */ opElse; });
__webpack_require__.d(__webpack_exports__, "unconditionalFlowControlOperations", function() { return /* reexport */ unconditionalFlowControlOperations; });
__webpack_require__.d(__webpack_exports__, "opNop", function() { return /* reexport */ opNop; });
__webpack_require__.d(__webpack_exports__, "nonOperations", function() { return /* reexport */ nonOperations; });
__webpack_require__.d(__webpack_exports__, "disabledOperation", function() { return /* reexport */ disabledOperation; });
__webpack_require__.d(__webpack_exports__, "disabledOperations", function() { return /* reexport */ disabledOperations; });
__webpack_require__.d(__webpack_exports__, "OpcodesCommon", function() { return /* reexport */ OpcodesCommon; });
__webpack_require__.d(__webpack_exports__, "PushOperationConstants", function() { return /* reexport */ PushOperationConstants; });
__webpack_require__.d(__webpack_exports__, "encodeDataPush", function() { return /* reexport */ encodeDataPush; });
__webpack_require__.d(__webpack_exports__, "isMinimalDataPush", function() { return /* reexport */ isMinimalDataPush; });
__webpack_require__.d(__webpack_exports__, "pushByteOpcodes", function() { return /* reexport */ pushByteOpcodes; });
__webpack_require__.d(__webpack_exports__, "pushOperation", function() { return /* reexport */ pushOperation; });
__webpack_require__.d(__webpack_exports__, "pushOperations", function() { return /* reexport */ pushOperations; });
__webpack_require__.d(__webpack_exports__, "pushNumberOpcodes", function() { return /* reexport */ pushNumberOpcodes; });
__webpack_require__.d(__webpack_exports__, "pushNumberOperations", function() { return /* reexport */ pushNumberOperations; });
__webpack_require__.d(__webpack_exports__, "SigningSerializationFlag", function() { return /* reexport */ SigningSerializationFlag; });
__webpack_require__.d(__webpack_exports__, "isDefinedSigningSerializationType", function() { return /* reexport */ isDefinedSigningSerializationType; });
__webpack_require__.d(__webpack_exports__, "hashPrevouts", function() { return /* reexport */ hashPrevouts; });
__webpack_require__.d(__webpack_exports__, "hashSequence", function() { return /* reexport */ hashSequence; });
__webpack_require__.d(__webpack_exports__, "hashOutputs", function() { return /* reexport */ hashOutputs; });
__webpack_require__.d(__webpack_exports__, "generateSigningSerializationBCH", function() { return /* reexport */ generateSigningSerializationBCH; });
__webpack_require__.d(__webpack_exports__, "isLegacySigningSerialization", function() { return /* reexport */ isLegacySigningSerialization; });
__webpack_require__.d(__webpack_exports__, "opSize", function() { return /* reexport */ opSize; });
__webpack_require__.d(__webpack_exports__, "spliceOperations", function() { return /* reexport */ spliceOperations; });
__webpack_require__.d(__webpack_exports__, "opToAltStack", function() { return /* reexport */ opToAltStack; });
__webpack_require__.d(__webpack_exports__, "opFromAltStack", function() { return /* reexport */ opFromAltStack; });
__webpack_require__.d(__webpack_exports__, "op2Drop", function() { return /* reexport */ op2Drop; });
__webpack_require__.d(__webpack_exports__, "op2Dup", function() { return /* reexport */ op2Dup; });
__webpack_require__.d(__webpack_exports__, "op3Dup", function() { return /* reexport */ op3Dup; });
__webpack_require__.d(__webpack_exports__, "op2Over", function() { return /* reexport */ op2Over; });
__webpack_require__.d(__webpack_exports__, "op2Rot", function() { return /* reexport */ op2Rot; });
__webpack_require__.d(__webpack_exports__, "op2Swap", function() { return /* reexport */ op2Swap; });
__webpack_require__.d(__webpack_exports__, "opIfDup", function() { return /* reexport */ opIfDup; });
__webpack_require__.d(__webpack_exports__, "opDepth", function() { return /* reexport */ opDepth; });
__webpack_require__.d(__webpack_exports__, "opDrop", function() { return /* reexport */ opDrop; });
__webpack_require__.d(__webpack_exports__, "opDup", function() { return /* reexport */ opDup; });
__webpack_require__.d(__webpack_exports__, "opNip", function() { return /* reexport */ opNip; });
__webpack_require__.d(__webpack_exports__, "opOver", function() { return /* reexport */ opOver; });
__webpack_require__.d(__webpack_exports__, "opPick", function() { return /* reexport */ opPick; });
__webpack_require__.d(__webpack_exports__, "opRoll", function() { return /* reexport */ opRoll; });
__webpack_require__.d(__webpack_exports__, "opRot", function() { return /* reexport */ opRot; });
__webpack_require__.d(__webpack_exports__, "opSwap", function() { return /* reexport */ opSwap; });
__webpack_require__.d(__webpack_exports__, "opTuck", function() { return /* reexport */ opTuck; });
__webpack_require__.d(__webpack_exports__, "stackOperations", function() { return /* reexport */ stackOperations; });
__webpack_require__.d(__webpack_exports__, "readLocktime", function() { return /* reexport */ readLocktime; });
__webpack_require__.d(__webpack_exports__, "opCheckLockTimeVerify", function() { return /* reexport */ opCheckLockTimeVerify; });
__webpack_require__.d(__webpack_exports__, "opCheckSequenceVerify", function() { return /* reexport */ opCheckSequenceVerify; });
__webpack_require__.d(__webpack_exports__, "timeOperations", function() { return /* reexport */ timeOperations; });
__webpack_require__.d(__webpack_exports__, "ScriptNumberError", function() { return /* reexport */ ScriptNumberError; });
__webpack_require__.d(__webpack_exports__, "isScriptNumberError", function() { return /* reexport */ isScriptNumberError; });
__webpack_require__.d(__webpack_exports__, "parseBytesAsScriptNumber", function() { return /* reexport */ parseBytesAsScriptNumber; });
__webpack_require__.d(__webpack_exports__, "bigIntToScriptNumber", function() { return /* reexport */ bigIntToScriptNumber; });
__webpack_require__.d(__webpack_exports__, "stackItemIsTruthy", function() { return /* reexport */ stackItemIsTruthy; });
__webpack_require__.d(__webpack_exports__, "booleanToScriptNumber", function() { return /* reexport */ booleanToScriptNumber; });
__webpack_require__.d(__webpack_exports__, "ConsensusCommon", function() { return /* reexport */ ConsensusCommon; });
__webpack_require__.d(__webpack_exports__, "undefinedOperation", function() { return /* reexport */ undefinedOperation; });
__webpack_require__.d(__webpack_exports__, "checkLimitsCommon", function() { return /* reexport */ checkLimitsCommon; });
__webpack_require__.d(__webpack_exports__, "commonOperations", function() { return /* reexport */ commonOperations; });
__webpack_require__.d(__webpack_exports__, "cloneStack", function() { return /* reexport */ cloneStack; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationProgramInternalStateCommon", function() { return /* reexport */ createAuthenticationProgramInternalStateCommon; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationProgramExternalStateCommon", function() { return /* reexport */ createAuthenticationProgramExternalStateCommon; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationProgramStateCommon", function() { return /* reexport */ createAuthenticationProgramStateCommon; });
__webpack_require__.d(__webpack_exports__, "cloneAuthenticationProgramStateCommon", function() { return /* reexport */ cloneAuthenticationProgramStateCommon; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationProgramExternalStateCommonEmpty", function() { return /* reexport */ createAuthenticationProgramExternalStateCommonEmpty; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationProgramStateCommonEmpty", function() { return /* reexport */ createAuthenticationProgramStateCommonEmpty; });
__webpack_require__.d(__webpack_exports__, "authenticationInstructionIsMalformed", function() { return /* reexport */ authenticationInstructionIsMalformed; });
__webpack_require__.d(__webpack_exports__, "authenticationInstructionsAreMalformed", function() { return /* reexport */ authenticationInstructionsAreMalformed; });
__webpack_require__.d(__webpack_exports__, "authenticationInstructionsAreNotMalformed", function() { return /* reexport */ authenticationInstructionsAreNotMalformed; });
__webpack_require__.d(__webpack_exports__, "readLittleEndianNumber", function() { return /* reexport */ readLittleEndianNumber; });
__webpack_require__.d(__webpack_exports__, "writeLittleEndianNumber", function() { return /* reexport */ writeLittleEndianNumber; });
__webpack_require__.d(__webpack_exports__, "numberToLittleEndianBin", function() { return /* reexport */ numberToLittleEndianBin; });
__webpack_require__.d(__webpack_exports__, "lengthBytesForPushOpcode", function() { return /* reexport */ lengthBytesForPushOpcode; });
__webpack_require__.d(__webpack_exports__, "readAuthenticationInstruction", function() { return /* reexport */ readAuthenticationInstruction; });
__webpack_require__.d(__webpack_exports__, "parseBytecode", function() { return /* reexport */ parseBytecode; });
__webpack_require__.d(__webpack_exports__, "disassembleParsedAuthenticationInstructionMalformed", function() { return /* reexport */ disassembleParsedAuthenticationInstructionMalformed; });
__webpack_require__.d(__webpack_exports__, "disassembleAuthenticationInstruction", function() { return /* reexport */ disassembleAuthenticationInstruction; });
__webpack_require__.d(__webpack_exports__, "disassembleParsedAuthenticationInstruction", function() { return /* reexport */ disassembleParsedAuthenticationInstruction; });
__webpack_require__.d(__webpack_exports__, "disassembleParsedAuthenticationInstructions", function() { return /* reexport */ disassembleParsedAuthenticationInstructions; });
__webpack_require__.d(__webpack_exports__, "disassembleBytecode", function() { return /* reexport */ disassembleBytecode; });
__webpack_require__.d(__webpack_exports__, "disassembleBytecodeBCH", function() { return /* reexport */ disassembleBytecodeBCH; });
__webpack_require__.d(__webpack_exports__, "disassembleBytecodeBTC", function() { return /* reexport */ disassembleBytecodeBTC; });
__webpack_require__.d(__webpack_exports__, "serializeAuthenticationInstruction", function() { return /* reexport */ serializeAuthenticationInstruction; });
__webpack_require__.d(__webpack_exports__, "serializeParsedAuthenticationInstructionMalformed", function() { return /* reexport */ serializeParsedAuthenticationInstructionMalformed; });
__webpack_require__.d(__webpack_exports__, "serializeParsedAuthenticationInstruction", function() { return /* reexport */ serializeParsedAuthenticationInstruction; });
__webpack_require__.d(__webpack_exports__, "serializeAuthenticationInstructions", function() { return /* reexport */ serializeAuthenticationInstructions; });
__webpack_require__.d(__webpack_exports__, "serializeParsedAuthenticationInstructions", function() { return /* reexport */ serializeParsedAuthenticationInstructions; });
__webpack_require__.d(__webpack_exports__, "generateBytecodeMap", function() { return /* reexport */ generateBytecodeMap; });
__webpack_require__.d(__webpack_exports__, "compileScriptText", function() { return /* reexport */ compileScriptText; });
__webpack_require__.d(__webpack_exports__, "compileScript", function() { return /* reexport */ compileScript; });
__webpack_require__.d(__webpack_exports__, "SigningSerializationAlgorithmIdentifier", function() { return /* reexport */ SigningSerializationAlgorithmIdentifier; });
__webpack_require__.d(__webpack_exports__, "compilerOperationBCHGenerateSignature", function() { return /* reexport */ compilerOperationBCHGenerateSignature; });
__webpack_require__.d(__webpack_exports__, "compilerOperationBCHGenerateDataSignature", function() { return /* reexport */ compilerOperationBCHGenerateDataSignature; });
__webpack_require__.d(__webpack_exports__, "compilerOperationBCHGenerateSigningSerialization", function() { return /* reexport */ compilerOperationBCHGenerateSigningSerialization; });
__webpack_require__.d(__webpack_exports__, "getCompilerOperationsBCH", function() { return /* reexport */ getCompilerOperationsBCH; });
__webpack_require__.d(__webpack_exports__, "createCompiler", function() { return /* reexport */ createCompiler; });
__webpack_require__.d(__webpack_exports__, "createStateCompilerBCH", function() { return /* reexport */ createStateCompilerBCH; });
__webpack_require__.d(__webpack_exports__, "createCompilerBCH", function() { return /* reexport */ createCompilerBCH; });
__webpack_require__.d(__webpack_exports__, "getResolutionErrors", function() { return /* reexport */ getResolutionErrors; });
__webpack_require__.d(__webpack_exports__, "parseScript", function() { return /* reexport */ parseScript; });
__webpack_require__.d(__webpack_exports__, "evaluateInstructionAggregations", function() { return /* reexport */ evaluateInstructionAggregations; });
__webpack_require__.d(__webpack_exports__, "sampledEvaluateReductionTraceNodes", function() { return /* reexport */ sampledEvaluateReductionTraceNodes; });
__webpack_require__.d(__webpack_exports__, "reduceScript", function() { return /* reexport */ reduceScript; });
__webpack_require__.d(__webpack_exports__, "IdentifierResolutionType", function() { return /* reexport */ IdentifierResolutionType; });
__webpack_require__.d(__webpack_exports__, "resolveScriptSegment", function() { return /* reexport */ resolveScriptSegment; });
__webpack_require__.d(__webpack_exports__, "BuiltInVariables", function() { return /* reexport */ BuiltInVariables; });
__webpack_require__.d(__webpack_exports__, "resolveAuthenticationTemplateVariable", function() { return /* reexport */ resolveAuthenticationTemplateVariable; });
__webpack_require__.d(__webpack_exports__, "resolveScriptIdentifier", function() { return /* reexport */ resolveScriptIdentifier; });
__webpack_require__.d(__webpack_exports__, "createIdentifierResolver", function() { return /* reexport */ createIdentifierResolver; });
__webpack_require__.d(__webpack_exports__, "createAuthenticationVirtualMachine", function() { return /* reexport */ createAuthenticationVirtualMachine; });
__webpack_require__.d(__webpack_exports__, "bech32CharacterSet", function() { return /* reexport */ bech32CharacterSet; });
__webpack_require__.d(__webpack_exports__, "bech32CharacterSetIndex", function() { return /* reexport */ bech32CharacterSetIndex; });
__webpack_require__.d(__webpack_exports__, "BitRegroupingError", function() { return /* reexport */ BitRegroupingError; });
__webpack_require__.d(__webpack_exports__, "regroupBits", function() { return /* reexport */ regroupBits; });
__webpack_require__.d(__webpack_exports__, "encodeBech32", function() { return /* reexport */ encodeBech32; });
__webpack_require__.d(__webpack_exports__, "decodeBech32", function() { return /* reexport */ decodeBech32; });
__webpack_require__.d(__webpack_exports__, "isBech32", function() { return /* reexport */ isBech32; });
__webpack_require__.d(__webpack_exports__, "Bech32DecodingError", function() { return /* reexport */ Bech32DecodingError; });
__webpack_require__.d(__webpack_exports__, "bech32PaddedToBin", function() { return /* reexport */ bech32PaddedToBin; });
__webpack_require__.d(__webpack_exports__, "binToBech32Padded", function() { return /* reexport */ binToBech32Padded; });
__webpack_require__.d(__webpack_exports__, "CashAddressNetworkPrefix", function() { return /* reexport */ CashAddressNetworkPrefix; });
__webpack_require__.d(__webpack_exports__, "cashAddressBitToSize", function() { return /* reexport */ cashAddressBitToSize; });
__webpack_require__.d(__webpack_exports__, "cashAddressSizeToBit", function() { return /* reexport */ cashAddressSizeToBit; });
__webpack_require__.d(__webpack_exports__, "CashAddressVersionByte", function() { return /* reexport */ CashAddressVersionByte; });
__webpack_require__.d(__webpack_exports__, "CashAddressType", function() { return /* reexport */ CashAddressType; });
__webpack_require__.d(__webpack_exports__, "encodeCashAddressVersionByte", function() { return /* reexport */ encodeCashAddressVersionByte; });
__webpack_require__.d(__webpack_exports__, "CashAddressVersionByteDecodingError", function() { return /* reexport */ CashAddressVersionByteDecodingError; });
__webpack_require__.d(__webpack_exports__, "decodeCashAddressVersionByte", function() { return /* reexport */ decodeCashAddressVersionByte; });
__webpack_require__.d(__webpack_exports__, "maskCashAddressPrefix", function() { return /* reexport */ maskCashAddressPrefix; });
__webpack_require__.d(__webpack_exports__, "cashAddressPolynomialModulo", function() { return /* reexport */ cashAddressPolynomialModulo; });
__webpack_require__.d(__webpack_exports__, "cashAddressChecksumToUint5Array", function() { return /* reexport */ cashAddressChecksumToUint5Array; });
__webpack_require__.d(__webpack_exports__, "encodeCashAddressFormat", function() { return /* reexport */ encodeCashAddressFormat; });
__webpack_require__.d(__webpack_exports__, "CashAddressEncodingError", function() { return /* reexport */ CashAddressEncodingError; });
__webpack_require__.d(__webpack_exports__, "encodeCashAddress", function() { return /* reexport */ encodeCashAddress; });
__webpack_require__.d(__webpack_exports__, "CashAddressDecodingError", function() { return /* reexport */ CashAddressDecodingError; });
__webpack_require__.d(__webpack_exports__, "decodeCashAddressFormat", function() { return /* reexport */ decodeCashAddressFormat; });
__webpack_require__.d(__webpack_exports__, "decodeCashAddress", function() { return /* reexport */ decodeCashAddress; });
__webpack_require__.d(__webpack_exports__, "decodeCashAddressFormatWithoutPrefix", function() { return /* reexport */ decodeCashAddressFormatWithoutPrefix; });
__webpack_require__.d(__webpack_exports__, "cashAddressPolynomialToCashAddress", function() { return /* reexport */ cashAddressPolynomialToCashAddress; });
__webpack_require__.d(__webpack_exports__, "CashAddressCorrectionError", function() { return /* reexport */ CashAddressCorrectionError; });
__webpack_require__.d(__webpack_exports__, "attemptCashAddressFormatErrorCorrection", function() { return /* reexport */ attemptCashAddressFormatErrorCorrection; });
__webpack_require__.d(__webpack_exports__, "readTransactionInput", function() { return /* reexport */ readTransactionInput; });
__webpack_require__.d(__webpack_exports__, "serializeInput", function() { return /* reexport */ serializeInput; });
__webpack_require__.d(__webpack_exports__, "serializeInputs", function() { return /* reexport */ serializeInputs; });
__webpack_require__.d(__webpack_exports__, "readTransactionOutput", function() { return /* reexport */ readTransactionOutput; });
__webpack_require__.d(__webpack_exports__, "serializeOutput", function() { return /* reexport */ serializeOutput; });
__webpack_require__.d(__webpack_exports__, "serializeOutputsForTransaction", function() { return /* reexport */ serializeOutputsForTransaction; });
__webpack_require__.d(__webpack_exports__, "deserializeTransaction", function() { return /* reexport */ deserializeTransaction; });
__webpack_require__.d(__webpack_exports__, "serializeTransaction", function() { return /* reexport */ serializeTransaction; });
__webpack_require__.d(__webpack_exports__, "getBitcoinIdentifier", function() { return /* reexport */ getBitcoinIdentifier; });
__webpack_require__.d(__webpack_exports__, "getBitcoinTransactionId", function() { return /* reexport */ getBitcoinTransactionId; });
__webpack_require__.d(__webpack_exports__, "serializeOutpoints", function() { return /* reexport */ serializeOutpoints; });
__webpack_require__.d(__webpack_exports__, "serializeOutputsForSigning", function() { return /* reexport */ serializeOutputsForSigning; });
__webpack_require__.d(__webpack_exports__, "serializeSequenceNumbers", function() { return /* reexport */ serializeSequenceNumbers; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ hex_range; });
__webpack_require__.d(__webpack_exports__, "splitEvery", function() { return /* reexport */ splitEvery; });
__webpack_require__.d(__webpack_exports__, "hexToBin", function() { return /* reexport */ hexToBin; });
__webpack_require__.d(__webpack_exports__, "isHex", function() { return /* reexport */ isHex; });
__webpack_require__.d(__webpack_exports__, "binToHex", function() { return /* reexport */ binToHex; });
__webpack_require__.d(__webpack_exports__, "swapEndianness", function() { return /* reexport */ swapEndianness; });
__webpack_require__.d(__webpack_exports__, "flattenBinArray", function() { return /* reexport */ flattenBinArray; });
__webpack_require__.d(__webpack_exports__, "isBase64", function() { return /* reexport */ isBase64; });
__webpack_require__.d(__webpack_exports__, "base64ToBin", function() { return /* reexport */ base64ToBin; });
__webpack_require__.d(__webpack_exports__, "binToBase64", function() { return /* reexport */ binToBase64; });
__webpack_require__.d(__webpack_exports__, "numberToBinUintLE", function() { return /* reexport */ numberToBinUintLE; });
__webpack_require__.d(__webpack_exports__, "numberToBinUint16LE", function() { return /* reexport */ numberToBinUint16LE; });
__webpack_require__.d(__webpack_exports__, "numberToBinUint32LE", function() { return /* reexport */ numberToBinUint32LE; });
__webpack_require__.d(__webpack_exports__, "binToNumberUintLE", function() { return /* reexport */ binToNumberUintLE; });
__webpack_require__.d(__webpack_exports__, "binToNumberUint16LE", function() { return /* reexport */ binToNumberUint16LE; });
__webpack_require__.d(__webpack_exports__, "binToNumberUint32LE", function() { return /* reexport */ binToNumberUint32LE; });
__webpack_require__.d(__webpack_exports__, "bigIntToBinUintLE", function() { return /* reexport */ bigIntToBinUintLE; });
__webpack_require__.d(__webpack_exports__, "bigIntToBinUint64LE", function() { return /* reexport */ bigIntToBinUint64LE; });
__webpack_require__.d(__webpack_exports__, "binToBigIntUintLE", function() { return /* reexport */ binToBigIntUintLE; });
__webpack_require__.d(__webpack_exports__, "binToBigIntUint64LE", function() { return /* reexport */ binToBigIntUint64LE; });
__webpack_require__.d(__webpack_exports__, "readBitcoinVarInt", function() { return /* reexport */ readBitcoinVarInt; });
__webpack_require__.d(__webpack_exports__, "bigIntToBitcoinVarInt", function() { return /* reexport */ bigIntToBitcoinVarInt; });
__webpack_require__.d(__webpack_exports__, "stringify", function() { return /* reexport */ stringify; });
__webpack_require__.d(__webpack_exports__, "dateToLockTime", function() { return /* reexport */ dateToLockTime; });
__webpack_require__.d(__webpack_exports__, "parseLockTime", function() { return /* reexport */ parseLockTime; });
__webpack_require__.d(__webpack_exports__, "utf8ToBin", function() { return /* reexport */ utf8ToBin; });
__webpack_require__.d(__webpack_exports__, "binToUtf8", function() { return /* reexport */ binToUtf8; });

// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/hashes.js
/* eslint-disable functional/no-conditional-statement, functional/no-let, functional/no-expression-statement, no-underscore-dangle, functional/no-try-statement, @typescript-eslint/no-magic-numbers */

/**
 * Note, most of this method is translated and boiled-down from the wasm-pack
 * workflow. Significant changes to wasm-bindgen or wasm-pack build will likely
 * require modifications to this method.
 */
const instantiateRustWasm = async (webassemblyBytes, expectedImportModuleName, hashExportName, initExportName, updateExportName, finalExportName) => {
  const wasm = (await WebAssembly.instantiate(webassemblyBytes, {
    [expectedImportModuleName]: {
      /**
       * This would only be called in cases where a `__wbindgen_malloc` failed.
       * Since `__wbindgen_malloc` isn't exposed to consumers, this error
       * can only be encountered if the code below is broken.
       */
      // eslint-disable-next-line camelcase
      __wbindgen_throw:
      /* istanbul ignore next */
      (ptr, len) => {
        // eslint-disable-next-line functional/no-throw-statement
        throw new Error( // eslint-disable-next-line @typescript-eslint/no-use-before-define
        Array.from(getUint8Memory().subarray(ptr, ptr + len)).map(num => String.fromCharCode(num)).join(''));
      }
    }
  })).instance.exports; // eslint-disable-line @typescript-eslint/no-explicit-any

  let cachedUint8Memory; // eslint-disable-line init-declarations

  let cachedUint32Memory; // eslint-disable-line init-declarations

  let cachedGlobalArgumentPtr; // eslint-disable-line init-declarations

  const globalArgumentPtr = () => {
    if (cachedGlobalArgumentPtr === undefined) {
      cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();
    }

    return cachedGlobalArgumentPtr;
  };
  /**
   * Must be hoisted for `__wbindgen_throw`.
   */
  // eslint-disable-next-line func-style


  function getUint8Memory() {
    if (cachedUint8Memory === undefined || cachedUint8Memory.buffer !== wasm.memory.buffer) {
      cachedUint8Memory = new Uint8Array(wasm.memory.buffer);
    }

    return cachedUint8Memory;
  }

  const getUint32Memory = () => {
    if (cachedUint32Memory === undefined || cachedUint32Memory.buffer !== wasm.memory.buffer) {
      cachedUint32Memory = new Uint32Array(wasm.memory.buffer);
    }

    return cachedUint32Memory;
  };

  const passArray8ToWasm = array => {
    const ptr = wasm.__wbindgen_malloc(array.length);

    getUint8Memory().set(array, ptr);
    return [ptr, array.length];
  };

  const getArrayU8FromWasm = (ptr, len) => getUint8Memory().subarray(ptr, ptr + len);

  const hash = input => {
    const [ptr0, len0] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();

    try {
      wasm[hashExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();

      wasm.__wbindgen_free(ptr, len);

      return realRet;
    } finally {
      wasm.__wbindgen_free(ptr0, len0);
    }
  };

  const init = () => {
    const retPtr = globalArgumentPtr();
    wasm[initExportName](retPtr);
    const mem = getUint32Memory();
    const ptr = mem[retPtr / 4];
    const len = mem[retPtr / 4 + 1];
    const realRet = getArrayU8FromWasm(ptr, len).slice();

    wasm.__wbindgen_free(ptr, len);

    return realRet;
  };

  const update = (rawState, input) => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const [ptr1, len1] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();

    try {
      wasm[updateExportName](retPtr, ptr0, len0, ptr1, len1);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();

      wasm.__wbindgen_free(ptr, len);

      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));

      wasm.__wbindgen_free(ptr0, len0);

      wasm.__wbindgen_free(ptr1, len1);
    }
  };

  const final = rawState => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const retPtr = globalArgumentPtr();

    try {
      wasm[finalExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();

      wasm.__wbindgen_free(ptr, len);

      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));

      wasm.__wbindgen_free(ptr0, len0);
    }
  };

  return {
    final,
    hash,
    init,
    update
  };
};
/* eslint-enable functional/no-conditional-statement, functional/no-let, functional/no-expression-statement, no-underscore-dangle, functional/no-try-statement, @typescript-eslint/no-magic-numbers */
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/ripemd160/ripemd160.base64.js
/**
 * @hidden
 */
// prettier-ignore
const ripemd160Base64Bytes = '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AgQMBQsgAEH8EigCACACaiICQQFyNgIEQYQTIAA2AgBB/BIgAjYCACAAIAJqIAI2AgAMBAsgAxAgDAELQewPQewPKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RB9A9qIQJB7A8oAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAhDAILQewPIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBgBMgACACayIBNgIAQYgTQYgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEGMFBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUH0DDYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJQALuAEBAX8jAEHgAWsiAyQAIANBOGpBzAgoAgA2AgAgA0EwakHECCkCADcDACADQgA3AyAgA0G8CCkCADcDKCADQTxqQQBBxAAQKhogA0EgaiABIAIQCSADQYABaiADQSBqQeAAECgaIANBCGogA0GAAWoQCiADQSBqIANBCGpBFBADIANBiAFqIANBKGooAgA2AgAgAyADKQMgNwOAASADIANBgAFqEAsgACADKQMANwIAIANB4AFqJAALlwMBBH8jAEFAaiIDJAAgACAAKQMAIAKtfDcDACADIABBCGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAhwiBQRAQcAAIAVrIgQgAk0NASADQRhqIAUgBSACaiIEIABBIGoQFiADKAIcIAJHDQUgAygCGCABIAIQKBoMAwsgAiEEDAELIANBMGogASACIAQQFyADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQSBqIgYgACgCHBAYIAIgAygCJEcNBCADKAIgIAUgAhAoGiAAQRxqQQA2AgAgA0EsaiAGEBkLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAXIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAaIANBLGogAygCCBAZDAALAAsgA0EQaiAAQSBqIAQQGyADKAIUIARHDQEgAygCECABIAQQKBoLIABBHGogBDYCACADQUBrJAAPC0H0ExAHAAtB9BMQBwALQfQTEAcAC+MCAgR/AX4jAEFAaiICJAAgAiABQQhqIgU2AiQgASkDACEGIAEoAhwhAyACIAJBJGo2AigCQCADQT9NBEAgAUEgaiIEIANqQYABOgAAIAEgASgCHEEBaiIDNgIcIAJBGGogBCADEBggAigCGEEAIAIoAhwQKhpBwAAgASgCHGtBB00EQCACQShqIAQQGSACQRBqIAQgAUEcaigCABAbIAIoAhBBACACKAIUECoaCyACQQhqIARBOBAYIAIoAgxBCEcNASACKAIIIAZCA4Y3AAAgAkEoaiAEEBkgAUEcakEANgIAIAJBADYCKEEEIQECQANAIAFBGEYNASACQShqIAFqQQA6AAAgAiACKAIoQQFqNgIoIAFBAWohAQwACwALIAAgBSkAADcAACAAQRBqIAVBEGooAAA2AAAgAEEIaiAFQQhqKQAANwAAIAJBQGskAA8LQcwTIANBwAAQHQALQdwTEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0G0ExAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAqGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YB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';
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/hex.js
/**
 * Returns an array of incrementing values starting at `begin` and incrementing by one for `length`.
 *
 * E.g.: `range(3)` => `[0, 1, 2]` and `range(3, 1)` => `[1, 2, 3]`
 *
 * @param length the number of elements in the array
 * @param begin the index at which the range starts (default: `0`)
 */
const hex_range = (length, begin = 0) => Array.from({
  length
}, (_, index) => begin + index);
/**
 * Split a string into an array of `chunkLength` strings. The final string may have a length between 1 and `chunkLength`.
 *
 * E.g.: `splitEvery('abcde', 2)` => `['ab', 'cd', 'e']`
 */

const splitEvery = (input, chunkLength) => hex_range(Math.ceil(input.length / chunkLength)).map(index => index * chunkLength).map(begin => input.slice(begin, begin + chunkLength));
const hexByteWidth = 2;
const hexadecimal = 16;
/**
 * Decode a hexadecimal-encoded string into a Uint8Array.
 *
 * E.g.: `hexToBin('2a64ff')` => `new Uint8Array([42, 100, 255])`
 *
 * Note, this method always completes. If `validHex` is not divisible by 2,
 * the final byte will be parsed as if it were prepended with a `0` (e.g. `aaa`
 * is interpreted as `aa0a`). If `validHex` is potentially malformed, check
 * it with `isHex` before calling this method.
 *
 * @param validHex a string of valid, hexadecimal-encoded data
 */

const hexToBin = validHex => Uint8Array.from(splitEvery(validHex, hexByteWidth).map(byte => parseInt(byte, hexadecimal)));
const hexByteLength = 2;
/**
 * For use before `hexToBin`. Returns true if the provided string is valid
 * hexadecimal (length is divisible by 2, only uses hexadecimal characters).
 * @param maybeHex a string to test
 */

const isHex = maybeHex => maybeHex.length % hexByteLength === 0 && !/[^a-fA-F0-9]/u.test(maybeHex);
/**
 * Encode a Uint8Array into a hexadecimal-encoded string.
 *
 * E.g.: `binToHex(new Uint8Array([42, 100, 255]))` => `'2a64ff'`
 *
 * @param bytes a Uint8Array to encode
 */

const binToHex = bytes => bytes.reduce((str, byte) => str + byte.toString(hexadecimal).padStart(hexByteWidth, '0'), '');
/**
 * Decode a hexadecimal-encoded string into bytes, reverse it, then re-encode.
 *
 * @param validHex a string of valid, hexadecimal-encoded data. See
 * `hexToBin` for more information.
 */

const swapEndianness = validHex => binToHex(hexToBin(validHex).reverse());
/**
 * Reduce an array of `Uint8Array`s into a single `Uint8Array`.
 * @param array the array of `Uint8Array`s to flatten
 */

const flattenBinArray = array => {
  const totalLength = array.reduce((total, bin) => total + bin.length, 0);
  const flattened = new Uint8Array(totalLength); // eslint-disable-next-line functional/no-expression-statement

  array.reduce((index, bin) => {
    // eslint-disable-next-line functional/no-expression-statement
    flattened.set(bin, index);
    return index + bin.length;
  }, 0);
  return flattened;
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/base64.js
// base64 encode/decode derived from: https://github.com/niklasvh/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const base64GroupLength = 4;
const nonBase64Chars = new RegExp(`[^${chars}=]`, 'u');
/**
 * For use before `base64ToBin`. Returns true if the provided string is valid
 * base64 (length is divisible by 4, only uses base64 characters).
 * @param maybeHex a string to test
 */

const isBase64 = maybeBase64 => maybeBase64.length % base64GroupLength === 0 && !nonBase64Chars.test(maybeBase64);
/* eslint-disable functional/no-expression-statement, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus */

/**
 * Convert a base64-encoded string to a Uint8Array.
 *
 * Note, this method always completes. If `validBase64` is not valid base64, an
 * incorrect result will be returned. If `validBase64` is potentially malformed,
 * check it with `isBase64` before calling this method.
 *
 * @param validBase64 a valid base64-encoded string to decode
 */

const base64ToBin = validBase64 => {
  const lookup = new Uint8Array(123); // eslint-disable-next-line functional/no-let, functional/no-loop-statement

  for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  const bufferLengthEstimate = validBase64.length * 0.75;
  const stringLength = validBase64.length;
  const bufferLength = validBase64[validBase64.length - 1] === '=' // eslint-disable-line @typescript-eslint/prefer-string-starts-ends-with
  ? validBase64[validBase64.length - 2] === '=' ? bufferLengthEstimate - 2 : bufferLengthEstimate - 1 : bufferLengthEstimate;
  const buffer = new ArrayBuffer(bufferLength);
  const bytes = new Uint8Array(buffer); // eslint-disable-next-line functional/no-let

  let p = 0; // eslint-disable-next-line functional/no-let, functional/no-loop-statement

  for (let i = 0; i < stringLength; i += 4) {
    const encoded1 = lookup[validBase64.charCodeAt(i)];
    const encoded2 = lookup[validBase64.charCodeAt(i + 1)];
    const encoded3 = lookup[validBase64.charCodeAt(i + 2)];
    const encoded4 = lookup[validBase64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }

  return bytes;
};
/**
 * Convert a Uint8Array to a base64-encoded string.
 * @param bytes the Uint8Array to base64 encode
 */

const binToBase64 = bytes => {
  // eslint-disable-next-line functional/no-let
  let result = ''; // eslint-disable-next-line functional/no-let, functional/no-loop-statement

  for (let i = 0; i < bytes.length; i += 3) {
    result += chars[bytes[i] >> 2];
    result += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    result += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    result += chars[bytes[i + 2] & 63];
  }

  const padded = bytes.length % 3 === 2 ? `${result.substring(0, result.length - 1)}=` : bytes.length % 3 === 1 ? `${result.substring(0, result.length - 2)}==` : result;
  return padded;
};
/* eslint-enable functional/no-expression-statement, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus */
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/numbers.js
/**
 * Encode a number as a little-endian Uint8Array.
 *
 * Note: For valid results, value must be within the range representable by the
 * specified number of bytes. For values exceeding Number.MAX_SAFE_INTEGER, use
 * `bigIntToBinUintLE`.
 *
 * @param value the number to convert into a Uint32LE Uint8Array
 * @param bytes the number of bytes to read
 */
const numberToBinUintLE = (value, bytes) => {
  const bin = new Uint8Array(bytes); // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let offset = 0; offset < bytes; offset++) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    bin[offset] = value; // eslint-disable-next-line functional/no-expression-statement, no-bitwise, no-param-reassign

    value >>>= 8
    /* bitsInAByte */
    ;
  }

  return bin;
};
/**
 * Encode a number as a 2-byte Uint16LE Uint8Array.
 *
 * Note: For valid results, value must be between 0 and 0xffff.
 *
 * @param value the number to convert into a Uint16LE Uint8Array
 */

const numberToBinUint16LE = value => numberToBinUintLE(value, 2
/* uint16 */
);
/**
 * Encode a number as a 4-byte Uint32LE Uint8Array.
 *
 * Note: For valid results, value must be between 0 and 0xffffffff.
 *
 * @param value the number to convert into a Uint32LE Uint8Array
 */

const numberToBinUint32LE = value => numberToBinUintLE(value, 4
/* uint32 */
);
/**
 * Decode a little-endian Uint8Array into a number.
 *
 * @param bin the Uint8Array to decode
 * @param bytes the number of bytes to read
 */

const binToNumberUintLE = (bin, bytes) => {
  // eslint-disable-next-line functional/no-let
  let value = 0; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let offset = 0; offset < bytes; offset++) {
    // eslint-disable-next-line functional/no-expression-statement
    value += bin[offset] * 2
    /* base */
    ** (8
    /* bitsInAByte */
    * offset);
  }

  return value;
};
/**
 * Decode a 2-byte Uint16LE Uint8Array into a number.
 *
 * @param bin the Uint8Array to decode
 */

const binToNumberUint16LE = bin => binToNumberUintLE(bin, 2
/* uint16 */
);
/**
 * Decode a 4-byte Uint32LE Uint8Array into a number.
 *
 * @param bin the Uint8Array to decode
 */

const binToNumberUint32LE = bin => binToNumberUintLE(bin, 4
/* uint32 */
);
/**
 * Return a BigInt as little-endian Uint8Array.
 *
 * Note: For valid results, value must be between 0 and 0xffff ffff ffff ffff.
 * @param value the number to convert into a little-endian Uint8Array
 * @param bytes the byte length of the Uint8Array to return
 */

const bigIntToBinUintLE = (value, bytes) => {
  const bin = new Uint8Array(bytes); // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let offset = 0; offset < bytes; offset++) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    bin[offset] = Number(value); // eslint-disable-next-line functional/no-expression-statement, no-bitwise, no-param-reassign

    value >>= BigInt(8
    /* bitsInAByte */
    );
  }

  return bin;
};
/**
 * Return a BigInt as Uint64LE Uint8Array.
 *
 * Note: For valid results, value must be within the range representable by the
 * specified number of bytes.
 *
 * @param value the number to convert into a little-endian Uint8Array
 */

const bigIntToBinUint64LE = value => bigIntToBinUintLE(value, 8
/* uint64 */
);
/**
 * Decode a little-endian Uint8Array into a BigInt.
 *
 * @param bin the Uint8Array to decode
 */

const binToBigIntUintLE = (bin, bytes) => {
  const base = 2;
  const bitsInAByte = 8; // eslint-disable-next-line functional/no-let

  let value = BigInt(0); // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let offset = 0; offset < bytes; offset++) {
    // eslint-disable-next-line functional/no-expression-statement
    value += BigInt(bin[offset] * base ** (bitsInAByte * offset));
  }

  return value;
};
/**
 * Decode an 8-byte Uint64LE Uint8Array into a BigInt.
 *
 * @param bin the Uint8Array to decode
 */

const binToBigIntUint64LE = bin => binToBigIntUintLE(bin, 8
/* uint64 */
);

const varIntPrefixToSize = firstByte => {
  switch (firstByte) {
    default:
      return 1
      /* uint8 */
      ;

    case 253
    /* Uint16Prefix */
    :
      return 2
      /* uint16 */
      ;

    case 254
    /* Uint32Prefix */
    :
      return 4
      /* uint32 */
      ;

    case 255
    /* Uint64Prefix */
    :
      return 8
      /* uint64 */
      ;
  }
};
/**
 * Read a Bitcoin VarInt (Variable-length integer) from a Uint8Array, returning
 * the `nextOffset` after the VarInt and the value as a BigInt.
 *
 * @param bin the Uint8Array from which to read the VarInt
 * @param offset the offset at which the input begins
 */


const readBitcoinVarInt = (bin, offset) => {
  const bytes = varIntPrefixToSize(bin[offset]);
  return {
    nextOffset: offset + bytes,
    value: binToBigIntUintLE(bin.subarray(offset, offset + bytes), bytes)
  };
};
/**
 * Encode a BigInt as a Bitcoin VarInt (Variable-length integer).
 *
 * Note: the maximum value of a Bitcoin VarInt is 0xffff ffff ffff ffff. This
 * method will produce invalid results for larger values.
 *
 * @param value the BigInt to encode (no larger than 0xffff ffff ffff ffff)
 */

const bigIntToBitcoinVarInt = value => value <= BigInt(252
/* Uint8MaxValue */
) ? bigIntToBinUintLE(value, 1
/* uint8 */
) : value <= BigInt(65535
/* Uint16MaxValue */
) ? Uint8Array.from([253
/* Uint16Prefix */
, ...bigIntToBinUintLE(value, 2
/* uint16 */
)]) : value <= BigInt(4294967295
/* Uint32MaxValue */
) ? Uint8Array.from([254
/* Uint32Prefix */
, ...bigIntToBinUintLE(value, 4
/* uint32 */
)]) : Uint8Array.from([255
/* Uint64Prefix */
, ...bigIntToBinUintLE(value, 8
/* uint64 */
)]);
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/log.js

const defaultStringifySpacing = 2;
/**
 * A safe method to `JSON.stringify` a value, useful for debugging and logging
 * purposes.
 *
 * @remarks
 * Without modifications, `JSON.stringify` has several shortcomings in
 * debugging and logging usage:
 * - throws when serializing anything containing a `bigint`
 * - `Uint8Array`s are often serialized in base 10 with newlines between each
 *   index item
 * - `functions` and `symbols` are not clearly marked
 *
 * This method is more helpful in these cases:
 * - `bigint`: `0n` => `<bigint: 0n>`
 * - `Uint8Array`: `Uint8Array.of(0,0)` => `<Uint8Array: 0x0000>`
 * - `function`: `(x) => x * 2` => `<function: (x) => x * 2>`
 * - `symbol`: `Symbol(A)` => `<symbol: Symbol(A)>`
 *
 * @param value the data to serialize
 * @param spacing the number of spaces to use in
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

const stringify = (value, spacing = defaultStringifySpacing) => JSON.stringify(value, // eslint-disable-next-line complexity
(_, item) => {
  var _item$constructor;

  const type = typeof item;
  const name = type === 'object' ? (_item$constructor = item.constructor) === null || _item$constructor === void 0 ? void 0 : _item$constructor.name : type;

  switch (name) {
    case 'Uint8Array':
      return `<Uint8Array: 0x${binToHex(item)}>`;

    case 'bigint':
      return `<bigint: ${item.toString()}n>`;

    case 'function':
    case 'symbol':
      return `<${name}: ${item.toString()}>`;

    default:
      return item;
  }
}, spacing);
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/types.js
var ScriptNumberError;

(function (ScriptNumberError) {
  ScriptNumberError["outOfRange"] = "Failed to parse Script Number: overflows Script Number range.";
  ScriptNumberError["requiresMinimal"] = "Failed to parse Script Number: the number is not minimally-encoded.";
})(ScriptNumberError || (ScriptNumberError = {}));

const isScriptNumberError = value => value === ScriptNumberError.outOfRange || value === ScriptNumberError.requiresMinimal;
const normalMaximumScriptNumberByteLength = 4;
/**
 * This method attempts to parse a "Script Number", a format with which numeric
 * values are represented on the stack. (The Satoshi implementation calls this
 * `CScriptNum`.)
 *
 * If `bytes` is a valid Script Number, this method returns the represented
 * number in BigInt format. If `bytes` is not valid, a `ScriptNumberError` is
 * returned.
 *
 * All common operations accepting numeric parameters or pushing numeric values
 * to the stack currently use the Script Number format. The binary format of
 * numbers wouldn't be important if they could only be operated on by arithmetic
 * operators, but since the results of these operations may become input to
 * other operations (e.g. hashing), the specific representation is consensus-
 * critical.
 *
 * Parsing of Script Numbers is limited to 4 bytes (with the exception of
 * OP_CHECKLOCKTIMEVERIFY and OP_CHECKSEQUENCEVERIFY, which read up to 5-bytes).
 * The bytes are read as a signed integer (for 32-bits: inclusive range from
 * -2^31 + 1 to 2^31 - 1) in little-endian byte order. Script Numbers must
 * further be encoded as minimally as possible (no zero-padding). See code/tests
 * for details.
 *
 * ### Notes
 *
 * Operators may push numeric results to the stack which exceed the current
 * 4-byte length limit of Script Numbers. While these stack elements would
 * otherwise be valid Script Numbers, because of the 4-byte length limit, they
 * can only be used as non-numeric values in later operations.
 *
 * Most other implementations currently parse Script Numbers into 64-bit
 * integers to operate on them (rather than integers of arbitrary size like
 * BigInt). Currently, no operators are at risk of overflowing 64-bit integers
 * given 32-bit integer inputs, but future operators may require additional
 * refactoring in those implementations.
 *
 * @param bytes a Uint8Array from the stack
 * @param requireMinimalEncoding if true, this method returns an error when
 * parsing non-minimally encoded Script Numbers
 * @param maximumScriptNumberByteLength the maximum valid number of bytes
 */
// eslint-disable-next-line complexity

const parseBytesAsScriptNumber = (bytes, requireMinimalEncoding = true, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength) => {
  if (bytes.length === 0) {
    return BigInt(0);
  }

  if (bytes.length > maximumScriptNumberByteLength) {
    return ScriptNumberError.outOfRange;
  }

  const mostSignificantByte = bytes[bytes.length - 1];
  const secondMostSignificantByte = bytes[bytes.length - 1 - 1];
  const allButTheSignBit = 127;
  const justTheSignBit = 128;

  if (requireMinimalEncoding && // eslint-disable-next-line no-bitwise
  (mostSignificantByte & allButTheSignBit) === 0 && ( // eslint-disable-next-line no-bitwise
  bytes.length <= 1 || (secondMostSignificantByte & justTheSignBit) === 0)) {
    return ScriptNumberError.requiresMinimal;
  }

  const bitsPerByte = 8;
  const signFlippingByte = 0x80; // eslint-disable-next-line functional/no-let

  let result = BigInt(0); // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let byte = 0; byte < bytes.length; byte++) {
    // eslint-disable-next-line functional/no-expression-statement,  no-bitwise
    result |= BigInt(bytes[byte]) << BigInt(byte * bitsPerByte);
  }
  /* eslint-disable no-bitwise */


  const isNegative = (bytes[bytes.length - 1] & signFlippingByte) !== 0;
  return isNegative ? -(result & ~(BigInt(signFlippingByte) << BigInt(bitsPerByte * (bytes.length - 1)))) : result;
  /* eslint-enable no-bitwise */
};
/**
 * Convert a BigInt into the "Script Number" format. See
 * `parseBytesAsScriptNumber` for more information.
 *
 * @param integer the BigInt to encode as a Script Number
 */
// eslint-disable-next-line complexity

const bigIntToScriptNumber = integer => {
  if (integer === BigInt(0)) {
    return new Uint8Array();
  }

  const bytes = [];
  const isNegative = integer < 0;
  const byteStates = 0xff;
  const bitsPerByte = 8; // eslint-disable-next-line functional/no-let

  let remaining = isNegative ? -integer : integer; // eslint-disable-next-line functional/no-loop-statement

  while (remaining > 0) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
    bytes.push(Number(remaining & BigInt(byteStates))); // eslint-disable-next-line functional/no-expression-statement, no-bitwise

    remaining >>= BigInt(bitsPerByte);
  }

  const signFlippingByte = 0x80; // eslint-disable-next-line no-bitwise, functional/no-conditional-statement

  if ((bytes[bytes.length - 1] & signFlippingByte) > 0) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    bytes.push(isNegative ? signFlippingByte : 0x00); // eslint-disable-next-line functional/no-conditional-statement
  } else if (isNegative) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
    bytes[bytes.length - 1] |= signFlippingByte;
  }

  return new Uint8Array(bytes);
};
/**
 * Returns true if the provided stack item is "truthy" in the sense required
 * by several operations (anything but zero and "negative zero").
 *
 * The Satoshi implementation calls this method `CastToBool`.
 *
 * @param item the stack item to check for truthiness
 */

const stackItemIsTruthy = item => {
  const signFlippingByte = 0x80; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < item.length; i++) {
    if (item[i] !== 0) {
      if (i === item.length - 1 && item[i] === signFlippingByte) {
        return false;
      }

      return true;
    }
  }

  return false;
};
/**
 * Convert a boolean into Script Number format (the type used to express
 * boolean values emitted by several operations).
 *
 * @param value the boolean value to convert
 */

const booleanToScriptNumber = value => value ? bigIntToScriptNumber(BigInt(1)) : bigIntToScriptNumber(BigInt(0));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/time.js

var Constants;

(function (Constants) {
  Constants[Constants["msPerLocktimeSecond"] = 1000] = "msPerLocktimeSecond";
  Constants[Constants["minimumTimestamp"] = 500000000] = "minimumTimestamp";
})(Constants || (Constants = {}));
/**
 * Convert a Javascript `Date` object to its equivalent LockTime
 * representation in an `AuthenticationVirtualMachine`.
 *
 * TODO: this method should error past the overflow Date and for dates which
 * would become BlockHeights when encoded.
 *
 * @param date the Date to convert to a BlockTime Uint8Array
 */


const dateToLockTime = date => bigIntToScriptNumber(BigInt(Math.round(date.getTime() / Constants.msPerLocktimeSecond)));
/**
 * Parse a locktime, returning a `number` for block heights, a `Date` for block
 * times, and a string for parsing errors.
 *
 * Note: this method does not check the length of locktime
 *
 * @param bin the 4-byte Uint8Array locktime to parse
 */

const parseLockTime = bin => {
  const parsed = parseBytesAsScriptNumber(bin);
  return typeof parsed === 'string' ? parsed : parsed >= BigInt(Constants.minimumTimestamp) ? new Date(Number(parsed) * Constants.msPerLocktimeSecond) : Number(parsed);
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/utf8.js
/**
 * This implementations is derived from:
 * https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js
 *
 * Copyright 2008 The Closure Library Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable complexity, functional/no-let, functional/immutable-data, no-bitwise, @typescript-eslint/no-magic-numbers, functional/no-expression-statement, functional/no-conditional-statement, functional/no-loop-statement, no-plusplus */

/**
 * Interpret a string as UTF-8 and encode it as a Uint8Array.
 * @param utf8 the string to encode
 */
const utf8ToBin = utf8 => {
  const out = [];
  let p = 0;

  for (let i = 0; i < utf8.length; i++) {
    let c = utf8.charCodeAt(i);

    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 0xfc00) === 0xd800 && i + 1 < utf8.length && (utf8.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
      c = ((c & 0x03ff) << 10) + 0x10000 + (utf8.charCodeAt(i += 1) & 0x03ff);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }

  return new Uint8Array(out);
};
/**
 * Decode a Uint8Array as a UTF-8 string.
 * @param bytes the Uint8Array to decode
 */

const binToUtf8 = bytes => {
  const out = [];
  let pos = 0;
  let c = 0;

  while (pos < bytes.length) {
    const c1 = bytes[pos++];

    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
      out[c++] = String.fromCharCode((u >> 10) + 0xd800);
      out[c++] = String.fromCharCode((u & 1023) + 0xdc00);
    } else {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }

  return out.join('');
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/utils/utils.js






// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/secp256k1/secp256k1-wasm-types.js
// cSpell:ignore noncefp, ndata, outputlen

/**
 * bitflags used in secp256k1's public API (translated from secp256k1.h)
 */

/* eslint-disable no-bitwise, @typescript-eslint/no-magic-numbers */

/** All flags' lower 8 bits indicate what they're for. Do not use directly. */
// const SECP256K1_FLAGS_TYPE_MASK = (1 << 8) - 1;
const SECP256K1_FLAGS_TYPE_CONTEXT = 1 << 0;
const SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
/** The higher bits contain the actual data. Do not use directly. */

const SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
const SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
const SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;
/** Flags to pass to secp256k1_context_create. */

const SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
const SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
const SECP256K1_CONTEXT_NONE = SECP256K1_FLAGS_TYPE_CONTEXT;
/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */

const SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;
const SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
/**
 * Flag to pass to a Secp256k1.contextCreate method.
 *
 * The purpose of context structures is to cache large precomputed data tables
 * that are expensive to construct, and also to maintain the randomization data
 * for blinding.
 *
 * You can create a context with only VERIFY or only SIGN capabilities, or you
 * can use BOTH. (NONE can be used for conversion/serialization.)
 */

var ContextFlag;

(function (ContextFlag) {
  ContextFlag[ContextFlag["NONE"] = SECP256K1_CONTEXT_NONE] = "NONE";
  ContextFlag[ContextFlag["VERIFY"] = SECP256K1_CONTEXT_VERIFY] = "VERIFY";
  ContextFlag[ContextFlag["SIGN"] = SECP256K1_CONTEXT_SIGN] = "SIGN";
  ContextFlag[ContextFlag["BOTH"] = SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY] = "BOTH";
})(ContextFlag || (ContextFlag = {}));
/**
 * Flag to pass a Secp256k1 public key serialization method.
 *
 * You can indicate COMPRESSED (33 bytes, header byte 0x02 or 0x03) or
 * UNCOMPRESSED (65 bytes, header byte 0x04) format.
 */


var CompressionFlag;

(function (CompressionFlag) {
  CompressionFlag[CompressionFlag["COMPRESSED"] = SECP256K1_EC_COMPRESSED] = "COMPRESSED";
  CompressionFlag[CompressionFlag["UNCOMPRESSED"] = SECP256K1_EC_UNCOMPRESSED] = "UNCOMPRESSED";
})(CompressionFlag || (CompressionFlag = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/secp256k1/secp256k1.base64.js
/**
 * @hidden
 */
// prettier-ignore
const secp256k1Base64Bytes = 'AGFzbQEAAAABXg5gAn9/AGAGf39/f39/AX9gAX8AYAABf2AAAGADf39/AX9gAX8Bf2ACf38Bf2AEf39/fwF/YAV/f39/fwF/YAN/f38AYAd/f39/f39/AX9gBH9/f38AYAV/f39/fwAC5wEMA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABBgYDZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudgVhYm9ydAACA2Vudg1lbmxhcmdlTWVtb3J5AAMDZW52DmdldFRvdGFsTWVtb3J5AAMDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAMDZW52C19fX3NldEVyck5vAAIDZW52Bl9hYm9ydAAEA2VudhZfZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAUDSUgAAAYKBQAKCgIMAAYABwACBgUNCgAKAAoAAAcHAAAAAgYMCgoFAAUFAAULAQYFAwcBCAgBCAgKBwUFBQUHAQEIBQUFCAUICQgGCwJ/ASMBC38BIwILB/QGGxFfX19lcnJub19sb2NhdGlvbgA1BV9mcmVlACYHX21hbGxvYwAnGV9zZWNwMjU2azFfY29udGV4dF9jcmVhdGUAMxxfc2VjcDI1NmsxX2NvbnRleHRfcmFuZG9taXplAD4fX3NlY3AyNTZrMV9lY19wcml2a2V5X3R3ZWFrX2FkZABCH19zZWNwMjU2azFfZWNfcHJpdmtleV90d2Vha19tdWwAQBtfc2VjcDI1NmsxX2VjX3B1YmtleV9jcmVhdGUAMBpfc2VjcDI1NmsxX2VjX3B1YmtleV9wYXJzZQBOHl9zZWNwMjU2azFfZWNfcHVia2V5X3NlcmlhbGl6ZQBNHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX2FkZABBHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX211bAA/G19zZWNwMjU2azFfZWNfc2Vja2V5X3ZlcmlmeQBDGF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcgA5NF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcmFibGVfc2lnbmF0dXJlX3BhcnNlX2NvbXBhY3QAPDhfc2VjcDI1NmsxX2VjZHNhX3JlY292ZXJhYmxlX3NpZ25h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iCEuIAogLadJIAkgLKdJaiALICinSWogISAbRXFqIBkgE0VxaiAaIBRFcWogDiAbSWogByATSWogBSAUSWogECAISWogESAGSSAqQgGGpyIJciAiaiITaiIOIBIgBEkgK0IBhqciCnIgF2oiFGoiByAMIANJICVCAYanIgtyIBVqIhBqIgUgDSACSSAkQgGGpyIIciAWaiIRaiIGICOnIgRBAXQiEmoiASASSSEZIB8oAgCtICd+IiNCIIghLCABICOnIgNBAXQiDGoiASAMSSEaIBgoAgCtICZ+IiNCIIghKCABICOnIgJBAXQiDWoiASANSSEbIAogK6dJIAkgKqdJaiALICWnSWogCCAkp0lqICIgE0VxaiAOIBNJaiAXIBRFcWogByAUSWogFSAQRXFqIAUgEElqIBYgEUVxaiAGIBFJaiASIARJIC5CAYanIg5yIBlqIhVqIgogDCADSSAsQgGGpyIHciAaaiIWaiILIA0gAkkgKEIBhqciBXIgG2oiEGoiCCABIB4oAgCtIiQgJH4iI6ciAmoiASACSSAjQiCIp2oiBmohESAPIAE2AiAgICgCAK0iKSAcKAIArX4iI0IgiCEtIBEgI6ciBEEBdCIMaiIBIAxJIRMgHygCAK0iJyAdKAIArSImfiIjQiCIISogASAjpyIDQQF0Ig1qIgEgDUkhFCAYKAIArSIlICR+IiNCIIghJCABICOnIgJBAXQiCWoiASAJSSESIA8gATYCJCApICZ+IiNCIIghKyAHICynSSAOIC6nSWogBSAop0lqIBkgFUVxaiAaIBZFcWogGyAQRXFqIAogFUlqIAsgFklqIAggEElqIBEgBklqIAwgBEkgLUIBhqciB3IgE2oiDGoiCyANIANJICpCAYanIgVyIBRqIg1qIgggCSACSSAkQgGGpyIGciASaiIJaiIEICOnIgNBAXQiDmoiASAOSSEQICcgHigCAK0iJn4iI0IgiCEoIAEgI6ciAkEBdCIKaiIBIApJIREgBSAqp0kgByAtp0lqIAYgJKdJaiATIAxFcWogCyAMSWogFCANRXFqIAggDUlqIBIgCUVxaiAEIAlJaiAOIANJICtCAYanIgtyIBBqIhJqIgUgCiACSSAoQgGGpyIIciARaiIMaiIGIAEgJSAlfiIjpyICaiIBIAJJICNCIIinaiIEaiENIA8g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QUBrIAJB////H3EiAkHRB2pBGnZqQf///x9LIAYgAXEgB3EgCHEgBEH///8fcSIEcSAJcSALcUH///8fRiAFQf///wFGcXFyIgprQdEHcSACaiECIApBBnQgA2ogAkEadmoiA0EadiABQf///x9xaiIKQRp2IAZB////H3FqIgZBGnYgB0H///8fcWoiB0EadiAIQf///x9xaiIIQRp2IARqIgRBGnYgCUH///8fcWoiCUEadiALQf///x9xaiEBIAAgAkH///8fcTYCACANIANB////H3E2AgAgDiAKQf///x9xNgIAIA8gBkH///8fcTYCACAQIAdB////H3E2AgAgESAIQf///x9xNgIAIBIgBEH///8fcTYCACATIAlB////H3E2AgAgFCABQf///x9xNgIAIAwgAUEadiAFakH///8BcTYCAAuhFwEnfyMEIQQjBEHAA2okBCACKAJQIQYgASgCeARAIAAgBjYCeCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggACACKQIgNwIgIABBKGoiAyACQShqIgEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIABBATYCUCAAQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIAQkBA8LIAYEQCADBEAgA0EBNgIAIANBBGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCIAsgACABKQIANwIAIAAgASkCCDcCCCAAIAEpAhA3AhAgACABKQIYNwIYIAAgASkCIDcCICAAIAEpAig3AiggACABKQIwNwIwIAAgASkCODcCOCAAQUBrIAFBQGspAgA3AgAgACABKQJINwJIIAAgASkCUDcCUCAAIAEpAlg3AlggACABKQJgNwJgIAAgASkCaDcCaCAAIAEpAnA3AnAgACABKAJ4NgJ4IAQkBA8LIARB+ABqIQwgBEHQAGohJCAEQShqIQogAEH4AGoiKUEANgIAIARBkANqIiUgAUHQAGoiJhAHIARB6AJqIgggASkCADcCACAIIAEpAgg3AgggCCABKQIQNwIQIAggASkCGDcCGCAIIAEpAiA3AiAgCEEkaiIdKAIAIhNBFnYiBkHRB2wgCCgCAGohGyAGQQZ0IAhBBGoiFygCAGogG0EadmoiGEEadiAIQQhqIhkoAgBqIhpBGnYgCEEMaiIFKAIAaiIHQRp2IAhBEGoiDSgCAGoiFEEadiAIQRRqIhUoAgBqIg5BGnYgCEEYaiIPKAIAaiIQQRp2IAhBHGoiESgCAGoiEkEadiAIQSBqIgYoAgBqIRwgCCAbQf///x9xIio2AgAgFyAYQf///x9xIgs2AgAgGSAaQf///x9xIh42AgAgBSAHQf///x9xIh82AgAgDSAUQf///x9xIiA2AgAgFSAOQf///x9xIiE2AgAgDyAQQf///x9xIiI2AgAgESASQf///x9xIiM2AgAgBiAcQf///x9xIhs2AgAgHSAcQRp2IBNB////AXFqIhw2AgAgBEHAAmoiFiACICUQCiAEQZgCaiIJIAFBKGoiBikCADcCACAJIAYpAgg3AgggCSAGKQIQNwIQIAkgBikCGDcCGCAJIAYpAiA3AiAgCUEkaiInKAIAIh1BFnYiBkHRB2wgCSgCAGohDSAGQQZ0IAlBBGoiEygCAGogDUEadmoiFEEadiAJQQhqIhcoAgBqIhVBGnYgCUEMaiIYKAIAaiIOQRp2IAlBEGoiGSgCAGoiD0EadiAJQRRqIhooAgBqIhBBGnYgCUEYaiIFKAIAaiIRQRp2IAlBHGoiBygCAGoiEkEadiAJQSBqIgYoAgBqISggCSANQf///x9xIg02AgAgEyAUQf///x9xIhQ2AgAgFyAVQf///x9xIhU2AgAgGCAOQf///x9xIg42AgAgGSAPQf///x9xIg82AgAgGiAQQf///x9xIhA2AgAgBSARQf///x9xIhE2AgAgByASQf///x9xIhI2AgAgBiAoQf///x9xIgY2AgAgJyAoQRp2IB1B////AXFqNgIAIARB8AFqIgcgAkEoaiAlEAogByAHICYQCiAEQcgBaiIFQbzh//8AICprIBYoAgBqNgIAIAVB/P3//wAgC2sgFigCBGo2AgQgBUH8////ACAeayAWKAIIajYCCCAFQfz///8AIB9rIBYoAgxqNgIMIAVB/P///wAgIGsgFigCEGo2AhAgBUH8////ACAhayAWKAIUajYCFCAFQfz///8AICJrIBYoAhhqNgIYIAVB/P///wAgI2sgFigCHGo2AhwgBUH8////ACAbayAWKAIgajYCICAFQfz//wcgHGsgFigCJGo2AiRB/P//ByAnKAIAayECIARBoAFqIgtBvOH//wAgDWsgBygCAGo2AgAgC0H8/f//ACAUayAHKAIEajYCBCALQfz///8AIBVrIAcoAghqNgIIIAtB/P///wAgDmsgBygCDGo2AgwgC0H8////ACAPayAHKAIQajYCECALQfz///8AIBBrIAcoAhRqNgIUIAtB/P///wAgEWsgBygCGGo2AhggC0H8////ACASayAHKAIcajYCHCALQfz///8AIAZrIAcoAiBqNgIgIAsgAiAHKAIkajYCJCAFEBdFBEAgDCALEAcgJCAFEAcgCiAFICQQCiADBEAgAyAFKQIANwIAIAMgBSkCCDcCCCADIAUpAhA3AhAgAyAFKQIYNwIYIAMgBSkCIDcCIAsgAEHQAGogJiAFEAogBCAIICQQCiAAIAQpAgA3AgAgACAEKQIINwIIIAAgBCkCEDcCECAAIAQpAhg3AhggACAEKQIgNwIgQfj7//8BIABBBGoiEygCAEEBdCAKQQRqIh4oAgBqayEOQfj///8BIABBCGoiFygCAEEBdCAKQQhqIh8oAgBqayEPQfj///8BIABBDGoiGCgCAEEBdCAKQQxqIiAoAgBqayEQQfj///8BIABBEGoiGSgCAEEBdCAKQRBqIiEoAgBqayERQfj///8BIABBFGoiGigCAEEBdCAKQRRqIiIoAgBqayESQfj///8BIABBGGoiBSgCAEEBdCAKQRhqIiMoAgBqayEGQfj///8BIABBHGoiBygCAEEBdCAKQRxqIhsoAgBqayEDQfj///8BIABBIGoiDSgCAEEBdCAKQSBqIhwoAgBqayECQfj//w8gAEEkaiIUKAIAQQF0IApBJGoiHSgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAooAgBqayAMKAIAaiIVNgIAIBMgDiAMKAIEaiIONgIAIBcgDyAMKAIIaiIPNgIAIBggECAMKAIMaiIQNgIAIBkgESAMKAIQaiIRNgIAIBogEiAMKAIUaiISNgIAIAUgBiAMKAIYaiIGNgIAIAcgAyAMKAIcaiIDNgIAIA0gAiAMKAIgaiICNgIAIBQgASAMKAIkaiIBNgIAIABBKGoiE0G0pP//AiAVayAEKAIAajYCACAAQSxqIhdB9Pn//wIgDmsgBCgCBGo2AgAgAEEwaiIYQfT///8CIA9rIAQoAghqNgIAIABBNGoiGUH0////AiAQayAEKAIMajYCACAAQThqIhpB9P///wIgEWsgBCgCEGo2AgAgAEE8aiIFQfT///8CIBJrIAQoAhRqNgIAIABBQGsiB0H0////AiAGayAEKAIYajYCACAAQcQAaiINQfT///8CIANrIAQoAhxqNgIAIABByABqIhRB9P///wIgAmsgBCgCIGo2AgAgAEHMAGoiFUH0//8XIAFrIAQoAiRqNgIAIBMgEyALEAogCiAKIAkQCiAKQbzh//8AIAooAgBrIg42AgAgHkH8/f//ACAeKAIAayIPNgIAIB9B/P///wAgHygCAGsiEDYCACAgQfz///8AICAoAgBrIhE2AgAgIUH8////ACAhKAIAayISNgIAICJB/P///wAgIigCAGsiBjYCACAjQfz///8AICMoAgBrIgM2AgAgG0H8////ACAbKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACATIBMoAgAgDmo2AgAgFyAXKAIAIA9qNgIAIBggGCgCACAQajYCACAZIBkoAgAgEWo2AgAgGiAaKAIAIBJqNgIAIAUgBSgCACAGajYCACAHIAcoAgAgA2o2AgAgDSANKAIAIAJqNgIAIBQgFCgCACABajYCACAVIBUoAgAgAGo2AgAgBCQEDwsgCxAXBEAgACABIAMQGiAEJAQPCyADBEAgA0IANwIAIANCADcCCCADQgA3AhAgA0IANwIYIANCADcCIAsgKUEBNgIAIAQkBAuvAwEBfyAAIAFBHGoiAigCAEEYdjoAACAAIAIoAgBBEHY6AAEgACACKAIAQQh2OgACIAAgAigCADoAAyAAIAFBGGoiAigCAEEYdjoABCAAIAIoAgBBEHY6AAUgACACKAIAQQh2OgAGIAAgAigCADoAByAAIAFBFGoiAigCAEEYdjoACCAAIAIoAgBBEHY6AAkgACACKAIAQQh2OgAKIAAgAigCADoACyAAIAFBEGoiAigCAEEYdjoADCAAIAIoAgBBEHY6AA0gACACKAIAQQh2OgAOIAAgAigCADoADyAAIAFBDGoiAigCAEEYdjoAECAAIAIoAgBBEHY6ABEgACACKAIAQQh2OgASIAAgAigCADoAEyAAIAFBCGoiAigCAEEYdjoA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BxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgByAGEAogBEHIAWoiBSAHKQIANwIAIAUgBykCCDcCCCAFIAcpAhA3AhAgBSAHKQIYNwIYIAUgBykCIDcCICAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUgBxAKIARBoAFqIgIgBSkCADcCACACIAUpAgg3AgggAiAFKQIQNwIQIAIgBSkCGDcCGCACIAUpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACIAUQCiAEQfgAaiIJIAIpAgA3AgAgCSACKQIINwIIIAkgAikCEDcCECAJIAIpAhg3AhggCSACKQIgNwIgQQAhBgNAIAkgCRAHIAZBAWoiBkHYAEcNAAsgCSAJIAIQCiADIAkpAgA3AgAgAyAJKQIINwIIIAMgCSkCEDcCECADIAkpAhg3AhggAyAJKQIgNwIgIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAyAFEAogCCADKQIANwIAIAggAykCCDcCCCAIIAMpAhA3AhAgCCADKQIYNwIYIAggAykCIDcCICAIIAgQByAIIAgQByAIIAgQByAIIAggChAKIAQgCCkCADcCACAEIAgpAgg3AgggBCAIKQIQNwIQIAQgCCkCGDcCGCAEIAgpAiA3AiAgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAcQCiAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQgARAKIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCALEAogBCAEEAcgBCAEEAcgACABIAQQCiAEJAQL7gQBG38gAEEkaiILKAIAIgJBFnYiAUHRB2wgACgCAGohBCABQQZ0IABBBGoiDCgCAGogBEEadmoiBUEadiAAQQhqIg0oAgBqIgZB////H3EhByAGQRp2IABBDGoiDigCAGoiCEEadiAAQRBqIg8oAgBqIQEgCEH///8fcSEJIAFB////H3EhCiABQRp2IABBFGoiECgCAGoiEUEadiAAQRhqIhIoAgBqIRMgEUH///8fcSEUIBNBGnYgAEEcaiIVKAIAaiIWQRp2IABBIGoiFygCAGohAyAWQf///x9xIRggA0H///8fcSEZIANBGnYgAkH///8BcWoiAkEWdiAFQf///x9xIgVBQGsgBEH///8fcSIEQdEHaiIaQRp2IhtqQf///x9LIAggBnEgAXEgEXEgE0H///8fcSIBcSAWcSADcUH///8fRiACQf///wFGcXFyIgNFBEAgACAENgIAIAwgBTYCACANIAc2AgAgDiAJNgIAIA8gCjYCACAQIBQ2AgAgEiABNgIAIBUgGDYCACAXIBk2AgAgCyACNgIADwsgGyAFaiADQQZ0aiIDQRp2IAdqIgRBGnYgCWoiBkEadiAKaiIHQRp2IBRqIghBGnYgAWoiAUEadiAYaiIJQRp2IBlqIgpBGnYgAmpB////AXEhAiAAIBpB////H3E2AgAgDCADQf///x9xNgIAIA0gBEH///8fcTYCACAOIAZB////H3E2AgAgDyAHQf///x9xNgIAIBAgCEH///8fcTYCACASIAFB////H3E2AgAgFSAJQf///x9xNgIAIBcgCkH///8fcTYCACALIAI2AgALsAIBCn8gACgCJCIBQRZ2IgJB0QdsIAAoAgBqIgNB////H3EiBEHQB3MhBSAEQQBHIAVB////H0dxBEBBAA8LIANBGnYgAkEGdHIgACgCBGoiAkEadiAAKAIIaiIDQRp2IAAoAgxqIgZBGnYgACgCEGoiB0EadiAAKAIUaiIIQRp2IAAoAhhqIglBGnYgACgCHGoiCkEadiAAKAIgaiIAQRp2IAFB////AXFqIQEgAkHAAHMgBXEgA3EgBnEgB3EgCHEgCXEgCnEgAHEgAUGAgIAec3FB////H0YEf0EBBSACQf///x9xIARyIANB////H3FyIAZB////H3FyIAdB////H3FyIAhB////H3FyIAlB////H3FyIApB////H3FyIABB////H3FyIAFyRQtBAXELmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABIAFBCHRyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsLqy8BnwF/IwQhDSMEQbAmaiQEIA1BgCZqIQ4gDUHYJWohESANQdgkaiEGIA1BhCRqIRIgDUGwI2ohDCANQcgfaiEWIA1ByBdqIUkgDUHoD2ohBSANQagNaiEJIA1BiAhqIQsCfwJAIAMoAgQgAygCAHIgAygCCHIgAygCDHIgAygCEHIgAygCFHIgAygCGHIgAygCHHJFDQAgAigCeA0AIA1BhAhqIgpBADYCACANQYAIaiANIANBBRArIgM2AgAgBiACIAooAgAiD0H8AGxqIhBBABAaIAwgBikCADcCACAMIAYpAgg3AgggDCAGKQIQNwIQIAwgBikCGDcCGCAMIAYpAiA3AiAgDEEoaiIKIAZBKGoiCCkCADcCACAKIAgpAgg3AgggCiAIKQIQNwIQIAogCCkCGDcCGCAKIAgpAiA3AiAgDEEANgJQIA4gBkHQAGoiChAHIBEgDiAKEAogEiAQIA4QCiASQShqIgggAiAPQfwAbGpBKGogERAKIBIgAiAPQfwAbGooAng2AlAgBSASKQIANwIAIAUgEikCCDcCCCAFIBIpAhA3AhAgBSASKQIYNwIYIAUgEikCIDcCICAFQShqIhAgCCkCADcCACAQIAgpAgg3AgggECAIKQIQNwIQIBAgCCkCGDcCGCAQIAgpAiA3AiAgBUHQAGoiCCACIA9B/ABsakHQAGoiAikCADcCACAIIAIpAgg3AgggCCACKQIQNwIQIAggAikCGDcCGCAIIAIpAiA3AiAgBUH4AGoiE0EANgIAIAkgCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgBUH8AGoiAiAFIAwgCUEoaiIUEBAgBUH4AWoiCCACIAwgCUHQAGoiBxAQIAVB9AJqIgIgCCAMIAlB+ABqIh0QECAFQfADaiIIIAIgDCAJQaABaiIeEBAgBUHsBGoiAiAIIAwgCUHIAWoiHxAQIAVB6AVqIg8gAiAMIAlB8AFqIiEQECAFQeQGaiIIIA8gDCAJQZgCaiIPEBAgBUG0B2oiAiACIAoQCiALQcwEaiIJIAgpAgA3AgAgCSAIKQIINwIIIAkgCCkCEDcCECAJIAgpAhg3AhggCSAIKQIgNwIgIAtB9ARqIgkgBUGMB2oiCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgC0GYBWoiIigCACIjQRZ2IghB0QdsIAkoAgBqIQogCEEGdCALQfgEaiIkKAIAaiAKQRp2aiIlQRp2IAtB/ARqIiYoAgBqIidBGnYgC0GABWoiKCgCAGoiKUEadiALQYQFaiIqKAIAaiIrQRp2IAtBiAVqIiwoAgBqIi1BGnYgC0GMBWoiLigCAGoiL0EadiALQZAFaiIwKAIAaiIxQRp2IAtBlAVqIjIoAgBqIQggCSAKQf///x9xNgIAICQgJUH///8fcTYCACAmICdB////H3E2AgAgKCApQf///x9xNgIAICogK0H///8fcTYCACAsIC1B////H3E2AgAgLiAvQf///x9xNgIAIDAgMUH///8fcTYCACAyIAhB////H3E2AgAgIiAIQRp2ICNB////AXFqNgIAIBYgAikCADcCACAWIAIpAgg3AgggFiACKQIQNwIQIBYgAikCGDcCGCAWIAIpAiA3AiAgC0EANgKcBSAGIA8pAgA3AgAgBiAPKQIINwIIIAYgDykCEDcCECAGIA8pAhg3AhggBiAPKQIgNwIgIA4gBhAHIBEgDiAGEAogC0H4A2ogBUHoBWogDhAKIAtBoARqIAVBkAZqIBEQCiALIAUoAuAGNgLIBCAGIAYgIRAKIA4gBhAHIBEgDiAGEAogC0GkA2ogBUHsBGogDhAKIAtBzANqIAVBlAVqIBEQCiALIAUoAuQFNgL0AyAGIAYgHxAKIA4gBhAHIBEgDiAGEAogC0HQAmogBUHwA2ogDhAKIAtB+AJqIAVBmARqIBEQCiALIAUoAugENgKgAyAGIAYgHhAKIA4gBhAHIBEgDiAGEAogC0H8AWogBUH0AmogDhAKIAtBpAJqIAVBnANqIBEQCiALIAUoAuwDNgLMAiAGIAYgHRAKIA4gBhAHIBEgDiAGEAogC0GoAWogBUH4AWogDhAKIAtB0AFqIAVBoAJqIBEQCiALIAUoAvACNgL4ASAGIAYgBxAKIA4gBhAHIBEgDiAGEAogC0HUAGogBUH8AGogDhAKIAtB/ABqIAVBpAFqIBEQCiALIAUoAvQBNgKkASAGIAYgFBAKIA4gBhAHIBEgDiAGEAogCyAFIA4QCiALQShqIBAgERAKIAsgEygCADYCUEEBIUogA0EASgR/IAMFQQALDAELIBZBATYCACAWQQRqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiBBASFLQQALIQIgBARAIEkgBEEPECsiAyFMIAMgAkoEQCADIQILCyABQfgAaiIdQQE2AgAgAUIANwIAIAFCADcCCCABQgA3AhAgAUIANwIYIAFCADcCICABQgA3AiggAUIANwIwIAFCADcCOCABQUBrQgA3AgAgAUIANwJIIAFCADcCUCABQgA3AlggAUIANwJgIAFCADcCaCABQgA3AnAgAkEATARAIA0kBA8LIA1B6CFqISsgDUHwIGohLCANQcggaiFNIA1B8B9qIgVB0ABqIWogAUHQAGohHiAGQQRqIU4gBkEIaiFPIAZBDGohUCAGQRBqIVEgBkEUaiFSIAZBGGohUyAGQRxqIVQgBkEgaiFVIAZBJGohViABQShqIRMgDEEEaiFXIAxBCGohWCAMQQxqIVkgDEEQaiFaIAxBFGohWyAMQRhqIVwgDEEcaiFdIAxBIGohXiAMQSRqIV8gBUEoaiFgIA1B4CJqIghBBGohayAIQQhqIWwgCEEMaiFtIAhBEGohbiAIQRRqIW8gCEEYaiFwIAhBHGohcSAIQSBqIXIgCEEkaiFzIBJBBGohdCASQQhqIXUgEkEMaiF2IBJBEGohdyASQRRqIXggEkEYaiF5IBJBHGoheiASQSBqIXsgEkEkaiF8IA1BuCJqIhBBBGohfSAQQQhqIX4gEEEMaiF/IBBBEGohgAEgEEEUaiGBASAQQRhqIYIBIBBBHGohgwEgEEEgaiGEASAQQSRqIYUBIA1BiCNqIg9BBGohhgEgD0EIaiGHASAPQQxqIYgBIA9BEGohiQEgD0EUaiGKASAPQRhqIYsBIA9BHGohjAEgD0EgaiGNASAPQSRqIY4BIAFBBGohYSABQQhqIWIgAUEMaiFjIAFBEGohZCABQRRqIWUgAUEYaiFmIAFBHGohZyABQSBqIWggAUEkaiFpIA1BwCFqIgpBBGohLSAKQQhqIS4gCkEMaiEvIApBEGohMCAKQRRqITEgCkEYaiEyIApBHGohOSAKQSBqITogCkEkaiE7IA1BkCJqIhRBBGohjwEgFEEIaiGQASAUQQxqIZEBIBRBEGohkgEgFEEUaiGTASAUQRhqIZQBIBRBHGohlQEgFEEgaiGWASAUQSRqIZcBIAFBLGohPCABQTBqIT0gAUE0aiE+IAFBOGohPyABQTxqIUAgAUFAayFBIAFBxABqIUIgAUHIAGohQyABQcwAaiFEIA1BmCFqIglBBGohmAEgCUEIaiGZASAJQQxqIZoBIAlBEGohmwEgCUEUaiGcASAJQRhqIZ0BIAlBHGohngEgCUEgaiGfASAJQSRqIaABIAFB0ABqIaEBIAFB1ABqIR8gBUEoaiEhIAVBLGohIiAFQTBqISMgBUE0aiEkIAVBOGohJSAFQTxqISYgBUFAayEnIAVBxABqISggBUHIAGohKSAFQcwAaiEqIA1BgAhqKAIAIaIBA0AgAkF/aiEEIAEgAUEAEBogSyACIKIBSnJFBEBBACEDA0AgDSADQYgIbGogBEECdGooAgAiBwRAIAsgA0EDdEHUAGxqIRUgB0EASgRAIAUgFSAHQX9qQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAFIAUgFSAHQX9zQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAgIUG84f//ACAhKAIAazYCACAiQfz9//8AICIoAgBrNgIAICNB/P///wAgIygCAGs2AgAgJEH8////ACAkKAIAazYCACAlQfz///8AICUoAgBrNgIAICZB/P///wAgJigCAGs2AgAgJ0H8////ACAnKAIAazYCACAoQfz///8AICgoAgBrNgIAIClB/P///wAgKSgCAGs2AgAgKkH8//8HICooAgBrNgIACyABIAEgBUEAEBALIANBAWoiAyBKRw0ACwsgAiBMTARAIEkgBEECdGooAgAiAwRAIAAoAgAhByADQQBKBEAgBSAHIANBf2pBAm1BBnRqECMFIAUgByADQX9zQQJtQQZ0ahAjICFBvOH//wAgISgCAGs2AgAgIkH8/f//ACAiKAIAazYCACAjQfz///8AICMoAgBrNgIAICRB/P///wAgJCgCAGs2AgAgJUH8////ACAlKAIAazYCACAmQfz///8AICYoAgBrNgIAICdB/P///wAgJygCAGs2AgAgKEH8////ACAoKAIAazYCACApQfz///8AICkoAgBrNgIAICpB/P//ByAqKAIAazYCAAsCQCBqKAIARQRAIB0oAgAEQCAdQQA2AgAgLCAWEAcgTSAsIBYQCiABIAUgLBAKIBMgYCBNEAogoQFBATYCACAfQgA3AgAgH0IANwIIIB9CADcCECAfQgA3AhggH0EANgIgDAILIB1BADYCACAOIB4gFhAKIBEgDhAHIAYgASkCADcCACAGIAEpAgg3AgggBiABKQIQNwIQIAYgASkCGDcCGCAGIAEpAiA3AiAgVigCACIVQRZ2IgdB0QdsIAYoAgBqIQMgB0EGdCBOKAIAaiADQRp2aiIXQRp2IE8oAgBqIhhBGnYgUCgCAGoiGUEadiBRKAIAaiIaQRp2IFIoAgBqIhtBGnYgUygCAGoiHEEadiBUKAIAaiIgQRp2IFUoAgBqIQcgBiADQf///x9xIkU2AgAgTiAXQf///x9xIhc2AgAgTyAYQf///x9xIhg2AgAgUCAZQf///x9xIhk2AgAgUSAaQf///x9xIho2AgAgUiAbQf///x9xIhs2AgAgUyAcQf///x9xIhw2AgAgVCAgQf///x9xIiA2AgAgVSAHQf///x9xIkY2AgAgViAHQRp2IBVB////AXFqIhU2AgAgEiAFIBEQCiAMIBMpAgA3AgAgDCATKQIINwIIIAwgEykCEDcCECAMIBMpAhg3AhggDCATKQIgNwIgIF8oAgAiR0EWdiIHQdEHbCAMKAIAaiEDIAdBBnQgVygCAGogA0EadmoiM0EadiBYKAIAaiI0QRp2IFkoAgBqIjVBGnYgWigCAGoiNkEadiBbKAIAaiI3QRp2IFwoAgBqIjhBGnYgXSgCAGoiSEEadiBeKAIAaiEHIAwgA0H///8fcSIDNgIAIFcgM0H///8fcSIzNgIAIFggNEH///8fcSI0NgIAIFkgNUH///8fcSI1NgIAIFogNkH///8fcSI2NgIAIFsgN0H///8fcSI3NgIAIFwgOEH///8fcSI4NgIAIF0gSEH///8fcSJINgIAIF4gB0H///8fcSKjATYCACBfIAdBGnYgR0H///8BcWoiBzYCACAPIGAgERAKIA8gDyAOEAogCEG84f//ACBFayASKAIAajYCACBrQfz9//8AIBdrIHQoAgBqNgIAIGxB/P///wAgGGsgdSgCAGo2AgAgbUH8////ACAZayB2KAIAajYCACBuQfz///8AIBprIHcoAgBqNgIAIG9B/P///wAgG2sgeCgCAGo2AgAgcEH8////ACAcayB5KAIAajYCACBxQfz///8AICBrIHooAgBqNgIAIHJB/P///wAgRmsgeygCAGo2AgAgc0H8//8HIBVrIHwoAgBqNgIAIBBBvOH//wAgA2sgDygCAGo2AgAgfUH8/f//ACAzayCGASgCAGo2AgAgfkH8////ACA0ayCHASgCAGo2AgAgf0H8////ACA1ayCIASgCAGo2AgAggAFB/P///wAgNmsgiQEoAgBqNgIAIIEBQfz///8AIDdrIIoBKAIAajYCACCCAUH8////ACA4ayCLASgCAGo2AgAggwFB/P///wAgSGsgjAEoAgBqNgIAIIQBQfz///8AIKMBayCNASgCAGo2AgAghQFB/P//ByAHayCOASgCAGo2AgAgCBAXRQRAIBQgEBAHICsgCBAHIAogCCArEAogHiAeIAgQCiAJIAYgKxAKIAEgCSkCADcCACABIAkpAgg3AgggASAJKQIQNwIQIAEgCSkCGDcCGCABIAkpAiA3AiAgLSgCACEDIC4oAgAhByAvKAIAIRUgMCgCACEXIDEoAgAhGCAyKAIAIRkgOSgCACEaIDooAgAhGyA7KAIAIRwgYSgCAEF+bCEgIGIoAgBBfmwhRSBjKAIAQX5sIUYgZCgCAEF+bCFHIGUoAgBBfmwhMyBmKAIAQX5sITQgZygCAEF+bCE1IGgoAgBBfmwhNiBpKAIAQX5sITcgASABKAIAQX5sQfjC//8BaiAKKAIAayAUKAIAaiI4NgIAIGEgIEH4+///AWogA2sgjwEoAgBqIgM2AgAgYiBFQfj///8BaiAHayCQASgCAGoiBzYCACBjIEZB+P///wFqIBVrIJEBKAIAaiIVNgIAIGQgR0H4////AWogF2sgkgEoAgBqIhc2AgAgZSAzQfj///8BaiAYayCTASgCAGoiGDYCACBmIDRB+P///wFqIBlrIJQBKAIAaiIZNgIAIGcgNUH4////AWogGmsglQEoAgBqIho2AgAgaCA2Qfj///8BaiAbayCWASgCAGoiGzYCACBpIDdB+P//D2ogHGsglwEoAgBqIhw2AgAgE0G0pP//AiA4ayAJKAIAajYCACA8QfT5//8CIANrIJgBKAIAajYCACA9QfT///8CIAdrIJkBKAIAajYCACA+QfT///8CIBVrIJoBKAIAajYCACA/QfT///8CIBdrIJsBKAIAajYCACBAQfT/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NwIIIAAgAykCEDcCECAAIAMpAhg3AhggACADKQIgNwIgQfb6/78CIABBBGoiASgCAEECdGshD0H2//+/AiAAQQhqIhAoAgBBAnRrIRFB9v//vwIgAEEMaiIbKAIAQQJ0ayEcQfb//78CIABBEGoiHSgCAEECdGshHkH2//+/AiAAQRRqIh8oAgBBAnRrISBB9v//vwIgAEEYaiIhKAIAQQJ0ayEiQfb//78CIABBHGoiIygCAEECdGshJEH2//+/AiAAQSBqIiUoAgBBAnRrISZB9v//EyAAQSRqIicoAgBBAnRrISggAEHWs/+/AiAAKAIAQQJ0ayAHKAIAIilqNgIAIAEgDyAHQQRqIg8oAgAiAWo2AgAgECARIAdBCGoiECgCACIRajYCACAbIBwgB0EMaiIbKAIAIhxqNgIAIB0gHiAHQRBqIh0oAgAiHmo2AgAgHyAgIAdBFGoiHygCACIgajYCACAhICIgB0EYaiIhKAIAIiJqNgIAICMgJCAHQRxqIiMoAgAiJGo2AgAgJSAmIAdBIGoiJSgCACImajYCACAnICggB0EkaiInKAIAIihqNgIAIAIoAgBBBmwhKiAGKAIAQQZsISsgCCgCAEEGbCEsIAkoAgBBBmwhLSAKKAIAQQZsIS4gCygCAEEGbCEvIAwoAgBBBmwhMCANKAIAQQZsITEgDigCAEEGbCEyIAMgAygCAEEGbEG84f//ACApa2o2AgAgAiAqQfz9//8AIAFrajYCACAGICtB/P///wAgEWtqNgIAIAggLEH8////ACAca2o2AgAgCSAtQfz///8AIB5rajYCACAKIC5B/P///wAgIGtqNgIAIAsgL0H8////ACAia2o2AgAgDCAwQfz///8AICRrajYCACANIDFB/P///wAgJmtqNgIAIA4gMkH8//8HIChrajYCACAAQShqIgEgBSADEAogB0Ga0v+/ASAEKAIAayICNgIAIA9B+vz/vwEgEigCAGsiAzYCACAQQfr//78BIBMoAgBrIgU2AgAgG0H6//+/ASAUKAIAayIHNgIAIB1B+v//vwEgFSgCAGsiBjYCACAfQfr//78BIBYoAgBrIgg2AgAgIUH6//+/ASAXKAIAayIJNgIAICNB+v//vwEgGCgCAGsiCjYCACAlQfr//78BIBkoAgBrIgs2AgAgJ0H6//8LIBooAgBr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BGohBCAGIAgQDEEBIANrIgNBwABJBH8gBAUgAkGBf2oiDUFAcSIOIAJrQcSSBGohBSADIQIgBCEDA0AgCCADKQAANwAAIAggAykACDcACCAIIAMpABA3ABAgCCADKQAYNwAYIAggAykAIDcAICAIIAMpACg3ACggCCADKQAwNwAwIAggAykAODcAOCADQUBrIQMgBiAIEAwgAkFAaiICQcAATw0ACyANIA5rIQMgBQshAiADBEAgAiEEQQAhAgwCCwsMAQsgCCACaiAEIAMQCxoLIAogECgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCAQIAJBNyACa0E/cUEBaiIDajYCACAGQSBqIQUCQAJAIANBwAAgAkE/cSICayIESQRAQfmMBCEEDAEFIAUgAmpB+YwEIAQQCxogBEH5jARqIQIgBiAFEAwgAyAEayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAIAIhBEEAIQIMAgsLDAELIAUgAmogBCADEAsaCyAQKAIAIgJBP3EhBCAQIAJBCGo2AgAgBkEgaiEFAkACQEHAACAEayIDQQhLBEAgCiECQQghAwwBBSAFIARqIAogAxALGiAKIANqIQIgBiAFEAxBCCADayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAQQAhBAwCCwsMAQsgBSAEaiACIAMQCxoLIAYoAgAQCSESIAZBADYCACAGQQRqIh4oAgAQCSEIIB5BADYCACAGQQhqIh8oAgAQCSENIB9BADYCACAGQQxqIiAoAgAQCSEOICBBADYCACAGQRBqIiEoAgAQCSEFICFBADYCACAGQRRqIiMoAgAQCSEEICNBADYCACAGQRhqIhMoAgAQCSEDIBNBADYCACAGQRxqIh0oAgAQ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EAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADIAIQDSAEQaABaiICIAMQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAJEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAKEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBhANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAsQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAMEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAEQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCAAIAIgBxANIAQkBAvYAwETfyMEIQIjBEHQAGokBCACIAFB0ABqEAcgAiACIAAQCiABKAIkIgZBFnYiAEHRB2wgASgCAGohBCAAQQZ0IAEoAgRqIARBGnZqIgdBGnYgASgCCGoiCEEadiABKAIMaiIJQRp2IAEoAhBqIgpBGnYgASgCFGoiC0EadiABKAIYaiIMQRp2IAEoAhxqIg1BGnYgASgCIGohBUH8/f//ACACKAIEayEOQfz///8AIAIoAghrIQ9B/P///wAgAigCDGshEEH8////ACACKAIQayERQfz///8AIAIoAhRrIRJB/P///wAgAigCGGshE0H8////ACACKAIcayEUQfz///8AIAIoAiBrIQEgAigCJCEAIAJBKGoiA0G84f//ACACKAIAayAEQf///x9xajYCACADIA4gB0H///8fcWo2AgQgAyAPIAhB////H3FqNgIIIAMgECAJQf///x9xajYCDCADIBEgCkH///8fcWo2AhAgAyASIAtB////H3FqNgIUIAMgEyAMQf///x9xajYCGCADIBQgDUH///8fcWo2AhwgAyABIAVB////H3FqNgIgIAMgBkH///8BcUH8//8HaiAAayAFQRp2ajYCJCADEBchACACJAQgAAuXEAEKfyMEIQQjBEHgA2okBCAEQdAAaiEDIARBKGohCCAEQbgDaiILIAEQByALIAsgARAKIARBkANqIgogCxAHIAogCiABEAogBEHoAmoiBiAKKQIANwIAIAYgCikCCDcCCCAGIAopAhA3AhAgBiAKKQIYNwIYIAYgCikCIDcCICAGIAYQByAGIAYQByAGIAYQByAGIAYgChAKIARBwAJqIgIgBikCADcCACACIAYpAgg3AgggAiAGKQIQNwIQIAIgBikCGDcCGCACIAYpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACIAoQCiAEQZgCaiIGIAIpAgA3AgAgBiACKQIINwIIIAYgAikCEDcCECAGIAIpAhg3AhggBiACKQIgNwIgIAYgBhAHIAYgBhAHIAYgBiALEAogBEHwAWoiByAGKQIANwIAIAcgBikCCDcCCCAHIAYpAhA3AhAgByAGKQIYNwIYIAcgBikCIDcCICAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcgBhAKIARByAFqIgUgBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFIAcQCiAEQaABaiICIAUpAgA3AgAgAiAFKQIINwIIIAIgBSkCEDcCECACIAUpAhg3AhggAiAFKQIgNwIgIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAiAFEAogBEH4AGoiCSACKQIANwIAIAkgAikCCDcCCCAJIAIpAhA3AhAgCSACKQIYNwIYIAkgAikCIDcCIEEAIQYDQCAJIAkQByAGQQFqIgZB2ABHDQALIAkgCSACEAogAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMgBRAKIAggAykCADcCACAIIAMpAgg3AgggCCADKQIQNwIQIAggAykCGDcCGCAIIAMpAiA3AiAgCCAIEAcgCCAIEAcgCCAIEAcgCCAIIAoQCiAEIAgpAgA3AgAgBCAIKQIINwIIIAQgCCkCEDcCECAEIAgpAhg3AhggBCAIKQIgNwIgIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCAHEAogBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAsQCiAEIAQQByAAIAQQByAEIAAQB0G84f//ACAEKAIAayABKAIAaiABKAIkQfz//wcgBCgCJGtqIgpBFnYiBkHRB2xqIQBB/P///wAgBCgCIGsgASgC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ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEAwgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQCxoLIAYoAgAQCSEIIAZBADYCACAKKAIAEAkhCSAKQQA2AgAgCygCABAJIQogC0EANgIAIAwoAgAQCSELIAxBADYCACANKAIAEAkhByANQQA2AgAgDigCABAJIQMgDkEANgIAIA8oAgAQCSECIA9BADYCACARKAIAEAkhASAFIAg2AgAgBSAJNgIEIAUgCjYCCCAFIAs2AgwgBSAHNgIQIAUgAzYCFCAFIAI2AhggBSABNgIcIAAgBSAQEA4gBSQEC+YBAQN/IABB4ABqIgMoAgAiBEE/cSEFIAMgBCACajYCAEHAACAFayIEIAJNBEAgAEEgaiIDIAVqIAEgBBALGiABIARqIQEgACADEAwgAiAEayICQcAASQRAQQAhBQUDQCADIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABggAyABKQAgNwAgIAMgASkAKDcAKCADIAEpADA3ADAgAyABKQA4NwA4IAFBQGshASAAIAMQDCACQUBqIgJBwABPDQBBACEFCwsLIAJFBEAPCyAAQSBqIAVqIAEgAhALGgvASwEzfyMEIQkjBEHwAWokBCAAQoGChIiQoMCAATcCACAAQoGChIiQoMCAATcCCCAAQoGChIiQoMCAATcCECAAQoGChIiQoMCAATcCGCAAQSBqIhlCADcCACAZQgA3AgggGUIANwIQIBlCADcCGCAJIgogGRATIApB4ABqIg0oAgAiCUE/cSEEIA0gCUEgajYCACAKQSBqIQsCQAJAQcAAIARrIglBIEsEQCAAIQkgBCEDQSAhCAwBBSALIARqIAAgCRALGiAAIAlqIQMgCiALEAxBICAJayIIQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCAIIQkgAyEIA0AgCyAIKQAANwAAIAsgCCkACDcACCALIAgpABA3ABAgCyAIKQAYNwAYIAsgCCkAIDcAICALIAgpACg3ACggCyAIKQAwNwAwIAsgCCkAODcAOCAIQUBrIQggCiALEAwgCUFAaiIJQcAATw0ACyAHIAZrIQggBAshCSAIBEBBACEDDAILCwwBCyAL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cXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYCAAJAAkBBwAAgA2siBEEgSwRAIAghASADIQJBICEDDAEFIAUgA2ogCCAEEAsaIAggBGohAiAMIAUQDEEgIARrIgFBwABJBH8gASEDIAIFIANBoH9qIgNBBnZBAXQhBiAEQUBqIQQDQCAFIAIpAAA3AAAgBSACKQAINwAIIAUgAikAEDcAECAFIAIpABg3ABggBSACKQAgNwAgIAUgAikAKDcAKCAFIAIpADA3ADAgBSACKQA4NwA4IAJBQGshAiAMIAUQDCABQUBqIgFBwABPDQALIANBP3EhAyAIIAZBBGpBBXRqIARqCyEBIAMEQEEAIQIMAgsLDAELIAUgAmogASADEAsaCyAJIBEoAgAiAUEddkEYdDYCACAJIAFBC3RBgID8B3EgAUEbdHIgAUEFdkGA/gNxciABQRV2Qf8BcXI2AgQgESABQTcgAWtBP3FBAWoiAmo2AgACQAJAIAJBwAAgAUE/cSIBayIDSQRAQfmMBCEDDAEFIAUgAWpB+YwEIAMQCxogA0H5jARqIQEgDCAFEAwgAiADayICQcAATwRAA0AgBSABKQAANwAAIAUgASkACDcACCAFIAEpABA3ABAgBSABKQAYNwAYIAUgASkAIDcAICAFIAEpACg3ACggBSABKQAwNwAwIAUgASkAODcAOCABQUBrIQEgDCAFEAwgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAUgAWogAyACEAsaCyARKAIAIgFBP3EhAyARIAFBCGo2AgACQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAUgA2ogCSACEAsaIAkgAmohASAMIAUQDEEIIAJrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAFIANqIAEgAhALGgsgDCgCABAJIQ4gDEEANgIAIBMoAgAQCSELIBNBADYCACAUKAIAEAkhByAUQQA2AgAgFSgCABAJIQYgFUEANgIAIBYoAgAQCSEEIBZBADYCACAXKAIAEAkhAyAXQQA2AgAgGCgCABAJIQIgGEEANgIAICEoAgAQCSEBICFBADYCACAuIA42AAAgLyALNgAAIDAgBzYAACAxIAY2AAAgMiAENgAAIDMgAzYAACA0IAI2AAAgNSABNgAAIAogGRATIA0oAgAiAUE/cSEEIA0gAUEgajYCACAKQSBqIQsCQAJAQcAAIARrIgFBIEsEQCAAIQEgBCEDQSAhAgwBBSALIARqIAAgARALGiAAIAFqIQMgCiALEAxBICABayICQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCACIQEgAyECA0AgCyACKQAANwAAIAsgAikACDcACCALIAIpABA3ABAgCyACKQAYNwAYIAsgAikAIDcAICALIAIpACg3ACggCyACKQAwNwAwIAsgAikAODcAOCACQUBrIQIgCiALEAwgAUFAaiIBQcAATw0ACyAHIAZrIQIgBAshASACBEBBACEDDAILCwwBCyALIANqIAEgAhALGgsgCSANKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYC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AEIANwIQIABCADcCGAsgASABKAIAIARqNgIAIAMkBEEBC9YDAQN/IwQhAyMEQYABaiQEIAAgASkCADcCACAAIAEpAgg3AgggACABKQIQNwIQIAAgASkCGDcCGCAAIAEpAiA3AiAgA0HQAGoiBSABEAcgA0EoaiIEIAEgBRAKIABBADYCUCADIAQoAgBBB2o2AgAgAyAEKAIENgIEIAMgBCgCCDYCCCADIAQoAgw2AgwgAyAEKAIQNgIQIAMgBCgCFDYCFCADIAQoAhg2AhggAyAEKAIcNgIcIAMgBCgCIDYCICADIAQoAiQ2AiQgAEEoaiIFIAMQIkUEQCADJARBAA8LIAUQFiAFKAIAIgFBAXEgAkYEQCADJARBAQ8LIAVBvOH//wAgAWs2AgAgAEEsaiIBQfz9//8AIAEoAgBrNgIAIABBMGoiAUH8////ACABKAIAazYCACAAQTRqIgFB/P///wAgASgCAGs2AgAgAEE4aiIBQfz///8AIAEoAgBrNgIAIABBPGoiAUH8////ACABKAIAazYCACAAQUBrIgFB/P///wAgASgCAGs2AgAgAEHEAGoiAUH8////ACABKAIAazYCACAAQcgAaiIBQfz///8AIAEoAgBrNgIAIABBzABqIgBB/P//ByAAKAIAazYCACADJARBAQv2CwIRfwJ+IwQhBSMEQaADaiQEIAVBuAJqIgJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUUEQCAAQQA2ApwBIABBJGoiA0GQiAQpAgA3AgAgA0GYiAQpAgA3AgggA0GgiAQpAgA3AhAgA0GoiAQpAgA3AhggA0GwiAQpAgA3AiAgAEEBNgJ0IABB+ABqIgNCADcCACADQgA3AgggA0IANwIQIANCADcCGCADQQA2AiAgAEGEuLznADYCTCAAQf61r/AANgJQIABBuMz59QA2AlQgAEHny/X2ADYCWCAAQcjQi/gANgJcIABB0vvu4wA2AmAgAEG8gMHtADYCZCAAQYbVuecANgJoIABB2bKj7AA2AmwgAEHG4rcHNgJwIABBATYCBCAAQQhqIgNCADcCACADQgA3AgggA0IANwIQIANBADYCGAsgBUH4AmoiBiAAQQRqIg8QESACIAYpAAA3AAAgAiAGKQAINwAIIAIgBikAEDcAECACIAYpABg3ABggAUEARyIHBEAgAkEgaiIDIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABgLIAVBkAJqIQggBUHwAWohBCAFQfAAaiEDIAVByABqIQEgBUEEaiIQIAIgBwR/QcAABUEgCxAqIAJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUEEaiECIAFBCGohByABQQxqIQkgAUEQaiEKIAFBFGohCyABQRhqIQwgAUEcaiENIAFBIGohESABQSRqIRIDQCAQIAYQHyAFIAEgBhAURSIONgIAIA4EQCAFQQE2AgAMAQUgBSACKAIAIAEoAgByIAcoAgByIAkoAgByIAooAgByIAsoAgByIAwoAgByIA0oAgByIBEoAgByIBIoAgByRSIONgIAIA4NAQsLIAggARAHIABBJGoiAiACIAgQCiAAQcwAaiIHIAcgCBAKIAcgByABEAogAEH0AGoiCCAIIAEQCiABQgA3AgAgAUIANwIIIAFCADcCECABQgA3AhggAUIANwIgIARBBGohASAEQQhqIQggBEEMaiEHIARBEGohCSAEQRRqIQogBEEYaiELIARBHGohDANAIBAgBhAfIAQgBiAFEA4gBSgCAARAIAVBATYCAAwBBSAFIAEoAgAgBCgCAHIgCCgCAHIgBygCAHIgCSgCAHIgCigCAHIgCygCAHIgDCgCAHJFIg02AgAgDQ0BCwsgBkIANwAAIAZCADcACCAGQgA3ABAgBkIANwAYIAAgAyAEEB4gBCAEKAIAIgBBf3OtQsKC2YENfCITIAEoAgAiBiAAciAIKAIAIgByIAcoAgAiEHIgCSgCACINciAKKAIAIhFyIAsoAgAiEnIgDCgCACIOckEAR0EfdEEfda0iFIM+AgAgASATQiCIQoy9yf4LhCAGQX9zrXwiEyAUgz4CACAIIABBf3OtQrvAovoKfCATQiCIfCITIBSDPgIAIAcgEEF/c61C5rm71Qt8IBNCIIh8IhMgFIM+AgAgCSANQX9zrUL+////D3wgE0IgiHwiEyAUgz4CACAKIBFBf3OtQv////8PfCATQiCIfCITIBSDPgIAIAsgEkF/c61C/////w98IBNCIIh8IhMgFIM+AgAgDCAO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KSAGQQhqISogBkEMaiErIAZBEGohLCAGQRRqIS0gBkEYaiEuIAZBHGohLyAGQSBqITAgBkEkaiExIANBBGohMiADQQhqITMgA0EMaiE0IANBEGohNSADQRRqITYgA0EYaiE3IANBHGohOCADQSBqITkgA0EkaiE6IARBBGohOyAEQQhqIQkgBEEMaiEMIARBEGohDiAEQRRqIQ8gBEEYaiERIARBHGohEiAEQSBqIRMgBEEkaiEVIA0oAgBBvOH//wBqIRYgDSgCBEH8/f//AGohFyANKAIIQfz///8AaiEYIA0oAgxB/P///wBqIRkgDSgCEEH8////AGohGiANKAIUQfz///8AaiEbIA0oAhhB/P///wBqIRwgDSgCHEH8////AGohHSANKAIgQfz///8AaiEeIA0oAiRB/P//B2ohH0H/PyEBA0AgBiAHIAFBf2oiAkEGdGoiIBAjIBAgECAGEAogFCAQEAcgKCAUIBAQCiAGIAYgFBAKICkoAgAhISAqKAIAISIgKygCACEjICwoAgAhJCAtKAIAISUgLigCACEmIC8oAgAhJyAwKAIAIQsgMSgCACEFIAYgFiAGKAIAazYCACApIBcgIWs2AgAgKiAYICJrNgIAICsgGSAjazYCACAsIBogJGs2AgAgLSAbICVrNgIAIC4gHCAmazYCACAvIB0gJ2s2AgAgMCAeIAtrNgIAIDEgHyAFazYCACAKIAogKBAKIAMgBikCADcCACADIAYpAgg3AgggAyAGKQIQNwIQIAMgBikCGDcCGCADIAYpAiA3AiAgAxAPIAQgCikCADcCACAEIAopAgg3AgggBCAKKQIQNwIQIAQgCikCGDcCGCAEIAopAiA3AiAgBBAPICAgMigCACILQRp0IAMoAgByNgIAIAcgAkEGdGogMygCACIFQRR0IAtBBnZyNgIEIAcgAkEGdGogNCgCACILQQ50IAVBDHZyNgIIIAcgAkEGdGogNSgCACIFQQh0IAtBEnZyNgIMIAcgAkEGdGogNigCAEECdCAFQRh2ciA3KAIAIgVBHHRyNgIQIAcgAkEGdGogOCgCACILQRZ0IAVBBHZyNgIUIAcgAkEGdGogOSgCACIFQRB0IAtBCnZyNgIYIAcgAkEGdGogOigCAEEKdCAFQRB2cjYCHCAHIAJBBnRqIDsoAgAiC0EadCAEKAIA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IAYoAgBFBEAgBygCBCAHKAIAciAHKAIIciAHKAIMciAHKAIQciAHKAIUciAHKAIYciAHKAIccgRAIAkgAkEAEA4CQCAMIAIgA0EAIAVBACAOQQFxEQEAIgAEQCAIQQRqIRAgCEEIaiERIAhBDGohEiAIQRBqIRMgCEEUaiEUIAhBGGohFSAIQRxqIRZBACEEA0AgCCAMIAYQDiAGKAIARQRAIBAoAgAgCCgCAHIgESgCAHIgEigCAHIgEygCAHIgFCgCAHIgFSgCAHIgFigCAHIEQCAPIAogCyAHIAkgCCANEDENBAsLIAwgAiADQQAgBSAEQQFqIgQgDkEBcREBACIADQBBACEACwVBACEACwsgCUIANwIAIAlCADcCCCAJQgA3AhAgCUIANwIYIAhCADcCACAIQgA3AgggCEIANwIQIAhCADcCGCAHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggAARAIA0oAgAhAyABIAopAAA3AAAgASAKKQAINwAIIAEgCikAEDcAECABIAopABg3ABggAUEgaiICIAspAAA3AAAgAiALKQAINwAIIAIgCykAEDcAECACIAspABg3ABggAUFAayADOgAAIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAGJARBAAv+AQECfyMEIQQjBEFAayQEIAFFBEBByooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgA0UEQEGuigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEQSBqIQUgAgR/IAUgAykAADcAACAFIAMpAAg3AAggBSADKQAQNwAQIAUgAykAGDcAGCAEIANBIGoiACkAADcAACAEIAApAAg3AAggBCAAKQAQNwAQIAQgACkAGDcAGCACIANBQGstAAA2AgAgASAFEBEgAUEgaiAEEBEgBCQEQQEFQb6MBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAAsL7wIBA38jBCEEIwRB0ABqJAQgBEEANgIAIAFFBEBBrooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAkUEQEG6igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyADQQNLBEBBpYwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgBEEoaiIFIAIgBBAOIAQoAgAhACAEQQhqIgYgAkEgaiAEEA4gBCgCACAAckUiACECIAAEfyABIAUpAAA3AAAgASAFKQAINwAIIAEgBSkAEDcAECABIAUpABg3ABggAUEgaiIAIAYpAAA3AAAgACAGKQAINwAIIAAgBikAEDcAECAAIAYpABg3ABggAUFAayADOgAAIAQkBCACBSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAEJAQgAgsLlCoBX38jBCEHIwRBwANqJAQgB0GgAWohCCAHQfgAaiEKIAFB+ABqIUAgB0GQA2oiBiABQdAAaiI9EAcgB0HoAmoiAyABKQIANwIAIAMgASkCCDcCCCADIAEpAhA3AhAgAyABKQIYNwIYIAMgASkCIDcCICADQSRqIiUoAgAiFEEWdiIEQdEHbCADKAIAaiEFIARBBnQgA0EEaiImKAIAaiAFQRp2aiIVQRp2IANBCGoiJygCAGoiFkEadiADQQxqIhwoAgBqIhdBGnYgA0EQaiIdKAIAaiIYQRp2IANBFGoiMSgCAGoiDkEadiADQRhqIjIoAgBqIiBBGnYgA0EcaiIzKAIAaiIhQRp2IANBIGoiNCgCAGohBCADIAVB////H3E2AgAgJiAVQf///x9xNgIAICcgFkH///8fcTYCACAcIBdB////H3E2AgAgHSAYQf///x9xNgIAIDEgDkH///8fcTYCACAyICBB////H3E2AgAgMyAhQf///x9xNgIAIDQgBEH///8fcTYCACAlIARBGnYgFEH///8BcWo2AgAgB0HAAmoiBCACIAYQCiABKAJMIhlBFnYiBUHRB2wgASgCKGohGiAFQQZ0IAEoAixqIBpBGnZqIihBGnYgASgCMGoiKUEadiABKAI0aiIqQRp2IAEoAjhqIitBGnYgASgCPGoiLEEadiABQUBrKAIAaiItQRp2IAEoAkRqIiJBGnYgASgCSGohHiAHQZgCaiIFIAJBKGoiWCAGEAogBSAFID0QCiAHQfABaiIBIAMpAgA3AgAgASADKQIINwIIIAEgAykCEDcCECABIAMpAhg3AhggASADKQIgNwIgIAEgASgCACAEKAIAIgZqNgIAIAFBBGoiFCAUKAIAIAQoAgQiNWo2AgAgAUEIaiIVIBUoAgAgBCgCCCI2ajYCACABQQxqIhYgFigCACAEKAIMIjdqNgIAIAFBEGoiFyAXKAIAIAQoAhAiCWo2AgAgAUEUaiIYIBgoAgAgBCgCFCIQajYCACABQRhqIg4gDigCACAEKAIYIgtqNgIAIAFBHGoiICAgKAIAIAQoAhwiEWo2AgAgAUEgaiIhICEoAgAgBCgCICIPajYCACABQSRqIi4gLigCACAEKAIkIiNqNgIAIAUoAgAgGkH///8fcSJDaiE4IAUoAgQgKEH///8fcSJEaiEoIAUoAgggKUH///8fcSJFaiEpIAUoAgwgKkH///8fcSJGaiEqIAUoAhAgK0H///8fcSJHaiErIAUoAhQgLEH///8fcSJIaiEsIAUoAhggLUH///8fcSJJaiEtIAUoAhwgIkH///8fcSJKaiEiIAUoAiAgHkH///8fcSJLaiEvIAUoAiQgHkEadiAZQf///wFxaiJMaiEaIAdB0ABqIgQgARAHIAdBKGoiBUG84f//ACAGazYCACAFQQRqIj5B/P3//wAgNWs2AgAgBUEIaiI1Qfz///8AIDZrNgIAIAVBDGoiNkH8////ACA3azYCACAFQRBqIjdB/P///wAgCWs2AgAgBUEUaiIJQfz///8AIBBrNgIAIAVBGGoiEEH8////ACALazYCACAFQRxqIgtB/P///wAgEWs2AgAgBUEgaiIRQfz///8AIA9rNgIAIAVBJGoiD0H8//8HICNrNgIAIAdByAFqIgYgAyAFEAogBCAEKAIAIAYoAgBqNgIAIARBBGoiIygCACAGKAIEaiEMICMgDDYCACAEQQhqIjAoAgAgBigCCGohDSAwIA02AgAgBEEMaiI5KAIAIAYoAgxqIRIgOSASNgIAIARBEGoiOigCACAGKAIQaiETIDogEzYCACAEQRRqIjsoAgAgBigCFGohHyA7IB82AgAgBEEYaiI/KAIAIAYoAhhqIRsgPyAbNgIAIARBHGoiQSgCACAGKAIcaiEkIEEgJDYCACAEQSBqIkIoAgAgBigCIGohPCBCIDw2AgAgBEEkaiJOKAIAIAYoAiRqIQYgTiAGNgIAIBpBFnYiGUHRB2wgOGohHiAZQQZ0IChqIB5BGnZqIk9BGnYgKWoiUEEadiAqaiJRQRp2ICtqIlJBGnYgLGoiU0EadiAtaiJUQRp2ICJqIlVBGnYgL2oiVkEadiAaQf///wFxaiFXIAZBFnYiTUHRB2wgBCgCAGohGSBNQQZ0IAxqIBlBGnZqIgxBGnYgDWoiDUEadiASaiISQRp2IBNqIhNBGnYgH2oiH0EadiAbaiIbQRp2ICRqIiRBGnYgPGoiPEEadiAGQf///wFxaiEGIAdBBGohTSAHQQhqIVkgB0EMaiFaIAdBEGohWyAHQRRqIVwgB0EYaiFdIAdBHGohXiAHQSBqIV8gB0EkaiFgIENBAXQhQyBEQQF0IUQgRUEBdCFFIEZBAXQhRiBHQQF0IUcgSEEBdCFIIElBAXQhSSBKQQF0IUogS0EBdCFLIExBAXQhTCAFKAIAIAMoAgBqIWEgPigCACAmKAIAaiEmIDUoAgAgJygCAGohJyA2KAIAIBwoAgBqIRwgNygCACAdKAIAaiEdIAkoAgAgMSgCAGohMSAQKAIAIDIoAgBqITIgCygCACAzKAIAaiEzIBEoAgAgNCgCAGohNCAPKAIAICUoAgBqISUgBCgCACEEIAcgTyAeciBQciBRciBSciBTciBUciBVciBWckH///8fcSBXcgR/IE9BwABzIB5B0AdzcSBQcSBRcSBScSBTcSBUcSBVcSBWcSBXQYCAgB5zcUH///8fRgVBAQsgDCAZciANciASciATciAfciAbciAkciA8ckH///8fcSAGcgR/IAxBwABzIBlB0AdzcSANcSAScSATcSAfcSAbcSAkcSA8cSAGQYCAgB5zcUH///8fRgVBAQtxIgMEfyBDBSAECzYCACAjKAIAIQQgTSADBH8gRAUgBAs2AgAgMCgCACEEIFkgAwR/IEUFIAQLNgIAIDkoAgAhBCBaIAMEfyBGBSAECzYCACA6KAIAIQQgWyADBH8gRwUgBAs2AgAgOygCACEEIFwgAwR/IEgFIAQLNgIAID8oAgAhBCBdIAMEfyBJBSAECzYCACBBKAIAIQQgXiADBH8gSgUgBAs2AgAgQigCACEEIF8gAwR/IEsFIAQLNgIAIE4oAgAhBCBgIAMEfyBMBSAECzYCACAFIAMEfyBhBSA4CzYCACA+IAMEfyAmBSAoCzYCACA1IAMEfyAnBSApCzYCACA2IAMEfyAcBSAqCzYCACA3IAMEfyAdBSArCzYCACAJIAMEfyAxBSAsCzYCACAQIAMEfyAyBSAtCzYCACALIAMEfyAzBSAiCzYCACARIAMEfyA0BSAvCzYCACAPIAMEfyAlBSAaCzYCACAIIAUQByAKIAggARAKIAggCBAHIAgoAgAhBCAIIAMEfyA4BSAECzYCACAIQQRqIh4oAgAhBCAeIAMEfyAoBSAECzYCACAIQQhqIhkoAgAhBCAZIAMEfyApBSAECzYCACAIQQxqIiUoAgAhBCAlIAMEfyAqBSAECzYCACAIQRBqIiYoAgAhBCAmIAMEfyArBSAECzYCACAIQRRqIicoAgAhBCAnIAMEfyAsBSAECzYCACAIQRhqIhwoAgAhBCAcIAMEfyAtBSAECzYCACAIQRxqIh0oAgAhBCAdIAMEfyAiBSAECzYCACAIQSBqIiIoAgAhBCAiIAMEfyAvBSAECzYCACAIQSRqIi8oAgAhBCAvIAMEfyAaBSAECzYCACABIAcQByAAQdAAaiIEID0gBRAKIABB9ABqIgUoAgAiA0EWdiIaQdEHbCAEKAIAIglqIQYgGkEGdCAAQdQAaiIaKAIAIhBqIAZBGnZqIj1BGnYgAEHYAGoiOCgCACILaiIxQRp2IABB3ABqIigoAgAiEWoiMkEadiAAQeAAaiIpKAIAIg9qIjNBGnYgAEHkAGoiKigCACIjaiI0QRp2IABB6ABqIisoAgAiDGoiPkEadiAAQewAaiIsKAIAIjBqIjVBGnYgAEHwAGoiLSgCACINaiI2QRp2IANB////AXFqITdBASBAKAIAayFBIAQgCUEBdDYCACAaIBBBAXQ2AgAgOCALQQF0NgIAICggEUEBdDYCACApIA9BAXQ2AgAgKiAjQQF0NgIAICsgDEEBdDYCACAsIDBBAXQ2AgAgLSANQQF0NgIAIAUgA0EBdDYCACAKQbzh//8AIAooAgBrIiQ2AgBB/P3//wAgCkEEaiIDKAIAayEJIAMgCTYCAEH8////ACAKQQhqIhAoAgBrIQsgECALNgIAQfz///8AIApBDGoiESgCAGshDyARIA82AgBB/P///wAgCkEQaiIjKAIAayEMICMgDDYCAEH8////ACAKQRRqIjAoAgBrIQ0gMCANNgIAQfz///8AIApBGGoiOSgCAGshEiA5IBI2AgBB/P///wAgCkEcaiI6KAIAayETIDogEzYCAEH8////ACAKQSBqIjsoAgBrIR8gOyAfNgIAQfz//wcgCkEkaiI/KAIAayEbID8gGzYCACAuKAIAIBtqIkJBFnYiPEHRB2wgASgCACAkamohGyA8QQZ0IBQoAgAgCWpqIBtBGnZqIiRBGnYgFSgCACALamoiC0EadiAWKAIAIA9qaiIPQRp2IBcoAgAgDGpqIgxBGnYgGCgCACANamoiDUEadiAOKAIAIBJqaiISQRp2ICAoAgAgE2pqIhNBGnYgISgCACAfamohCSABIBtB////H3EiHzYCACAUICRB////H3EiGzYCACAVIAtB////H3EiCzYCACAWIA9B////H3EiDzYCACAXIAxB////H3EiDDYCACAYIA1B////H3EiDTYCACAOIBJB////H3EiEjYCACAgIBNB////H3EiEzYCACAhIAlB////H3EiJDYCACAuIAlBGnYgQkH///8BcWoiCTYCACAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAEgH0EBdCAKKAIAajYCACAUIBtBAXQgAygCAGo2AgAgFSALQQF0IBAoAgBqNgIAIBYgD0EBdCARKAIAajYCACAXIAxBAXQgIygCAGo2AgAgGCANQQF0IDAoAgBqNgIAIA4gEkEBdCA5KAIAajYCACAgIBNBAXQgOigCAGo2AgAgISAkQQF0IDsoAgBqNgIAIC4gCUEBdCA/KAIAajYCACABIAEgBxAKIAEgASgCACAIKAIAaiIBNgIAIBQgFCgCACAeKAIAaiIDNgIAIBUgFSgCACAZKAIAaiIINgIAIBYgFigCACAlKAIAaiIKNgIAIBcgFygCACAmKAIAaiIUNgIAIBggGCgCACAnKAIAaiIVNgIAIA4gDigCACAcKAIAaiIWNgIAICAgICgCACAdKAIAaiIXNgIAICEgISgCACAiKAIAaiIYNgIAIC4gLigCACAvKAIAaiIONgIAQfj//w8gDmsiD0EWdiIOQdEHbEH4wv//ASABa2ohASAOQQZ0Qfj7//8BIANraiABQRp2aiIcQRp2Qfj///8BIAhraiIdQRp2Qfj///8BIApraiIJQRp2Qfj///8BIBRraiIQQRp2Qfj///8BIBVraiILQRp2Qfj///8BIBZraiIR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FHZyNgIwIAIgEUESdEGAgPAfcSAQQQ52cjYCNCACIAVBGHRBgICAGHEgEUEIdnI2AjggAiAFQQJ2Qf///x9xNgI8IAJBQGsgEkEEdEHw//8fcSAFQRx2cjYCACACIBNBCnRBgPj/H3EgEkEWdnI2AkQgAiAUQRB0QYCA/B9xIBNBEHZyNgJIIAIgFEEKdjYCTCACQdAAaiINQQA2AgAgDiACKAIAciAGciAHciAIciAVciADciAKciALciAMckUEQEHajAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIARBwAJqIQogBEGYAmohCyAEQfgBaiEIIARB/ABqIQMgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAJKAIEIAkoAgByIAkoAghyIAkoAgxyIAkoAhByIAkoAhRyIAkoAhhyIAkoAhxyBH8gCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIANB+ABqIgxBADYCACADIAIpAgA3AgAgAyACKQIINwIIIAMgAikCEDcCECADIAIpAhg3AhggAyACKQIgNwIgIANBKGoiBSACQShqIgYpAgA3AgAgBSAGKQIINwIIIAUgBikCEDcCECAFIAYpAhg3AhggBSAGKQIgNwIgIANBATYCUCADQdQAaiIHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggB0EANgIgIAAgAyADIAkgCBAZIA0gDCgCADYCACADQdAAaiIAIAAQFSAKIAAQByALIAAgChAKIAMgAyAKEAogBSAFIAsQCiAAQQE2AgAgB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCICACIAMpAgA3AgAgAiADKQIINwIIIAIgAykCEDcCECACIAMpAhg3AhggAiADKQIgNwIgIAYgBSkCADcCACAGIAUpAgg3AgggBiAFKQIQNwIQIAYgBSkCGDcCGCAGIAUpAiA3AiAgASACEBsgBCQEQQEFIAQkBEEACwvhAgEBfyMEIQMjBEHQAGokBCADQQA2AgAgAUUEQEGIjAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAyQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACADJARBAA8LIANBKGoiACACIAMQDiADQQhqIgIgAUEAEA4gAygCAAR/IAFCADcAACABQgA3AAggAUIANwAQIAFCADcAGEEABSAAKAIEIAAoAgByIAAoAghyIAAoAgxyIAAoAhByIAAoAhRyIAAoAhhyIAAoAhxyBH8gAiACIAAQDSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggASACEBFBAQUgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYQQALCyEBIAJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAyQEIAELgAsBE38jBCEEIwRB8AJqJAQgBEEANgIAIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAA8LIARBCGoiFCACIAQQDiAEKAIABEAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIAEoAAQhBiABKAAIIQcgASgADCEIIAEoABAhAyABKAAUIQkgASgAGCEKIAEoABwhCyABKAAgIQwgASgAJCENIAEoACghDyABKAAsIRAgASgAMCEFIAEoADQhESABKAA4IRIgASgAPCETIARBKGoiAiABKAAAIg5B////H3E2AgAgAiAGQQZ0QcD//x9xIA5BGnZyIg42AgQgAiAHQQx0QYDg/x9xIAZBFHZyIgY2AgggAiAIQRJ0QYCA8B9xIAdBDnZyIgc2AgwgAiADQRh0QYCAgBhxIAhBCHZyIgg2AhAgAiADQQJ2Qf///x9xIhU2AhQgAiAJQQR0QfD//x9xIANBHHZyIgM2AhggAiAKQQp0QYD4/x9xIAlBFnZyIgk2AhwgAiALQRB0QYCA/B9xIApBEHZyIgo2AiAgAiALQQp2Igs2AiQgAiAMQf///x9xNgIoIAIgDUEGdEHA//8fcSAMQRp2cjYCLCACIA9BDHRBgOD/H3Eg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AWoiBCANQQFxEQEAIgANAEEAIQALBUEAIQALCyAJQgA3AgAgCUIANwIIIAlCADcCECAJQgA3AhggCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIAdCADcCACAHQgA3AgggB0IANwIQIAdCADcCGCAABEAgASAKKQAANwAAIAEgCikACDcACCABIAopABA3ABAgASAKKQAYNwAYIAFBIGoiASALKQAANwAAIAEgCykACDcACCABIAspABA3ABAgASALKQAYNwAYIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAYkBEEAC9cCAQJ/IwQhByMEQcABaiQEIAdByABqIgYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGQSBqIgIgASkAADcAACACIAEpAAg3AAggAiABKQAQNwAQIAIgASkAGDcAGCAEBH8gBkFAayIBIAQpAAA3AAAgASAEKQAINwAIIAEgBCkAEDcAECABIAQpABg3ABhB4AAFQcAACyEBIAMEQCAGIAFqIgIgAykAADcAACACIAMpAAg3AAggAUEQciEBCyAHIAYgARAqIAZCADcAACAGQgA3AAggBkIANwAQIAZCADcAGCAGQgA3ACAgBkIANwAoIAZCADcAMCAGQgA3ADggBkFAa0IANwAAIAZCADcASCAGQgA3AFAgBkIANwBYIAZCADcAYCAGQgA3AGhBACEBA0AgByAAEB8gAUEBaiIBIAVNDQALIAckBEEBC90QASl/IwQhBSMEQYAEaiQEIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgAkUEQEGsiwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyABRQRAQa6KBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIANFBEBB5IgEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgBSACQQAQDiAFQUBrIgYgASkAADcAACAGIAEpAAg3AAggBiABKQAQNwAQIAYgASkAGDcAGCAFQSBqIgQgAUEgaiIBKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIARBGGoi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////HzYCACAGQf///x82AgAgAkH///8BNgIAIAMgBxAhQQBHCwsLCwsLCwsFQQALBUEACwshACAFJAQgAAuYBQIJfwd+IwQhBCMEQSBqJAQgAkUEQEHbigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEIgAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCACKAA4IghBf0cgAigAPCIEQR92IgVBf3MiA3EgBEH/////B0lyIAMgAigANCIJQX9HcXIgAyACKAAwIgpBf0dxciADIAIoACwiA0Hz3N3qBUlxciIGQQFzIANB89zd6gVLcSAFciIHQQFzIAIoACgiBUGdoJG9BUlxIAZyIgtBAXMgBUGdoJG9BUtxIAdyIgdBAXMgAigAJCIGQcbepP99SXEgC3JBf3MiCyAGQcbepP99S3EgB3IgCyACKAAgIgJBoMHswAZLcXIhByABRQRAIAAkBCAHDwsgBwRAIAhBf3OtQv////8PfCAJQX9zrUL/////D3wgCkF/c61C/v///w98IANBf3OtQua5u9ULfCAFQX9zrUK7wKL6CnwgBkF/c61CjL3J/gt8IAJBf3OtQsKC2YENfCIMQiCIfCIOQiCIfCIPQiCIfCIQQiCIfCIRQiCIfCISQiCIfCENIAwgBiACciAFciADciAKciAJciAIciAEckEAR0EfdEEfda0iDIOnIQIgDyAMg6chBSAQIAyDpyEDIBEgDIOnIQogEiAMg6chCSANIAyDpyEIIARBf3OtQv////8PfCANQiCIfCAMg6chBCAOIAyDpyEGCyABIAApAAA3AAAgASAAKQAINwAIIAEgACkAEDcAECABIAApABg3ABggASACNgAgIAEgBjYAJCABIAU2ACggASADNgAsIAEgCjYAMCABIAk2ADQgASAINgA4IAEgBDYAPCAAJAQgBwuDAwIGfwh+IAJFBEBB24oEIAAoAqgBIAAoAqQBQQNxQQJqEQAAQQAPCyABBH8gAigAICIAQX9zrULCgtmBDXwhCiACKAAkIgMgAHIgAigAKCIAciACKAAsIgRyIAIoADAiBXIgAigANCIGciACKAA4IgdyIAIoADwiCHJBAEdBH3RBH3WtIQkgB0F/c61C/////w98IAZBf3OtQv////8PfCAFQX9zrUL+////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';
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/secp256k1/secp256k1-wasm.js
/* eslint-disable no-underscore-dangle */
// cSpell:ignore memcpy, anyfunc




/* eslint-disable @typescript-eslint/no-explicit-any */

const wrapSecp256k1Wasm = (instance, heapU8, heapU32) => ({
  contextCreate: context => instance.exports._secp256k1_context_create(context),
  contextRandomize: (contextPtr, seedPtr) => instance.exports._secp256k1_context_randomize(contextPtr, seedPtr),
  free: pointer => instance.exports._free(pointer),
  heapU32,
  heapU8,
  instance,
  malloc: bytes => instance.exports._malloc(bytes),
  mallocSizeT: num => {
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const pointer = instance.exports._malloc(4); // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers


    const pointerView32 = pointer >> 2; // eslint-disable-next-line functional/no-expression-statement

    heapU32.set([num], pointerView32);
    return pointer;
  },
  mallocUint8Array: array => {
    const pointer = instance.exports._malloc(array.length); // eslint-disable-next-line functional/no-expression-statement


    heapU8.set(array, pointer);
    return pointer;
  },
  privkeyTweakAdd: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr),
  privkeyTweakMul: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr),
  pubkeyCreate: (contextPtr, publicKeyPtr, secretKeyPtr) => instance.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr),
  pubkeyParse: (contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) => instance.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength),
  pubkeySerialize: (contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) => instance.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression),
  pubkeyTweakAdd: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr),
  pubkeyTweakMul: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr),
  readHeapU8: (pointer, bytes) => new Uint8Array(heapU8.buffer, pointer, bytes),
  readSizeT: pointer => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const pointerView32 = pointer >> 2;
    return heapU32[pointerView32];
  },
  recover: (contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) => instance.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr),
  recoverableSignatureParse: (contextPtr, outputRSigPtr, inputSigPtr, rid) => instance.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid),
  recoverableSignatureSerialize: (contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) => instance.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr),
  schnorrSign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_schnorr_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
  schnorrVerify: (contextPtr, sigPtr, msg32Ptr, publicKeyPtr) => instance.exports._secp256k1_schnorr_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr),
  seckeyVerify: (contextPtr, secretKeyPtr) => instance.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr),
  sign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
  signRecoverable: (contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr),
  signatureMalleate: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_malleate(contextPtr, outputSigPtr, inputSigPtr),
  signatureNormalize: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr),
  signatureParseCompact: (contextPtr, sigOutPtr, compactSigInPtr) => instance.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr),
  signatureParseDER: (contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) => instance.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength),
  signatureSerializeCompact: (contextPtr, outputCompactSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr),
  signatureSerializeDER: (contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr),
  verify: (contextPtr, sigPtr, msg32Ptr, pubkeyPtr) => instance.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr)
});
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */

/**
 * Method extracted from Emscripten's preamble.js
 */


const isLittleEndian = buffer => {
  const littleEndian = true;
  const notLittleEndian = false;
  const heap16 = new Int16Array(buffer);
  const heap32 = new Int32Array(buffer);
  const heapU8 = new Uint8Array(buffer);
  heap32[0] = 1668509029;
  heap16[1] = 25459;
  return heapU8[2] !== 115 || heapU8[3] !== 99 ?
  /* istanbul ignore next */
  notLittleEndian : littleEndian;
};
/**
 * Method derived from Emscripten's preamble.js
 */


const alignMemory = (factor, size) => Math.ceil(size / factor) * factor;
/**
 * The most performant way to instantiate secp256k1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateSecp256k1`.
 *
 * Note, most of this method is translated and boiled-down from Emscripten's
 * preamble.js. Significant changes to the WASM build or breaking updates to
 * Emscripten will likely require modifications to this method.
 *
 * @param webassemblyBytes A buffer containing the secp256k1 binary.
 */


const instantiateSecp256k1WasmBytes = async webassemblyBytes => {
  const STACK_ALIGN = 16;
  const GLOBAL_BASE = 1024;
  const WASM_PAGE_SIZE = 65536;
  const TOTAL_STACK = 5242880;
  const TOTAL_MEMORY = 16777216;
  const wasmMemory = new WebAssembly.Memory({
    initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
    maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
  });
  /* istanbul ignore if  */

  if (!isLittleEndian(wasmMemory.buffer)) {
    /*
     * note: this block is excluded from test coverage. It's A) hard to test
     * (must be either tested on big-endian hardware or a big-endian buffer
     * mock) and B) extracted from Emscripten's preamble.js, where it should
     * be tested properly.
     */
    throw new Error('Runtime error: expected the system to be little-endian.');
  }

  const STATIC_BASE = GLOBAL_BASE;
  const STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
  const DYNAMICTOP_PTR = STATICTOP_INITIAL;
  const DYNAMICTOP_PTR_SIZE = 4;
  const STATICTOP = STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15 & -16;
  const STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
  const STACK_BASE = STACKTOP;
  const STACK_MAX = STACK_BASE + TOTAL_STACK;
  const DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
  const heapU8 = new Uint8Array(wasmMemory.buffer);
  const heap32 = new Int32Array(wasmMemory.buffer);
  const heapU32 = new Uint32Array(wasmMemory.buffer);
  heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  const TABLE_SIZE = 6;
  const MAX_TABLE_SIZE = 6; // eslint-disable-next-line functional/no-let, init-declarations

  let getErrNoLocation;
  /*
   * note: A number of methods below are excluded from test coverage. They are
   * a) not part of the regular usage of this library (should only be evaluated
   * if the consumer mis-implements the library and exist only to make
   * debugging easier) and B) already tested adequately in Emscripten, from
   * which this section is extracted.
   */

  const env = {
    DYNAMICTOP_PTR,
    STACKTOP,
    ___setErrNo:
    /* istanbul ignore next */
    value => {
      if (getErrNoLocation !== undefined) {
        heap32[getErrNoLocation() >> 2] = value;
      }

      return value;
    },
    _abort:
    /* istanbul ignore next */
    (err = 'Secp256k1 Error') => {
      throw new Error(err);
    },
    // eslint-disable-next-line camelcase
    _emscripten_memcpy_big:
    /* istanbul ignore next */
    (dest, src, num) => {
      heapU8.set(heapU8.subarray(src, src + num), dest);
      return dest;
    },
    abort:
    /* istanbul ignore next */
    (err = 'Secp256k1 Error') => {
      throw new Error(err);
    },
    abortOnCannotGrowMemory:
    /* istanbul ignore next */
    () => {
      throw new Error('Secp256k1 Error: abortOnCannotGrowMemory was called.');
    },
    enlargeMemory:
    /* istanbul ignore next */
    () => {
      throw new Error('Secp256k1 Error: enlargeMemory was called.');
    },
    getTotalMemory: () => TOTAL_MEMORY
  };
  const info = {
    env: { ...env,
      memory: wasmMemory,
      memoryBase: STATIC_BASE,
      table: new WebAssembly.Table({
        element: 'anyfunc',
        initial: TABLE_SIZE,
        maximum: MAX_TABLE_SIZE
      }),
      tableBase: 0
    },
    global: {
      Infinity,
      NaN
    }
  };
  return WebAssembly.instantiate(webassemblyBytes, info).then(result => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getErrNoLocation = result.instance.exports.___errno_location;
    return wrapSecp256k1Wasm(result.instance, heapU8, heapU32);
  });
};
/* eslint-enable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */

const getEmbeddedSecp256k1Binary = () => base64ToBin(secp256k1Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of `instantiateSecp256k1Bytes`
 * which does not require the consumer to provide the secp256k1 binary buffer.
 */

const instantiateSecp256k1Wasm = async () => instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary());
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/sha1/sha1.base64.js
/**
 * @hidden
 */
// prettier-ignore
const sha1Base64Bytes = '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cjYCBEG8FCAANgIAQbQUIAI2AgAgACACaiACNgIADAQLIAMQJQwBC0GkEUGkESgCAEF+IAFBA3Z3cTYCAAsgBCACaiECIAMgBGohAwsgAyADKAIEQX5xNgIEIAAgAkEBcjYCBCAAIAJqIAI2AgACfwJAIAJB/wFNBEAgAkEDdiIBQQN0QawRaiECQaQRKAIAIgNBASABQR9xdCIBcUUNASACQQhqIQMgAigCCAwCCyAAIAIQJgwCC0GkESADIAFyNgIAIAJBCGohAyACCyEBIAMgADYCACABIAA2AgwgACACNgIMIAAgATYCCAsgBUEIag8LQbgUIAAgAmsiATYCAEHAFEHAFCgCACIAIAJqIgM2AgAgAyABQQFyNgIEIAAgAkEDcjYCBCAAQQhqC6UBAQJ/QQIhBQJAAkACQAJAAkAgACgCBCIGIAFrIAJPDQAgASACaiICIAFJIQECQCAEBEBBACEFIAENAiAGQQF0IgEgAiACIAFJGyECDAELQQAhBSABDQELIAJBAEgNACAGRQ0BIAAoAgAgAhATIgFFDQIMAwsgBQ8LIAIQBCIBDQELIAMNAQsgAQRAIAAgATYCACAAQQRqIAI2AgBBAg8LQQEPCwALCABB5BUQBwALZgIBfwN+IwBBMGsiASQAIAApAhAhAiAAKQIIIQMgACkCACEEIAFBFGpBADYCACABIAQ3AxggAUIBNwIEIAFBrA42AhAgASABQRhqNgIAIAEgAzcDICABIAI3AyggASABQSBqECIAC7gBAQF/IwBB4AFrIgMkACADQThqQcwIKAIANgIAIANBMGpBxAgpAgA3AwAgA0IANwMgIANBvAgpAgA3AyggA0E8akEAQcQAEC4aIANBIGogASACEAkgA0GAAWogA0EgakHgABAsGiADQQhqIANBgAFqEAogA0EgaiADQQhqQRQQAyADQYgBaiADQShqKAIANgIAIAMgAykDIDcDgAEgAyADQYABahALIAAgAykDADcCACADQeABaiQAC5cDAQR/IwBBQGoiAyQAIAAgACkDACACrXw3AwAgAyAAQQhqNgIoIAMgA0EoajYCLAJAAkACQAJAAkACQCAAKAIcIgUEQEHAACAFayIEIAJNDQEgA0EYaiAFIAUgAmoiBCAAQSBqEBUgAygCHCACRw0FIAMoAhggASACECwaDAMLIAIhBAwB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QcgAaiICKQMANwMAIAEgASkDQDcDcCABIAw2AoQBIAEgFCAZQR53ajYCgAEgASAPNgKIASABIAY2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQAQHiABKAJsIRYgASkCZCEfIAEoAiAhDSABKAIsIRAgASgCKCEKIAEoAiQhESABIAEoAmAiDjYCcCABIB83AnQgASAWNgJ8IAEgETYChAEgASAKNgKIASABIBA2AowBIAEgDSABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBABAeIAIgAUHoAGoiFikDADcDACABIAEpA2A3A0AgASgCPCEHIAEoAjghCCABKAIwIRIgASgCNCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIBIgDkEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEAEB4gASgCbCEOIAEpAmQhHyABKAJgIRcgASARIAQgC3NzNgKEASABIA0gBSADc3M2AoABIAEgCiAUIAVzczYCiAEgASAQIAwgBHNzNgKMASABQdAAaiABQYABaiAJIAggBxAfIAEgFzYCcCABIB83AnQgASAONgJ8IAEgASgCVCIDNgKEASABIAEoAlgiCzYCiAEgASABKAJcIg42AowBIAEgASgCQEEedyABKAJQIhVqNgKAASABQeAAaiABQfAAaiABQYABakEAEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgBiAMc3M2AoQBIAEgEiAPIBRzczYCgAEgASAIIA0gD3NzNgKIASABIAcgESAGc3M2AowBIAFB8ABqIAFBgAFqIAMgCyAOEB8gASgCfCEEIAEoAnghBSABKAJwIQ8gASgCdCEGIBMgAikDADcDACABIAEpA0A3A3AgASAGNgKEASABIA8gF0Eed2o2AoABIAEgBTYCiAEgASAENgKMASABQeAAaiABQfAAaiABQYABakEBEB4gASgCbCEMIAEpAmQhHyABKAJgIRcgASADIBAgEXNzNgKEASABIBUgCiANc3M2AoABIAEgCyASIApzczYCiAEgASAOIAkgEHNzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnAhFCABKAJ8IQ0gASgCeCEQIAEoAnQhCiABIBc2AnAgASAfNwJ0IAEgDDYCfCABIAo2AoQBIAEgEDYCiAEgASANNgKMASABIBQgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgBiAHIAlzczYChAEgASAPIAggEnNzNgKAASABIAUgFSAIc3M2AogBIAEgBCADIAdzczYCjAEgAUHwAGogAUGAAWogCiAQIA0QHyABKAJ8IQcgASgCeCEIIAEoAnAhDCABKAJ0IQkgEyACKQMANwMAIAEgASkDQDcDcCABIAk2AoQBIAEgDCAXQR53ajYCgAEgASAINgKIASABIAc2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRcgASkCZCEfIAEoAmAhGCABIAogDiADc3M2AoQBIAEgFCALIBVzczYCgAEgASAQIA8gC3NzNgKIASABIA0gBiAOc3M2AowBIAFB8ABqIAFBgAFqIAkgCCAHEB8gASgCcCELIAEoAnwhESABKAJ4IRIgASgCdCEDIAEgGDYCcCABIB83AnQgASAXNgJ8IAEgAzYChAEgASASNgKIASABIBE2AowBIAEgCyABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBARAeIAIgFikDADcDACABIAEpA2A3A0AgASAJIAQgBnNzNgKEASABIAwgBSAPc3M2AoABIAEgCCAUIAVzczYCiAEgASAHIAogBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIBMgAikDADcDACABIAEpA0A3A3AgASABKAJUIg42AoQBIAEgASgCWCIPNgKIASABIAEoAlwiFTYCjAEgASABKAJQIhcgGEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRogASkCZCEfIAEoAmAhGCABIAMgDSAKc3M2AoQBIAEgCyAQIBRzczYCgAEgASASIAwgEHNzNgKIASABIBEgCSANc3M2AowBIAFB8ABqIAFBgAFqIA4gDyAVEB8gASgCcCEUIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgGDYCcCABIB83AnQgASAaNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgFCABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAIgFikDADcDACABIAEpA2A3A0AgASAOIAcgCXNzNgKEASABIBcgCCAMc3M2AoABIAEgDyALIAhzczYCiAEgASAVIAMgB3NzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnwhByABKAJ4IQggASgCcCEMIAEoAnQhCSATIAIpAwA3AwAgASABKQNANwNwIAEgCTYChAEgASAMIBhBHndqNgKAASABIAg2AogBIAEgBzYCjAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAEoAmwhGiABKQJkIR8gASgCYCEYIAEgBiARIANzczYChAEgASAUIBIgC3NzNgKAASABIAUgFyASc3M2AogBIAEgBCAOIBFzczYCjAEgAUHwAGogAUGAAWogCSAIIAcQHyABKAJwIQsgASgCfCENIAEoAnghECABKAJ0IQogASAYNgJwIAEgHzcCdCABIBo2AnwgASAKNgKEASABIBA2AogBIAEgDTYCjAEgASALIAEoAkBBHndqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgFSAOc3M2AoQBIAEgDCAPIBdzczYCgAEgASAIIBQgD3NzNgKIASABIAcgBiAVc3M2AowBIAFB8ABqIAFBgAFqIAogECANEB8gASgCfCERIAEoAnghEiABKAJwIQ4gASgCdCEDIBMgAikDADcDACABIAEpA0A3A3AgASADNgKEASABIA4gGEEed2o2AoABIAEgEjYCiAEgASARNgKMASABQeAAaiABQfAAaiABQYABakECEB4gASgCbCEPIAEpAmQhHyABKAJgIRUgASAKIAQgBnNzNgKEASABIAsgBSAUc3M2AoABIAEgECAMIAVzczYCiAEgASANIAkgBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIAEgFTYCcCABIB83AnQgASAPNgJ8IAEgASgCVCIENgKEASABIAEoAlgiBTYCiAEgASABKAJcIgY2AowBIAEgASgCQEEedyABKAJQIhRqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAMgByAJc3M2AoQBIAEgDiAIIAxzczYCgAEgASASIAsgCHNzNgKIASABIBEgCiAHc3M2AowBIAFB8ABqIAFBgAFqIAQgBSAGEB8gASgCfCEHIAEoAnghCCABKAJwIQ8gASgCdCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIA8gFUEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEDEB4gASgCbCEVIAEpAmQhHyABKAJgIQwgASAEIA0gCnNzNgKEASABIBQgECALc3M2AoABIAEgBSAOIBBzczYCiAEgASAGIAMgDXNzNgKMASABQfAAaiABQYABaiAJIAggBxAfIAEoAnAhECABKAJ8IQogASgCeCELIAEoAnQhDSABIAw2AnAgASAfNwJ0IAEgFTYCfCABIA02AoQBIAEgCzYCiAEgASAKNgKMASABIBAgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgCSARIANzczYChAEgASAPIBIgDnNzNgKAASABIAggFCASc3M2AogBIAEgByAEIBFzczYCjAEgAUHwAGogAUGAAWogDSALIAoQHyABKAJ8IREgASgCeCESIAEoAnAhDiABKAJ0IQMgEyACKQMANwMAIAEgASkDQDcDcCABIAM2AoQBIAEgDiAMQR53ajYCgAEgASASNgKIASABIBE2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiABKAJsIRUgASkCZCEfIAEoAmAhDCABIA0gBiAEc3M2AoQBIAEgECAFIBRzczYCgAEgASALIA8gBXNzNgKIASABIAogCSAGc3M2AowBIAFB8ABqIAFBgAFqIAMgEiAREB8gASgCcCEKIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgDDYCcCABIB83AnQgASAVNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgCiABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAeIAIgFikDADcDACABIAEpA2A3A0AgASADIAcgCXNzNgKEASABIA4gCCAPc3M2AoABIAEgEiAQIAhzczYCiAEgASARIA0gB3NzNgKMASABQdAAaiABQYABaiAGIAUgBBAfIBMgAikDADcDACABIAEpA0A3A3AgASABKQJUNwKEASABIAEoAlw2AowBIAEgASgCUCAMQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAe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DSAKIABBDHZBD3FB4AFyOgAMQQMMAQsgCiAAQRJ2QfABcjoADCAKIABBP3FBgAFyOgAPIAogAEEMdkE/cUGAAXI6AA0gCiAAQQZ2QT9xQYABcjoADkEECyEIIAEoAhghAkF/IQAgAUEcaigCACIJQQxqIQECQAJAAkADQCAAQQFqIgAgBE8NASACIApBDGogCCABKAIAEQUARQ0ACwwBCyACIAcgBiAJQQxqKAIAIgERBQANAEF/IQADQCAAQQFqIgAgA08NAiACIApBDGogCCABEQUARQ0ACwtBAQwBC0EACyEAIApBEGokACAAC0YCAX8BfiMAQSBrIgIkACABKQIAIQMgAkEUaiABKQIINwIAIAJBlBY2AgQgAkGsDjYCACACIAA2AgggAiADNwIMIAIQJAALUAACQAJAQZARKAIAQQFGBEBBlBFBlBEoAgBBAWoiADYCACAAQQNJDQEMAgtBkBFCgYCAgBA3AwALQZwRKAIAIgBBf0wNAEGcESAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQfwVEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECMAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEG0E2oiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQagRQagRKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEG0E2ohAwJAAkACQEGoESgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIM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LTFlY2M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMy4zL3NyYy9saWIucnNkZXN0aW5hdGlvbiBhbmQgc291cmNlIHNsaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc2hhLTEtMC43LjAvc3JjL3V0aWxzLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogdW5rbm93biBpY29zYXJvdW5kIGluZGV4AEHwCwvSBAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB7BQLnQIWBAAAJAAAAC8IAAATAAAASAIAAAkAAADQBAAAUwAAAEsAAAARAAAAUAQAACAAAABwBAAAWgAAAB8AAAAFAAAAIwUAADQAAABfBwAAFAAAAG0GAAAJAAAAzwUAABgAAAClBQAAKgAAAFcFAABOAAAAQgAAAA4AAAAUBgAAEQAAAC8IAAATAAAA8gIAAAUAAAAlBgAAKwAAAFAGAAARAAAAWQEAABUAAAADAAAAAAAAAAEAAAAEAAAALQcAACAAAABNBwAAEgAAALwHAAAGAAAAwgcAACIAAABfBwAAFAAAAK0HAAAFAAAA5AcAABYAAAD6BwAADQAAAF8HAAAUAAAAswcAAAUAAAAHCAAAKAAAAC8IAAATAAAA9QEAAB4ADAdsaW5raW5nAwKMDw==';
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/sha256/sha256.base64.js
/**
 * @hidden
 */
// prettier-ignore
const sha256Base64Bytes = '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IAJHDQUgAygCGCABIAIQKxoMAwsgAiEEDAELIANBMGogASACIAQQFiADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQQxqIgYgACgCCBAXIAIgAygCJEcNBCADKAIgIAUgAhArGiAAQQhqQQA2AgAgA0EsaiAGEBgLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAWIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAZIANBLGogAygCCBAYDAALAAsgA0EQaiAAQQxqIAQQGiADKAIUIARHDQEgAygCECABIAQQKxoLIABBCGogBDYCACADQUBrJAAPC0GEFBAHAAtBhBQQBwALQYQUEAcAC98EAgN/AX4jAEHQAGsiAiQAIAIgAUHMAGo2AiQgASkDACEFIAEoAgghBCACIAJBJGo2AigCQCAEQT9NBEAgAUEMaiIDIARqQYABOgAAIAEgASgCCEEBaiIENgIIIAJBGGogAyAEEBcgAigCGEEAIAIoAhwQLRpBwAAgASgCCGtBB00EQCACQShqIAMQGCACQRBqIAMgAUEIaigCABAaIAIoAhBBACACKAIUEC0aCyACQQhqIANBOBAXIAIoAgxBCEcNASACKAIIIAVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAJBKGogAxAYIAFBCGpBADYCACACQQA2AiggAkEoakEEciEEQQAhAwJAA0AgA0EgRg0BIAQgA2pBADoAACACIAIoAihBAWo2AiggA0EBaiEDDAALAAsgAkFAayABQeQAaikAADcDACACQThqIAFB3ABqKQAANwMAIAJBMGogAUHUAGopAAA3AwAgAiABKQBMNwMoQQAhAwJAA0AgA0EgRg0BIAJBKGogA2oiBCAEKAIAIgRBGHQgBEEIdEGAgPwHcXIgBEEIdkGA/gNxIARBGHZycjYCACADQQRqIQMMAAsACyAAIAIpAyg3AAAgAEEYaiACQUBrKQMANwAAIABBEGogAkE4aikDADcAACAAQQhqIAJBMGopAwA3AAAgAkHQAGokAA8LQdwTIARBwAAQ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KAJsIQggASAPNgJkIAEgDjYCYCABIBM2AmggASAYNgJsIAEgAjYCdCABIBc2AnAgASAQNgJ4IAEgDDYCfCABQdAAaiABQeAAaiABQfAAaiAHQevZwaJ6aiAIQfr/+4V5ahAeIAEoAlwhByABKAJYIQggASgCUCEKIAEoAlQhESABIAI2AmQgASAXNgJgIAEgEDYCaCABIAw2AmwgASARNgJ0IAEgCjYCcCABIAg2AnggASAHNgJ8IAFB0ABqIAFB4ABqIAFB8ABqIA1B8vHFs3xqIBlB98fm93tqEB4gASgCXCENIAEoAlghGCABKAJQIRMgACAeIAEoAlRqNgIEIAAgEyAdajYCACAAIAogIWo2AgggACARICJqNgIMIAAgGCAcajYCECAAIA0gG2o2AhQgACAIICBqNgIYIAAgByAfajYCHCABQYABaiQAC30BAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQSxqQQE2AgAgAkEUakECNgIAIAJBHGpBAjYCACACQQE2AiQgAkGMFTYCCCACQQI2AgwgAkHMDTYCECACIAI2AiAgAiACQQRqNgIoIAIgAkEgajYCGCACQQhqQZwVECgAC3wBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQSxqQQE2AgAgA0EUakECNgIAIANBHGpBAjYCACADQQE2AiQgA0HcFDYCCCADQQI2AgwgA0HMDTYCECADIANBBGo2AiAgAyADNgIoIAMgA0EgajYCGCADQQhqIAAQKAAL1gEBBn8gACABKAIAIgggAigCBCIHcyACKAIAIgVxIAggB3FzIAVBHncgBUETd3MgBUEKd3NqIAIoAggiBkEadyAGQRV3cyAGQQd3cyAEaiABKAIMaiABKAIIIgQgAigCDCIJcyAGcSAEc2oiCmoiAjYCBCAAIAogASgCBGoiATYCDCAAIAJBHncgAkETd3MgAkEKd3MgAiAHIAVzcSAHIAVxc2ogBCADaiAJIAEgCSAGc3FzaiABQRp3IAFBFXdzIAFBB3dzaiIFajYCACAAIAUgCGo2AggLeAAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgAiAmo2AgAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgQiAmo2AgQgACACQRl3IAJBA3ZzIAJBDndzIAEoAggiAmo2AgggACACQRl3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';
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/sha512/sha512.base64.js
/**
 * @hidden
 */
// prettier-ignore
const sha512Base64Bytes = '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AjYCACAAIAJBAXI2AgQMBQsgAEGsEygCACACaiICQQFyNgIEQbQTIAA2AgBBrBMgAjYCACAAIAJqIAI2AgAMBAsgAxAiDAELQZwQQZwQKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RBpBBqIQJBnBAoAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAjDAILQZwQIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBsBMgACACayIBNgIAQbgTQbgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEG8FBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUGkDTYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJwALsgEBAn8jAEGABGsiAyQAIANB2ABqIgRCADcDACADQgA3A1AgA0GgAWpBAEGEARAsGiADQeAAakHICkHAABAqGiADQdAAaiABIAIQCSADQagCaiADQdAAakHYARAqGiADQRBqIANBqAJqEAogA0HQAGogA0EQakHAABADIANBsAJqIAQoAgA2AgAgAyADKQNQNwOoAiADQQhqIANBqAJqEAsgACADKQMINwIAIANBgARqJAALuwMCBH8CfiMAQUBqIgMkACAAIAApAwgiByACrUIDhnwiCDcDCCAIIAdUBEAgACAAKQMAQgF8NwMACyADIABBEGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAlAiBQRAQYABIAVrIgQg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sBMoAgAgAGoiADYCACABIABBAXI2AgQgAUG0EygCAEYEQEGsE0EANgIAQbQTQQA2AgALQdQTKAIAIABPDQcCQCAAQSlJDQBBxBMhAANAIAAoAgAiAiABTQRAIAIgACgCBGogAUsNAgsgACgCCCIADQALC0EAIQFBzBMoAgAiAEUNBANAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMBQtBtBMgATYCAEGsE0GsEygCACAAaiIANgIADAcLIAIQIgwBC0GcEEGcECgCAEF+IANBA3Z3cTYCAAsgASAAQQFyNgIEIAEgAGogADYCACABQbQTKAIARw0CQawTIAA2AgAPC0H/HwshAUHUE0F/NgIAQdwTIAE2AgAPC0HcEwJ/AkACfwJAIABB/wFNBEAgAEEDdiICQQN0QaQQaiEAQZwQKAIAIgNBASACQR9xdCICcUUNASAAQQhqIQMgACgCCAwCCyABIAAQI0HcE0HcEygCAEF/aiIBNgIAIAENBEHMEygCACIARQ0CQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMAwtBnBAgAyACcjYCACAAQQhqIQMgAAshAiADIAE2AgAgAiABNgIMIAEgADYCDCABIAI2AggPC0H/HwsiATYCAAsPCyABIABBAXI2AgQgASAAaiAANgIACzkAAkAgAiABTwRAIAJBgQFPDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAkGAARACAAtNAgF/An4jAEEQayIEJAAgBEEIakEAIAMgASACEBkgBCkDCCEFIAQgAyACIAEgAhAZIAQpAwAhBiAAIAU3AgAgACAGNwIIIARBEGokAAssAQF/IwBBEGsiAyQAIANBCGogAkGAASABEBUgACADKQMINwIAIANBEGokAAsOACAAKAIAKAIAIAEQGws3AAJAIAIgAU8EQCAEIAJJDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAiAEEAIACysBAX8jAEEQayIDJAAgA0EIakEAIAIgARAVIAAgAykDCDcCACADQRBqJAALqioCAn8ifiMAQYAPayICJAAgAkGADmogAUGAARAqGkEAIQECQANAIAFBgAFGDQEgAkGADmogAWoiAyADKQMAIhxCOIYgHEIohkKAgICAgIDA/wCD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c2VydGlvbiBmYWlsZWQ6IDggPT0gZHN0LmxlbigpL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnl0ZS10b29scy0wLjIuMC9zcmMvd3JpdGVfc2luZ2xlLnJzAEHwCQvKBS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjMuMy9zcmMvbGliLnJzAAAAAAAIybzzZ+YJajunyoSFrme7K/iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBbAAAAAABjYXBhY2l0eSBvdmVyZmxvd2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVsaWJjb3JlL29wdGlvbi5yczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB5BML/QEWBAAAJAAAAKcHAAATAAAASAIAAAkAAAA6BAAANAAAANcGAAAUAAAAbQYAAAkAAADwBAAAUwAAAEsAAAARAAAAbgQAACAAAACOBAAAWgAAAB8AAAAFAAAAjQUAABEAAACnBwAAEwAAAPICAAAFAAAAngUAACsAAADJBQAAEQAAAFkBAAAVAAAAAgAAAAAAAAABAAAAAwAAAKUGAAAgAAAAxQYAABIAAAA0BwAABgAAADoHAAAiAAAA1wYAABQAAACtBwAABQAAAFwHAAAWAAAAcgcAAA0AAADXBgAAFAAAALMHAAAFAAAAfwcAACgAAACnBwAAEwAAAPUBAAAeAAwHbGlua2luZwMC5A0=';
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/bin/bin.js






// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/secp256k1.js
/* eslint-disable functional/no-conditional-statement, functional/no-expression-statement, functional/no-throw-statement */

/**
 * @param secp256k1Wasm a Secp256k1Wasm object
 * @param randomSeed a 32-byte random seed used to randomize the context after
 * creation
 */

const secp256k1_wrapSecp256k1Wasm = (secp256k1Wasm, randomSeed) => {
  /**
   * Currently, this wrapper creates a context with both SIGN and VERIFY
   * capabilities. For better initialization performance, consumers could
   * re-implement a wrapper with only the capabilities they require.
   */
  const contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
  /**
   * Since all of these methods are single-threaded and synchronous, we can
   * reuse allocated WebAssembly memory for each method without worrying about
   * calls interfering with each other. Likewise, these spaces never need to be
   * `free`d, since we will continue using them until this entire object (and
   * with it, the entire WebAssembly instance) is garbage collected.
   *
   * If malicious javascript gained access to this object, it should be
   * considered a critical vulnerability in the consumer. However, as a best
   * practice, we zero out private keys below when we're finished with them.
   */

  const sigScratch = secp256k1Wasm.malloc(72
  /* maxECDSASig */
  );
  const publicKeyScratch = secp256k1Wasm.malloc(65
  /* maxPublicKey */
  );
  const messageHashScratch = secp256k1Wasm.malloc(32
  /* messageHash */
  );
  const internalPublicKeyPtr = secp256k1Wasm.malloc(64
  /* internalPublicKey */
  );
  const internalSigPtr = secp256k1Wasm.malloc(64
  /* internalSig */
  );
  const schnorrSigPtr = secp256k1Wasm.malloc(64
  /* schnorrSig */
  );
  const privateKeyPtr = secp256k1Wasm.malloc(32
  /* privateKey */
  );
  const internalRSigPtr = secp256k1Wasm.malloc(65
  /* recoverableSig */
  ); // eslint-disable-next-line @typescript-eslint/no-magic-numbers

  const recoveryNumPtr = secp256k1Wasm.malloc(4); // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers

  const recoveryNumPtrView32 = recoveryNumPtr >> 2;

  const getRecoveryNumPtr = () => secp256k1Wasm.heapU32[recoveryNumPtrView32]; // eslint-disable-next-line @typescript-eslint/no-magic-numbers


  const lengthPtr = secp256k1Wasm.malloc(4); // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers

  const lengthPtrView32 = lengthPtr >> 2;

  const parsePublicKey = publicKey => {
    secp256k1Wasm.heapU8.set(publicKey, publicKeyScratch);
    return secp256k1Wasm.pubkeyParse(contextPtr, internalPublicKeyPtr, publicKeyScratch, // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    publicKey.length) === 1;
  };

  const setLengthPtr = value => {
    secp256k1Wasm.heapU32.set([value], lengthPtrView32);
  };

  const getLengthPtr = () => secp256k1Wasm.heapU32[lengthPtrView32];

  const serializePublicKey = (length, flag) => {
    setLengthPtr(length);
    secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
    return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
  };

  const getSerializedPublicKey = compressed => compressed ? serializePublicKey(33
  /* compressedPublicKey */
  , CompressionFlag.COMPRESSED) : serializePublicKey(65
  /* uncompressedPublicKey */
  , CompressionFlag.UNCOMPRESSED);

  const convertPublicKey = compressed => publicKey => {
    if (!parsePublicKey(publicKey)) {
      throw new Error('Failed to parse public key.');
    }

    return getSerializedPublicKey(compressed);
  };

  const parseSignature = (signature, DER) => {
    secp256k1Wasm.heapU8.set(signature, sigScratch);
    return DER ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1 : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
  };

  const parseOrThrow = (signature, DER) => {
    if (!parseSignature(signature, DER)) {
      throw new Error('Failed to parse signature.');
    }
  };

  const getCompactSig = () => {
    secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, 64
    /* compactSig */
    ).slice();
  };

  const getDERSig = () => {
    setLengthPtr(72
    /* maxECDSASig */
    );
    secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
  };

  const convertSignature = wasDER => signature => {
    parseOrThrow(signature, wasDER);
    return wasDER ? getCompactSig() : getDERSig();
  };

  const fillPrivateKeyPtr = privateKey => {
    secp256k1Wasm.heapU8.set(privateKey, privateKeyPtr);
  };

  const zeroOutPtr = (pointer, bytes) => {
    secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
  };

  const zeroOutPrivateKeyPtr = () => {
    zeroOutPtr(privateKeyPtr, 32
    /* privateKey */
    );
  };

  const withPrivateKey = (privateKey, instructions) => {
    fillPrivateKeyPtr(privateKey);
    const ret = instructions();
    zeroOutPrivateKeyPtr();
    return ret;
  };

  const derivePublicKey = compressed => privateKey => {
    const invalid = withPrivateKey(privateKey, () => secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1);

    if (invalid) {
      throw new Error('Cannot derive public key from invalid private key.');
    }

    return getSerializedPublicKey(compressed);
  };

  const fillMessageHashScratch = messageHash => {
    secp256k1Wasm.heapU8.set(messageHash, messageHashScratch);
  };

  const normalizeSignature = () => {
    secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
  };

  const modifySignature = (DER, normalize) => signature => {
    parseOrThrow(signature, DER);

    if (normalize) {
      normalizeSignature();
    } else {
      secp256k1Wasm.signatureMalleate(contextPtr, internalSigPtr, internalSigPtr);
    }

    return DER ? getDERSig() : getCompactSig();
  };

  const parseAndNormalizeSignature = (signature, DER, normalize) => {
    const ret = parseSignature(signature, DER);

    if (normalize) {
      normalizeSignature();
    }

    return ret;
  };

  const signMessageHash = DER => (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr) !== 1;

      if (failed) {
        throw new Error('Failed to sign message hash. The private key is not valid.');
      }

      if (DER) {
        setLengthPtr(72
        /* maxECDSASig */
        );
        secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
      }

      secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
      return secp256k1Wasm.readHeapU8(sigScratch, 64
      /* compactSig */
      ).slice();
    });
  };

  const signMessageHashSchnorr = () => (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;

      if (failed) {
        throw new Error('Failed to sign message hash. The private key is not valid.');
      }

      return secp256k1Wasm.readHeapU8(schnorrSigPtr, 64
      /* schnorrSig */
      ).slice();
    });
  };

  const verifyMessage = messageHash => {
    fillMessageHashScratch(messageHash);
    return secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };

  const verifySignature = (DER, normalize) => (signature, publicKey, messageHash) => parsePublicKey(publicKey) && parseAndNormalizeSignature(signature, DER, normalize) && verifyMessage(messageHash);

  const verifyMessageSchnorr = (messageHash, signature) => {
    fillMessageHashScratch(messageHash);
    secp256k1Wasm.heapU8.set(signature, schnorrSigPtr);
    return secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };

  const verifySignatureSchnorr = () => (signature, publicKey, messageHash) => parsePublicKey(publicKey) ? verifyMessageSchnorr(messageHash, signature) : false;

  const signMessageHashRecoverable = (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
        throw new Error('Failed to sign message hash. The private key is not valid.');
      }

      secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
      return {
        recoveryId: getRecoveryNumPtr(),
        signature: secp256k1Wasm.readHeapU8(sigScratch, 64
        /* compactSig */
        ).slice()
      };
    });
  };

  const recoverPublicKey = compressed => (signature, recoveryId, messageHash) => {
    fillMessageHashScratch(messageHash);
    secp256k1Wasm.heapU8.set(signature, sigScratch);

    if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
      throw new Error('Failed to recover public key. Could not parse signature.');
    }

    if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
      throw new Error('Failed to recover public key. The compact signature, recovery, or message hash is invalid.');
    }

    return getSerializedPublicKey(compressed);
  };

  const addTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        throw new Error('Private key is invalid or adding failed.');
      }

      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32
      /* privateKey */
      ).slice();
    });
  };

  const mulTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        throw new Error('Private key is invalid or multiplying failed.');
      }

      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32
      /* privateKey */
      ).slice();
    });
  };

  const addTweakPublicKey = compressed => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error('Failed to parse public key.');
    }

    fillMessageHashScratch(tweakValue);

    if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      throw new Error('Adding failed');
    }

    return getSerializedPublicKey(compressed);
  };

  const mulTweakPublicKey = compressed => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error('Failed to parse public key.');
    }

    fillMessageHashScratch(tweakValue);

    if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      throw new Error('Multiplying failed');
    }

    return getSerializedPublicKey(compressed);
  };
  /**
   * The value of this precaution is debatable, especially in the context of
   * javascript and WebAssembly.
   *
   * In the secp256k1 C library, context randomization is an additional layer of
   * security from side-channel attacks which attempt to extract private key
   * information by analyzing things like a CPU's emitted radio frequencies or
   * power usage.
   *
   * In this library, these attacks seem even less likely, since the "platform"
   * on which this code will be executed (e.g. V8) is likely to obscure any
   * such signals.
   *
   * Still, out of an abundance of caution (and because no one has produced a
   * definitive proof indicating that this is not helpful), this library exposes
   * the ability to randomize the context like the C library. Depending on the
   * intended application, consumers can decide whether or not to randomize.
   */


  if (randomSeed !== undefined) {
    const randomSeedPtr = messageHashScratch;
    secp256k1Wasm.heapU8.set(randomSeed, randomSeedPtr);
    secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
    zeroOutPtr(randomSeedPtr, 32
    /* randomSeed */
    );
  }

  return {
    addTweakPrivateKey,
    addTweakPublicKeyCompressed: addTweakPublicKey(true),
    addTweakPublicKeyUncompressed: addTweakPublicKey(false),
    compressPublicKey: convertPublicKey(true),
    derivePublicKeyCompressed: derivePublicKey(true),
    derivePublicKeyUncompressed: derivePublicKey(false),
    malleateSignatureCompact: modifySignature(false, false),
    malleateSignatureDER: modifySignature(true, false),
    mulTweakPrivateKey,
    mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
    mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
    normalizeSignatureCompact: modifySignature(false, true),
    normalizeSignatureDER: modifySignature(true, true),
    recoverPublicKeyCompressed: recoverPublicKey(true),
    recoverPublicKeyUncompressed: recoverPublicKey(false),
    signMessageHashCompact: signMessageHash(false),
    signMessageHashDER: signMessageHash(true),
    signMessageHashRecoverableCompact: signMessageHashRecoverable,
    signMessageHashSchnorr: signMessageHashSchnorr(),
    signatureCompactToDER: convertSignature(false),
    signatureDERToCompact: convertSignature(true),
    uncompressPublicKey: convertPublicKey(false),
    validatePrivateKey: privateKey => withPrivateKey(privateKey, () => secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1),
    verifySignatureCompact: verifySignature(false, true),
    verifySignatureCompactLowS: verifySignature(false, false),
    verifySignatureDER: verifySignature(true, true),
    verifySignatureDERLowS: verifySignature(true, false),
    verifySignatureSchnorr: verifySignatureSchnorr()
  };
};
/**
 * This method is like `instantiateSecp256k1`, but requires the consumer to
 * `Window.fetch` or `fs.readFile` the `secp256k1.wasm` binary and provide it to
 * this method as `webassemblyBytes`. This skips a base64 decoding of an
 * embedded binary.
 *
 * ### Randomizing the Context with `randomSeed`
 * This method also accepts an optional, 32-byte `randomSeed`, which is passed
 * to the `contextRandomize` method in the underlying WebAssembly.
 *
 * The value of this precaution is debatable, especially in the context of
 * javascript and WebAssembly.
 *
 * In the secp256k1 C library, context randomization is an additional layer of
 * security from side-channel attacks which attempt to extract private key
 * information by analyzing things like a CPU's emitted radio frequencies or
 * power usage.
 *
 * In this library, these attacks seem even less likely, since the "platform"
 * on which this code will be executed (e.g. V8) is likely to obscure any
 * such signals.
 *
 * Still, out of an abundance of caution (and because no one has produced a
 * definitive proof indicating that this is not helpful), this library exposes
 * the ability to randomize the context like the C library. Depending on the
 * intended application, consumers can decide whether or not to randomize.
 *
 * @param webassemblyBytes an ArrayBuffer containing the bytes from bitcoin-ts'
 * `secp256k1.wasm` binary. Providing this buffer manually may be faster than
 * the internal base64 decode which happens in `instantiateSecp256k1`.
 * @param randomSeed a 32-byte random seed used to randomize the secp256k1
 * context after creation. See above for details.
 */


const instantiateSecp256k1Bytes = async (webassemblyBytes, randomSeed) => secp256k1_wrapSecp256k1Wasm((await instantiateSecp256k1WasmBytes(webassemblyBytes)), randomSeed);
/**
 * Create and wrap a Secp256k1 WebAssembly instance to expose a set of
 * purely-functional Secp256k1 methods. For slightly faster initialization, use
 * `instantiateSecp256k1Bytes`.
 *
 * TODO: cache resulting instance to return in all future calls
 *
 * @param randomSeed a 32-byte random seed used to randomize the secp256k1
 * context after creation. See the description in `instantiateSecp256k1Bytes`
 * for details.
 */

const instantiateSecp256k1 = async randomSeed => secp256k1_wrapSecp256k1Wasm((await instantiateSecp256k1Wasm()), randomSeed);
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/ripemd160.js


/**
 * The most performant way to instantiate ripemd160 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateRipemd160`.
 *
 * @param webassemblyBytes A buffer containing the ripemd160 binary.
 */

const instantiateRipemd160Bytes = async webassemblyBytes => {
  const wasm = await instantiateRustWasm(webassemblyBytes, './ripemd160', 'ripemd160', 'ripemd160_init', 'ripemd160_update', 'ripemd160_final');
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
const getEmbeddedRipemd160Binary = () => base64ToBin(ripemd160Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of `instantiateRipemd160Bytes`
 * which does not require the consumer to provide the ripemd160 binary buffer.
 */

const instantiateRipemd160 = async () => instantiateRipemd160Bytes(getEmbeddedRipemd160Binary());
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/sha1.js


/**
 * The most performant way to instantiate sha1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateSha1`.
 *
 * @param webassemblyBytes A buffer containing the sha1 binary.
 */

const instantiateSha1Bytes = async webassemblyBytes => {
  const wasm = await instantiateRustWasm(webassemblyBytes, './sha1', 'sha1', 'sha1_init', 'sha1_update', 'sha1_final');
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
const getEmbeddedSha1Binary = () => base64ToBin(sha1Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of `instantiateSha1Bytes`
 * which does not require the consumer to provide the sha1 binary buffer.
 */

const instantiateSha1 = async () => instantiateSha1Bytes(getEmbeddedSha1Binary());
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/sha256.js


/**
 * The most performant way to instantiate sha256 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateSha256`.
 *
 * @param webassemblyBytes A buffer containing the sha256 binary.
 */

const instantiateSha256Bytes = async webassemblyBytes => {
  const wasm = await instantiateRustWasm(webassemblyBytes, './sha256', 'sha256', 'sha256_init', 'sha256_update', 'sha256_final');
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
const getEmbeddedSha256Binary = () => base64ToBin(sha256Base64Bytes).buffer;
/**
 * An ultimately-portable (but possibly slower) version of
 * `instantiateSha256Bytes` which does not require the consumer to provide the
 * sha256 binary buffer.
 *
 * TODO: cache resulting instance to return in all future calls
 */

const instantiateSha256 = async () => instantiateSha256Bytes(getEmbeddedSha256Binary());
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/sha512.js


/**
 * The most performant way to instantiate sha512 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use `instantiateSha512`.
 *
 * @param webassemblyBytes A buffer containing the sha512 binary.
 */

const instantiateSha512Bytes = async webassemblyBytes => {
  const wasm = await instantiateRustWasm(webassemblyBytes, './sha512', 'sha512', 'sha512_init', 'sha512_update', 'sha512_final');
  return {
    final: wasm.final,
    hash: wasm.hash,
    init: wasm.init,
    update: wasm.update
  };
};
const getEmbeddedSha512Binary = () => base64ToBin(sha512Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of `instantiateSha512Bytes`
 * which does not require the consumer to provide the sha512 binary buffer.
 */

const instantiateSha512 = async () => instantiateSha512Bytes(getEmbeddedSha512Binary());
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/crypto/crypto.js





// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/btc/btc.js
var OpcodesBTC;

(function (OpcodesBTC) {
  OpcodesBTC[OpcodesBTC["OP_0"] = 0] = "OP_0";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA1"] = 76] = "OP_PUSHDATA1";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA2"] = 77] = "OP_PUSHDATA2";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA4"] = 78] = "OP_PUSHDATA4";
  OpcodesBTC[OpcodesBTC["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBTC[OpcodesBTC["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBTC[OpcodesBTC["OP_1"] = 81] = "OP_1";
  OpcodesBTC[OpcodesBTC["OP_2"] = 82] = "OP_2";
  OpcodesBTC[OpcodesBTC["OP_3"] = 83] = "OP_3";
  OpcodesBTC[OpcodesBTC["OP_4"] = 84] = "OP_4";
  OpcodesBTC[OpcodesBTC["OP_5"] = 85] = "OP_5";
  OpcodesBTC[OpcodesBTC["OP_6"] = 86] = "OP_6";
  OpcodesBTC[OpcodesBTC["OP_7"] = 87] = "OP_7";
  OpcodesBTC[OpcodesBTC["OP_8"] = 88] = "OP_8";
  OpcodesBTC[OpcodesBTC["OP_9"] = 89] = "OP_9";
  OpcodesBTC[OpcodesBTC["OP_10"] = 90] = "OP_10";
  OpcodesBTC[OpcodesBTC["OP_11"] = 91] = "OP_11";
  OpcodesBTC[OpcodesBTC["OP_12"] = 92] = "OP_12";
  OpcodesBTC[OpcodesBTC["OP_13"] = 93] = "OP_13";
  OpcodesBTC[OpcodesBTC["OP_14"] = 94] = "OP_14";
  OpcodesBTC[OpcodesBTC["OP_15"] = 95] = "OP_15";
  OpcodesBTC[OpcodesBTC["OP_16"] = 96] = "OP_16";
  OpcodesBTC[OpcodesBTC["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBTC[OpcodesBTC["OP_VER"] = 98] = "OP_VER";
  OpcodesBTC[OpcodesBTC["OP_IF"] = 99] = "OP_IF";
  OpcodesBTC[OpcodesBTC["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBTC[OpcodesBTC["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBTC[OpcodesBTC["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBTC[OpcodesBTC["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBTC[OpcodesBTC["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBTC[OpcodesBTC["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBTC[OpcodesBTC["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBTC[OpcodesBTC["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBTC[OpcodesBTC["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBTC[OpcodesBTC["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBTC[OpcodesBTC["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBTC[OpcodesBTC["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBTC[OpcodesBTC["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBTC[OpcodesBTC["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBTC[OpcodesBTC["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBTC[OpcodesBTC["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBTC[OpcodesBTC["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBTC[OpcodesBTC["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBTC[OpcodesBTC["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBTC[OpcodesBTC["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBTC[OpcodesBTC["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBTC[OpcodesBTC["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBTC[OpcodesBTC["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBTC[OpcodesBTC["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBTC[OpcodesBTC["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBTC[OpcodesBTC["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBTC[OpcodesBTC["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBTC[OpcodesBTC["OP_SUBSTR"] = 127] = "OP_SUBSTR";
  OpcodesBTC[OpcodesBTC["OP_LEFT"] = 128] = "OP_LEFT";
  OpcodesBTC[OpcodesBTC["OP_RIGHT"] = 129] = "OP_RIGHT";
  OpcodesBTC[OpcodesBTC["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBTC[OpcodesBTC["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBTC[OpcodesBTC["OP_AND"] = 132] = "OP_AND";
  OpcodesBTC[OpcodesBTC["OP_OR"] = 133] = "OP_OR";
  OpcodesBTC[OpcodesBTC["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBTC[OpcodesBTC["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBTC[OpcodesBTC["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBTC[OpcodesBTC["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBTC[OpcodesBTC["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBTC[OpcodesBTC["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBTC[OpcodesBTC["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBTC[OpcodesBTC["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBTC[OpcodesBTC["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBTC[OpcodesBTC["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBTC[OpcodesBTC["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBTC[OpcodesBTC["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBTC[OpcodesBTC["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBTC[OpcodesBTC["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBTC[OpcodesBTC["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBTC[OpcodesBTC["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBTC[OpcodesBTC["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBTC[OpcodesBTC["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBTC[OpcodesBTC["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBTC[OpcodesBTC["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBTC[OpcodesBTC["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBTC[OpcodesBTC["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBTC[OpcodesBTC["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBTC[OpcodesBTC["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBTC[OpcodesBTC["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBTC[OpcodesBTC["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBTC[OpcodesBTC["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBTC[OpcodesBTC["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBTC[OpcodesBTC["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBTC[OpcodesBTC["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBTC[OpcodesBTC["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBTC[OpcodesBTC["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBTC[OpcodesBTC["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBTC[OpcodesBTC["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBTC[OpcodesBTC["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBTC[OpcodesBTC["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBTC[OpcodesBTC["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBTC[OpcodesBTC["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBTC[OpcodesBTC["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBTC[OpcodesBTC["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBTC[OpcodesBTC["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBTC[OpcodesBTC["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBTC[OpcodesBTC["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBTC[OpcodesBTC["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBTC[OpcodesBTC["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBTC[OpcodesBTC["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBTC[OpcodesBTC["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  /**
   * Used internally in the C++ implementation.
   */

  OpcodesBTC[OpcodesBTC["OP_SMALLINTEGER"] = 250] = "OP_SMALLINTEGER";
  /**
   * Used internally in the C++ implementation.
   */

  OpcodesBTC[OpcodesBTC["OP_PUBKEYS"] = 251] = "OP_PUBKEYS";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  /**
   * Used internally in the C++ implementation.
   */

  OpcodesBTC[OpcodesBTC["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
  /**
   * Used internally in the C++ implementation.
   */

  OpcodesBTC[OpcodesBTC["OP_PUBKEY"] = 254] = "OP_PUBKEY";
  /**
   * Used internally in the C++ implementation.
   */

  OpcodesBTC[OpcodesBTC["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OpcodesBTC || (OpcodesBTC = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/virtual-machine.js

/**
 * Create an AuthenticationVirtualMachine to evaluate authentication programs
 * constructed from operations in the `instructionSet`.
 * @param instructionSet an `InstructionSet`
 */

const createAuthenticationVirtualMachine = instructionSet => {
  const availableOpcodes = 256;
  const operators = hex_range(availableOpcodes).map(codepoint => instructionSet.operations[codepoint] === undefined ? instructionSet.undefined : instructionSet.operations[codepoint]);

  const getCodepoint = state => state.instructions[state.ip];

  const after = state => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.ip += 1;
    return state;
  };

  const getOperation = state => operators[getCodepoint(state).opcode];

  const stateStepMutate = state => after(getOperation(state)(state));

  const stateContinue = instructionSet.continue;
  /**
   * When we get real tail call optimization, this can be replaced
   * with recursion.
   */

  const untilComplete = (state, stepFunction) => {
    // eslint-disable-next-line functional/no-loop-statement
    while (stateContinue(state)) {
      // eslint-disable-next-line functional/no-expression-statement, no-param-reassign
      state = stepFunction(state);
    }

    return state;
  };

  const clone = state => instructionSet.clone(state);

  const {
    verify
  } = instructionSet;

  const stateEvaluate = state => untilComplete(clone(state), stateStepMutate);

  const stateDebugStep = state => {
    const operator = getOperation(state);
    return after(operator(clone(state)));
  };

  const stateDebug = state => {
    const trace = []; // eslint-disable-next-line functional/no-expression-statement

    untilComplete(state, currentState => {
      const nextState = stateDebugStep(currentState); // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

      trace.push(nextState);
      return nextState;
    });
    return trace;
  };

  const stateStep = state => stateStepMutate(clone(state));

  const evaluate = program => instructionSet.evaluate(program, stateEvaluate);

  const debug = program => {
    const results = [];

    const proxyDebug = state => {
      var _debugResult;

      const debugResult = stateDebug(state); // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

      results.push(...debugResult);
      return (_debugResult = debugResult[debugResult.length - 1]) !== null && _debugResult !== void 0 ? _debugResult : state;
    };

    const finalResult = instructionSet.evaluate(program, proxyDebug);
    return [...results, finalResult];
  };

  return {
    debug,
    evaluate,
    stateContinue,
    stateDebug,
    stateEvaluate,
    stateStep,
    stateStepMutate,
    verify
  };
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/transaction.js

/**
 * @param bin the raw transaction from which to read the input
 * @param offset the offset at which the input begins
 */

const readTransactionInput = (bin, offset) => {
  const offsetAfterTxHash = offset + 32
  /* sha256Hash */
  ;
  const outpointTransactionHash = bin.slice(offset, offsetAfterTxHash).reverse();
  const offsetAfterOutpointIndex = offsetAfterTxHash + 4
  /* uint32 */
  ;
  const outpointIndex = binToNumberUint32LE(bin.subarray(offsetAfterTxHash, offsetAfterOutpointIndex));
  const {
    nextOffset: offsetAfterScriptLength,
    value: scriptLength
  } = readBitcoinVarInt(bin, offsetAfterOutpointIndex);
  const offsetAfterScript = offsetAfterScriptLength + Number(scriptLength);
  const unlockingBytecode = bin.slice(offsetAfterScriptLength, offsetAfterScript);
  const nextOffset = offsetAfterScript + 4
  /* uint32 */
  ;
  const sequenceNumber = binToNumberUint32LE(bin.subarray(offsetAfterScript, nextOffset));
  return {
    input: {
      outpointIndex,
      outpointTransactionHash,
      sequenceNumber,
      unlockingBytecode
    },
    nextOffset
  };
};
/**
 * Serialize a single input.
 * @param output the input to serialize
 */

const serializeInput = input => flattenBinArray([input.outpointTransactionHash.slice().reverse(), numberToBinUint32LE(input.outpointIndex), bigIntToBitcoinVarInt(BigInt(input.unlockingBytecode.length)), input.unlockingBytecode, numberToBinUint32LE(input.sequenceNumber)]);
/**
 * Serialize a set of inputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: input count> <serialized inputs>
 *
 * @param inputs the set of inputs to serialize
 */

const serializeInputs = inputs => flattenBinArray([bigIntToBitcoinVarInt(BigInt(inputs.length)), ...inputs.map(serializeInput)]);
/**
 * @param bin the raw transaction from which to read the output
 * @param offset the offset at which the output begins
 */

const readTransactionOutput = (bin, offset) => {
  const offsetAfterSatoshis = offset + 8
  /* uint64 */
  ;
  const satoshis = binToBigIntUint64LE(bin.subarray(offset, offsetAfterSatoshis));
  const {
    nextOffset: offsetAfterScriptLength,
    value
  } = readBitcoinVarInt(bin, offsetAfterSatoshis);
  const scriptLength = Number(value);
  const nextOffset = offsetAfterScriptLength + scriptLength;
  const lockingBytecode = scriptLength === 0 ? new Uint8Array() : bin.slice(offsetAfterScriptLength, nextOffset);
  return {
    nextOffset,
    output: {
      lockingBytecode,
      satoshis
    }
  };
};
/**
 * Serialize a single output.
 * @param output the output to serialize
 */

const serializeOutput = output => flattenBinArray([bigIntToBinUint64LE(BigInt(output.satoshis)), bigIntToBitcoinVarInt(BigInt(output.lockingBytecode.length)), output.lockingBytecode]);
/**
 * Serialize a set of outputs for inclusion in a serialized transaction.
 *
 * Format: <BitcoinVarInt: output count> <serialized outputs>
 *
 * @param outputs the set of outputs to serialize
 */

const serializeOutputsForTransaction = outputs => flattenBinArray([bigIntToBitcoinVarInt(BigInt(outputs.length)), ...outputs.map(serializeOutput)]);
/**
 * TODO: document return type (note outpointTransactionHash is little-endian â most UIs display big-endian transaction hashes)
 *
 * Note: this method throws runtime errors when attempting to decode improperly
 * encoded transactions.
 *
 * @param bin the raw transaction to decode
 */

const deserializeTransaction = bin => {
  const version = binToNumberUint32LE(bin.subarray(0, 4
  /* uint32 */
  ));
  const offsetAfterVersion = 4
  /* uint32 */
  ;
  const {
    nextOffset: offsetAfterInputCount,
    value: inputCount
  } = readBitcoinVarInt(bin, offsetAfterVersion); // eslint-disable-next-line functional/no-let

  let cursor = offsetAfterInputCount;
  const inputs = []; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < Number(inputCount); i++) {
    const {
      input,
      nextOffset
    } = readTransactionInput(bin, cursor); // eslint-disable-next-line functional/no-expression-statement

    cursor = nextOffset; // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

    inputs.push(input);
  }

  const {
    nextOffset: offsetAfterOutputCount,
    value: outputCount
  } = readBitcoinVarInt(bin, cursor); // eslint-disable-next-line functional/no-expression-statement

  cursor = offsetAfterOutputCount;
  const outputs = []; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < Number(outputCount); i++) {
    const {
      output,
      nextOffset
    } = readTransactionOutput(bin, cursor); // eslint-disable-next-line functional/no-expression-statement

    cursor = nextOffset; // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

    outputs.push(output);
  }

  const locktime = binToNumberUint32LE(bin.subarray(cursor, cursor + 4
  /* uint32 */
  ));
  return {
    inputs,
    locktime,
    outputs,
    version
  };
};
/**
 * TODO: doc
 */

const serializeTransaction = tx => flattenBinArray([numberToBinUint32LE(tx.version), serializeInputs(tx.inputs), serializeOutputsForTransaction(tx.outputs), numberToBinUint32LE(tx.locktime)]);
/**
 * Derive a standard identifier from a serialized data structure.
 *
 * @remarks
 * By convention, Bitcoin transaction and block identifiers are derived by
 * double-sha256 hashing their serialized form, and reversing the byte order.
 * (The result of sha256 is defined by its specification as big-endian, and
 * bitcoin displays hashes in little-endian format.)
 *
 * @returns an identifier in little-endian byte order
 *
 * @param data the serialized raw data being identified
 * @param sha256 an implementation of sha256
 */

const getBitcoinIdentifier = (data, sha256) => sha256.hash(sha256.hash(data)).reverse();
/**
 * Derive a standard transaction identifier from a serialized transaction.
 *
 * @returns a Transaction ID in little-endian byte order
 *
 * @param transaction the serialized transaction
 * @param sha256 an implementation of sha256
 */

const getBitcoinTransactionId = (transaction, sha256) => binToHex(getBitcoinIdentifier(transaction, sha256));
/**
 * Get the hash of all outpoints in a series of inputs. (For use in
 * `hashTransactionOutpoints`.)
 *
 * @param inputs the series of inputs from which to extract the outpoints
 * @param sha256 an implementation of sha256
 */

const serializeOutpoints = inputs => flattenBinArray(inputs.map(i => flattenBinArray([i.outpointTransactionHash.slice().reverse(), numberToBinUint32LE(i.outpointIndex)])));
/**
 * Get the signing serialization for a series of outputs.
 * @param outputs the series of outputs to serialize
 */

const serializeOutputsForSigning = outputs => flattenBinArray(outputs.map(serializeOutput));
/**
 * Serialize a series of input sequence numbers.
 *
 * @param inputs the series of inputs from which to extract the sequence numbers
 */

const serializeSequenceNumbers = inputs => flattenBinArray(inputs.map(i => numberToBinUint32LE(i.sequenceNumber)));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/errors.js
var AuthenticationErrorCommon;

(function (AuthenticationErrorCommon) {
  AuthenticationErrorCommon["calledReserved"] = "Program called an unassigned, reserved operation.";
  AuthenticationErrorCommon["calledReturn"] = "Program called an OP_RETURN operation.";
  AuthenticationErrorCommon["calledUpgradableNop"] = "Program called a disallowed upgradable non-operation (OP_NOP1-OP_NOP10).";
  AuthenticationErrorCommon["checkSequenceUnavailable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation, but OP_CHECKSEQUENCEVERIFY requires transaction version 2 or higher.";
  AuthenticationErrorCommon["disabledOpcode"] = "Program contains a disabled opcode.";
  AuthenticationErrorCommon["emptyAlternateStack"] = "Tried to read from an empty alternate stack.";
  AuthenticationErrorCommon["emptyStack"] = "Tried to read from an empty stack.";
  AuthenticationErrorCommon["exceededMaximumBytecodeLengthLocking"] = "The provided locking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon["exceededMaximumBytecodeLengthUnlocking"] = "The provided unlocking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon["exceededMaximumStackDepth"] = "Program exceeded the maximum stack depth (1,000 items).";
  AuthenticationErrorCommon["exceededMaximumOperationCount"] = "Program exceeded the maximum operation count (201 operations).";
  AuthenticationErrorCommon["exceedsMaximumMultisigPublicKeyCount"] = "Program called an OP_CHECKMULTISIG which exceeds the maximum public key count (20 public keys).";
  AuthenticationErrorCommon["exceedsMaximumPush"] = "Push exceeds the push size limit of 520 bytes.";
  AuthenticationErrorCommon["failedVerify"] = "Program failed an OP_VERIFY operation.";
  AuthenticationErrorCommon["invalidStackIndex"] = "Tried to read from an invalid stack index.";
  AuthenticationErrorCommon["incompatibleLocktimeType"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation with an incompatible locktime type. The transaction locktime and required locktime must both refer to either a block height or a block time.";
  AuthenticationErrorCommon["incompatibleSequenceType"] = "Program called an OP_CHECKSEQUENCEVERIFY operation with an incompatible sequence type flag. The input sequence number and required sequence number must both use the same sequence locktime type.";
  AuthenticationErrorCommon["insufficientPublicKeys"] = "Program called an OP_CHECKMULTISIG operation which requires signatures from more public keys than are provided.";
  AuthenticationErrorCommon["invalidNaturalNumber"] = "Invalid input: the key/signature count inputs for OP_CHECKMULTISIG require a natural number (n > 0).";
  AuthenticationErrorCommon["invalidProtocolBugValue"] = "The OP_CHECKMULTISIG protocol bug value must be a Script Number 0 (to comply with the \"NULLDUMMY\" rule).";
  AuthenticationErrorCommon["invalidPublicKeyEncoding"] = "Encountered an improperly encoded public key.";
  AuthenticationErrorCommon["invalidScriptNumber"] = "Invalid input: this operation requires a valid Script Number.";
  AuthenticationErrorCommon["invalidSignatureEncoding"] = "Encountered an improperly encoded signature.";
  AuthenticationErrorCommon["locktimeDisabled"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation, but locktime is disabled for this transaction.";
  AuthenticationErrorCommon["malformedLockingBytecode"] = "The provided locking bytecode is malformed.";
  AuthenticationErrorCommon["malformedPush"] = "Program must be long enough to push the requested number of bytes.";
  AuthenticationErrorCommon["malformedUnlockingBytecode"] = "The provided unlocking bytecode is malformed.";
  AuthenticationErrorCommon["negativeLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY or OP_CHECKSEQUENCEVERIFY operation with a negative locktime.";
  AuthenticationErrorCommon["nonMinimalPush"] = "Push operations must use the smallest possible encoding.";
  AuthenticationErrorCommon["nonNullSignatureFailure"] = "Program failed a signature verification with a non-null signature (violating the \"NULLFAIL\" rule).";
  AuthenticationErrorCommon["schnorrSizedSignatureInCheckMultiSig"] = "Program used a schnorr-sized signature (65 bytes) in an OP_CHECKMULTISIG operation.";
  AuthenticationErrorCommon["unexpectedElse"] = "Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.";
  AuthenticationErrorCommon["unexpectedEndIf"] = "Encountered an OP_ENDIF which is not following a matching OP_IF.";
  AuthenticationErrorCommon["unknownOpcode"] = "Called an unknown opcode.";
  AuthenticationErrorCommon["unmatchedSequenceDisable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation requiring the disable flag, but the input's sequence number is missing the disable flag.";
  AuthenticationErrorCommon["unsatisfiedLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation which requires a locktime greater than the transaction's locktime.";
  AuthenticationErrorCommon["unsatisfiedSequenceNumber"] = "Program called an OP_CHECKSEQUENCEVERIFY operation which requires a sequence number greater than the input's sequence number.";
})(AuthenticationErrorCommon || (AuthenticationErrorCommon = {}));
/**
 * Applies the `error` to a `state`.
 *
 * @remarks
 * If the state already has an error, this method does not override it.
 * (Evaluation should end after the first encountered error, so further errors
 * aren't relevant.)
 */


const applyError = (error, state) => ({ ...state,
  error: state.error === undefined ? error : state.error
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/opcodes.js
var OpcodesCommon;

(function (OpcodesCommon) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesCommon[OpcodesCommon["OP_0"] = 0] = "OP_0";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesCommon[OpcodesCommon["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesCommon[OpcodesCommon["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesCommon[OpcodesCommon["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesCommon[OpcodesCommon["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesCommon[OpcodesCommon["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesCommon[OpcodesCommon["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */

  OpcodesCommon[OpcodesCommon["OP_1"] = 81] = "OP_1";
  OpcodesCommon[OpcodesCommon["OP_2"] = 82] = "OP_2";
  OpcodesCommon[OpcodesCommon["OP_3"] = 83] = "OP_3";
  OpcodesCommon[OpcodesCommon["OP_4"] = 84] = "OP_4";
  OpcodesCommon[OpcodesCommon["OP_5"] = 85] = "OP_5";
  OpcodesCommon[OpcodesCommon["OP_6"] = 86] = "OP_6";
  OpcodesCommon[OpcodesCommon["OP_7"] = 87] = "OP_7";
  OpcodesCommon[OpcodesCommon["OP_8"] = 88] = "OP_8";
  OpcodesCommon[OpcodesCommon["OP_9"] = 89] = "OP_9";
  OpcodesCommon[OpcodesCommon["OP_10"] = 90] = "OP_10";
  OpcodesCommon[OpcodesCommon["OP_11"] = 91] = "OP_11";
  OpcodesCommon[OpcodesCommon["OP_12"] = 92] = "OP_12";
  OpcodesCommon[OpcodesCommon["OP_13"] = 93] = "OP_13";
  OpcodesCommon[OpcodesCommon["OP_14"] = 94] = "OP_14";
  OpcodesCommon[OpcodesCommon["OP_15"] = 95] = "OP_15";
  OpcodesCommon[OpcodesCommon["OP_16"] = 96] = "OP_16";
  OpcodesCommon[OpcodesCommon["OP_NOP"] = 97] = "OP_NOP";
  OpcodesCommon[OpcodesCommon["OP_VER"] = 98] = "OP_VER";
  OpcodesCommon[OpcodesCommon["OP_IF"] = 99] = "OP_IF";
  OpcodesCommon[OpcodesCommon["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesCommon[OpcodesCommon["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesCommon[OpcodesCommon["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesCommon[OpcodesCommon["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesCommon[OpcodesCommon["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesCommon[OpcodesCommon["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesCommon[OpcodesCommon["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesCommon[OpcodesCommon["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesCommon[OpcodesCommon["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesCommon[OpcodesCommon["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesCommon[OpcodesCommon["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesCommon[OpcodesCommon["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesCommon[OpcodesCommon["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesCommon[OpcodesCommon["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesCommon[OpcodesCommon["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesCommon[OpcodesCommon["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesCommon[OpcodesCommon["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesCommon[OpcodesCommon["OP_DROP"] = 117] = "OP_DROP";
  OpcodesCommon[OpcodesCommon["OP_DUP"] = 118] = "OP_DUP";
  OpcodesCommon[OpcodesCommon["OP_NIP"] = 119] = "OP_NIP";
  OpcodesCommon[OpcodesCommon["OP_OVER"] = 120] = "OP_OVER";
  OpcodesCommon[OpcodesCommon["OP_PICK"] = 121] = "OP_PICK";
  OpcodesCommon[OpcodesCommon["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesCommon[OpcodesCommon["OP_ROT"] = 123] = "OP_ROT";
  OpcodesCommon[OpcodesCommon["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesCommon[OpcodesCommon["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesCommon[OpcodesCommon["OP_CAT"] = 126] = "OP_CAT";
  OpcodesCommon[OpcodesCommon["OP_SUBSTR"] = 127] = "OP_SUBSTR";
  OpcodesCommon[OpcodesCommon["OP_LEFT"] = 128] = "OP_LEFT";
  OpcodesCommon[OpcodesCommon["OP_RIGHT"] = 129] = "OP_RIGHT";
  OpcodesCommon[OpcodesCommon["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesCommon[OpcodesCommon["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesCommon[OpcodesCommon["OP_AND"] = 132] = "OP_AND";
  OpcodesCommon[OpcodesCommon["OP_OR"] = 133] = "OP_OR";
  OpcodesCommon[OpcodesCommon["OP_XOR"] = 134] = "OP_XOR";
  OpcodesCommon[OpcodesCommon["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesCommon[OpcodesCommon["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesCommon[OpcodesCommon["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesCommon[OpcodesCommon["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesCommon[OpcodesCommon["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesCommon[OpcodesCommon["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesCommon[OpcodesCommon["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesCommon[OpcodesCommon["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesCommon[OpcodesCommon["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesCommon[OpcodesCommon["OP_ABS"] = 144] = "OP_ABS";
  OpcodesCommon[OpcodesCommon["OP_NOT"] = 145] = "OP_NOT";
  OpcodesCommon[OpcodesCommon["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesCommon[OpcodesCommon["OP_ADD"] = 147] = "OP_ADD";
  OpcodesCommon[OpcodesCommon["OP_SUB"] = 148] = "OP_SUB";
  OpcodesCommon[OpcodesCommon["OP_MUL"] = 149] = "OP_MUL";
  OpcodesCommon[OpcodesCommon["OP_DIV"] = 150] = "OP_DIV";
  OpcodesCommon[OpcodesCommon["OP_MOD"] = 151] = "OP_MOD";
  OpcodesCommon[OpcodesCommon["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesCommon[OpcodesCommon["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesCommon[OpcodesCommon["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesCommon[OpcodesCommon["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesCommon[OpcodesCommon["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesCommon[OpcodesCommon["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesCommon[OpcodesCommon["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesCommon[OpcodesCommon["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesCommon[OpcodesCommon["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesCommon[OpcodesCommon["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesCommon[OpcodesCommon["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesCommon[OpcodesCommon["OP_MIN"] = 163] = "OP_MIN";
  OpcodesCommon[OpcodesCommon["OP_MAX"] = 164] = "OP_MAX";
  OpcodesCommon[OpcodesCommon["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesCommon[OpcodesCommon["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesCommon[OpcodesCommon["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesCommon[OpcodesCommon["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesCommon[OpcodesCommon["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesCommon[OpcodesCommon["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesCommon[OpcodesCommon["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesCommon[OpcodesCommon["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesCommon[OpcodesCommon["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesCommon[OpcodesCommon["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesCommon[OpcodesCommon["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesCommon[OpcodesCommon["OP_NOP1"] = 176] = "OP_NOP1";
  /**
   * Previously `OP_NOP2`
   */

  OpcodesCommon[OpcodesCommon["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  /**
   * Previously `OP_NOP2`
   */

  OpcodesCommon[OpcodesCommon["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesCommon[OpcodesCommon["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesCommon[OpcodesCommon["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesCommon[OpcodesCommon["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesCommon[OpcodesCommon["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesCommon[OpcodesCommon["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesCommon[OpcodesCommon["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesCommon[OpcodesCommon["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesCommon[OpcodesCommon["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesCommon || (OpcodesCommon = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/flow-control.js





const opVerify = () => state => useOneStackItem(state, (nextState, item) => stackItemIsTruthy(item) ? nextState : applyError(AuthenticationErrorCommon.failedVerify, nextState));
const reservedOperation = () => state => applyError(AuthenticationErrorCommon.calledReserved, state);
const opReturn = () => state => applyError(AuthenticationErrorCommon.calledReturn, state);
const conditionalFlowControlOperations = () => ({
  [OpcodesCommon.OP_RESERVED]: reservedOperation(),
  [OpcodesCommon.OP_VER]: reservedOperation(),
  [OpcodesCommon.OP_VERIFY]: opVerify(),
  [OpcodesCommon.OP_RETURN]: opReturn(),
  [OpcodesCommon.OP_RESERVED1]: reservedOperation(),
  [OpcodesCommon.OP_RESERVED2]: reservedOperation()
});
const opIf = () => state => {
  if (state.executionStack.every(item => item)) {
    // eslint-disable-next-line functional/immutable-data
    const element = state.stack.pop();

    if (element === undefined) {
      return applyError(AuthenticationErrorCommon.emptyStack, state);
    } // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data


    state.executionStack.push(stackItemIsTruthy(element));
    return state;
  } // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data


  state.executionStack.push(false);
  return state;
};
const opNotIf = flags => {
  const not = conditionallyEvaluate(opNot(flags));
  const ifOp = opIf();
  return state => ifOp(not(state));
};
const opEndIf = () => state => {
  // eslint-disable-next-line functional/immutable-data
  const element = state.executionStack.pop();

  if (element === undefined) {
    return applyError(AuthenticationErrorCommon.unexpectedEndIf, state);
  }

  return state;
};
const opElse = () => state => {
  const top = state.executionStack[state.executionStack.length - 1];

  if (top === undefined) {
    return applyError(AuthenticationErrorCommon.unexpectedElse, state);
  } // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data


  state.executionStack[state.executionStack.length - 1] = !top;
  return state;
};
const unconditionalFlowControlOperations = flags => ({
  [OpcodesCommon.OP_IF]: opIf(),
  [OpcodesCommon.OP_NOTIF]: opNotIf(flags),
  [OpcodesCommon.OP_VERIF]: reservedOperation(),
  [OpcodesCommon.OP_VERNOTIF]: reservedOperation(),
  [OpcodesCommon.OP_ELSE]: opElse(),
  [OpcodesCommon.OP_ENDIF]: opEndIf()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/arithmetic.js




const op1Add = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, bigIntToScriptNumber(value + BigInt(1))), flags.requireMinimalEncoding);
const op1Sub = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, bigIntToScriptNumber(value - BigInt(1))), flags.requireMinimalEncoding);
const opNegate = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, bigIntToScriptNumber(-value)), flags.requireMinimalEncoding);
const opAbs = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, bigIntToScriptNumber(value < 0 ? -value : value)), flags.requireMinimalEncoding);
const opNot = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, value === BigInt(0) ? bigIntToScriptNumber(BigInt(1)) : bigIntToScriptNumber(BigInt(0))), flags.requireMinimalEncoding);
const op0NotEqual = flags => state => useOneScriptNumber(state, (nextState, value) => pushToStack(nextState, value === BigInt(0) ? bigIntToScriptNumber(BigInt(0)) : bigIntToScriptNumber(BigInt(1))), flags.requireMinimalEncoding);
const opAdd = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, bigIntToScriptNumber(firstValue + secondValue)), flags.requireMinimalEncoding);
const opSub = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, bigIntToScriptNumber(firstValue - secondValue)), flags.requireMinimalEncoding);
const opBoolAnd = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue !== BigInt(0) && secondValue !== BigInt(0))), flags.requireMinimalEncoding);
const opBoolOr = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue !== BigInt(0) || secondValue !== BigInt(0))), flags.requireMinimalEncoding);
const opNumEqual = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue === secondValue)), flags.requireMinimalEncoding);
const opNumEqualVerify = flags => combineOperations(opNumEqual(flags), opVerify());
const opNumNotEqual = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue !== secondValue)), flags.requireMinimalEncoding);
const opLessThan = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue < secondValue)), flags.requireMinimalEncoding);
const opLessThanOrEqual = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue <= secondValue)), flags.requireMinimalEncoding);
const opGreaterThan = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue > secondValue)), flags.requireMinimalEncoding);
const opGreaterThanOrEqual = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, booleanToScriptNumber(firstValue >= secondValue)), flags.requireMinimalEncoding);
const opMin = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, bigIntToScriptNumber(firstValue < secondValue ? firstValue : secondValue)), flags.requireMinimalEncoding);
const opMax = flags => state => useTwoScriptNumbers(state, (nextState, firstValue, secondValue) => pushToStack(nextState, bigIntToScriptNumber(firstValue > secondValue ? firstValue : secondValue)), flags.requireMinimalEncoding);
const opWithin = flags => state => useThreeScriptNumbers(state, (nextState, firstValue, secondValue, thirdValue) => pushToStack(nextState, booleanToScriptNumber(secondValue <= firstValue && firstValue < thirdValue)), flags.requireMinimalEncoding);
const arithmeticOperations = flags => ({
  [OpcodesCommon.OP_1ADD]: op1Add(flags),
  [OpcodesCommon.OP_1SUB]: op1Sub(flags),
  [OpcodesCommon.OP_NEGATE]: opNegate(flags),
  [OpcodesCommon.OP_ABS]: opAbs(flags),
  [OpcodesCommon.OP_NOT]: opNot(flags),
  [OpcodesCommon.OP_0NOTEQUAL]: op0NotEqual(flags),
  [OpcodesCommon.OP_ADD]: opAdd(flags),
  [OpcodesCommon.OP_SUB]: opSub(flags),
  [OpcodesCommon.OP_BOOLAND]: opBoolAnd(flags),
  [OpcodesCommon.OP_BOOLOR]: opBoolOr(flags),
  [OpcodesCommon.OP_NUMEQUAL]: opNumEqual(flags),
  [OpcodesCommon.OP_NUMEQUALVERIFY]: opNumEqualVerify(flags),
  [OpcodesCommon.OP_NUMNOTEQUAL]: opNumNotEqual(flags),
  [OpcodesCommon.OP_LESSTHAN]: opLessThan(flags),
  [OpcodesCommon.OP_LESSTHANOREQUAL]: opLessThanOrEqual(flags),
  [OpcodesCommon.OP_GREATERTHAN]: opGreaterThan(flags),
  [OpcodesCommon.OP_GREATERTHANOREQUAL]: opGreaterThanOrEqual(flags),
  [OpcodesCommon.OP_MIN]: opMin(flags),
  [OpcodesCommon.OP_MAX]: opMax(flags),
  [OpcodesCommon.OP_WITHIN]: opWithin(flags)
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/bitwise.js





const areEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  } // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus


  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
};

const opEqual = () => state => useTwoStackItems(state, (nextState, element1, element2) => pushToStack(nextState, booleanToScriptNumber(areEqual(element1, element2))));
const opEqualVerify = () => combineOperations(opEqual(), opVerify());
const bitwiseOperations = () => ({
  [OpcodesCommon.OP_EQUAL]: opEqual(),
  [OpcodesCommon.OP_EQUALVERIFY]: opEqualVerify()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-types.js


var ConsensusBCH;

(function (ConsensusBCH) {
  ConsensusBCH[ConsensusBCH["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusBCH || (ConsensusBCH = {}));

const createTestAuthenticationProgramBCH = (unlockingBytecode, lockingBytecode, sha256, satoshis = BigInt(0)) => {
  const testFundingTransaction = {
    inputs: [{
      outpointIndex: 0xffffffff,
      outpointTransactionHash: hexToBin('0000000000000000000000000000000000000000000000000000000000000000'),
      sequenceNumber: 0xffffffff,
      unlockingBytecode: Uint8Array.of(0, 0)
    }],
    locktime: 0,
    outputs: [{
      lockingBytecode,
      satoshis
    }],
    version: 1
  };
  const testSpendingTransaction = {
    inputs: [{
      outpointIndex: 0,
      outpointTransactionHash: hexToBin(swapEndianness(getBitcoinTransactionId(serializeTransaction(testFundingTransaction), sha256))),
      sequenceNumber: 0xffffffff,
      unlockingBytecode
    }],
    locktime: 0,
    outputs: [{
      lockingBytecode: Uint8Array.of(),
      satoshis
    }],
    version: 1
  };
  return {
    inputIndex: 0,
    sourceOutput: testFundingTransaction.outputs[0],
    spendingTransaction: testSpendingTransaction
  };
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/instruction-sets-utils.js



const authenticationInstructionIsMalformed = instruction => instruction.malformed;
const authenticationInstructionsAreMalformed = instructions => instructions.length > 0 && authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
const authenticationInstructionsAreNotMalformed = instructions => !authenticationInstructionsAreMalformed(instructions);
var CommonPushOpcodes;

(function (CommonPushOpcodes) {
  CommonPushOpcodes[CommonPushOpcodes["OP_0"] = 0] = "OP_0";
  CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
})(CommonPushOpcodes || (CommonPushOpcodes = {}));

var Bytes;

(function (Bytes) {
  Bytes[Bytes["Uint8"] = 1] = "Uint8";
  Bytes[Bytes["Uint16"] = 2] = "Uint16";
  Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(Bytes || (Bytes = {}));
/**
 * Note: this implementation assumes `script` is defined and long enough to read
 * the specified number of bytes. If necessary, validation should be done before
 * calling this method.
 *
 * @param script the Uint8Array from which to read
 * @param index the index from which to begin reading
 * @param length the number of bytes to read
 */


const readLittleEndianNumber = (script, index, length) => {
  const view = new DataView(script.buffer, index, length);
  const readAsLittleEndian = true;
  return length === Bytes.Uint8 ? view.getUint8(0) : length === Bytes.Uint16 ? view.getUint16(0, readAsLittleEndian) : view.getUint32(0, readAsLittleEndian);
};
/**
 * Note: this implementation assumes `script` is defined and long enough to
 * write the specified number of bytes. It also assumes the provided `number` is
 * representable in `length` bytes.
 *
 * If necessary, validation should be done before calling this method.
 *
 * @param script the Uint8Array to which the number should be written
 * @param index the index at which to begin reading
 * @param length the number of bytes to use
 * @param value the number to write at `script[index]`
 */

const writeLittleEndianNumber = (script, index, length, value) => {
  const view = new DataView(script.buffer, index, length);
  const writeAsLittleEndian = true; // eslint-disable-next-line @typescript-eslint/no-unused-expressions, functional/no-expression-statement

  length === Bytes.Uint8 ? view.setUint8(0, value) : length === Bytes.Uint16 ? view.setUint16(0, value, writeAsLittleEndian) : view.setUint32(0, value, writeAsLittleEndian);
  return script;
};
const numberToLittleEndianBin = (value, length) => {
  const array = new Uint8Array(length);
  return writeLittleEndianNumber(array, 0, length, value);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode an opcode between 0x00 and 0x4e
 */

const lengthBytesForPushOpcode = opcode => opcode < CommonPushOpcodes.OP_PUSHDATA_1 ? 0 : opcode === CommonPushOpcodes.OP_PUSHDATA_1 ? Bytes.Uint8 : opcode === CommonPushOpcodes.OP_PUSHDATA_2 ? Bytes.Uint16 : Bytes.Uint32;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script the script from which to read the next instruction
 * @param index the offset from which to begin reading
 */
// eslint-disable-next-line complexity

const readAuthenticationInstruction = (script, index) => {
  const opcode = script[index];

  if (opcode > CommonPushOpcodes.OP_PUSHDATA_4) {
    return {
      instruction: {
        opcode: opcode
      },
      nextIndex: index + 1
    };
  }

  const lengthBytes = lengthBytesForPushOpcode(opcode);
  const pushBytes = lengthBytes === 0;

  if (!pushBytes && index + lengthBytes >= script.length) {
    const sliceStart = index + 1;
    const sliceEnd = sliceStart + lengthBytes;
    return {
      instruction: {
        expectedLengthBytes: lengthBytes,
        length: script.slice(sliceStart, sliceEnd),
        malformed: true,
        opcode: opcode
      },
      nextIndex: sliceEnd
    };
  }

  const dataBytes = pushBytes ? opcode : readLittleEndianNumber(script, index + 1, lengthBytes);
  const dataStart = index + 1 + lengthBytes;
  const dataEnd = dataStart + dataBytes;
  return {
    instruction: {
      data: script.slice(dataStart, dataEnd),
      ...(dataEnd > script.length ? {
        expectedDataBytes: dataEnd - dataStart,
        malformed: true
      } : undefined),
      opcode: opcode
    },
    nextIndex: dataEnd
  };
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script the serialized script to parse
 */

const parseBytecode = script => {
  const instructions = []; // eslint-disable-next-line functional/no-let

  let i = 0; // eslint-disable-next-line functional/no-loop-statement

  while (i < script.length) {
    const {
      instruction,
      nextIndex
    } = readAuthenticationInstruction(script, i); // eslint-disable-next-line functional/no-expression-statement

    i = nextIndex; // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

    instructions.push(instruction);
  }

  return instructions;
};

const isPush = instruction => instruction.data !== undefined;
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */


const isMultiWordPush = opcode => opcode !== CommonPushOpcodes.OP_0;

const formatAsmPushHex = data => data.length > 0 ? `0x${binToHex(data)}` : '';

const formatMissingBytesAsm = missing => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;

const hasMalformedLength = instruction => instruction.length !== undefined;

const isPushData = pushOpcode => lengthBytesForPushOpcode(pushOpcode) > 0;

const disassembleParsedAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode]} ${hasMalformedLength(instruction) ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}` : `${isPushData(instruction.opcode) ? `${instruction.expectedDataBytes} ` : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
const disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode]}${isPush(instruction) && isMultiWordPush(instruction.opcode) ? ` ${isPushData(instruction.opcode) ? `${instruction.data.length} ` : ''}${formatAsmPushHex(instruction.data)}` : ''}`;
const disassembleParsedAuthenticationInstruction = (opcodes, instruction) => authenticationInstructionIsMalformed(instruction) ? disassembleParsedAuthenticationInstructionMalformed(opcodes, instruction) : disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script the array of instructions to disassemble
 */

const disassembleParsedAuthenticationInstructions = (opcodes, instructions) => instructions.map(instruction => disassembleParsedAuthenticationInstruction(opcodes, instruction)).join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode the authentication bytecode to disassemble
 */

const disassembleBytecode = (opcodes, bytecode) => disassembleParsedAuthenticationInstructions(opcodes, parseBytecode(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */

const disassembleBytecodeBCH = bytecode => disassembleParsedAuthenticationInstructions(OpcodesBCH, parseBytecode(bytecode)); // TODO: assembleBytecodeBCH â instantiate synchronous compiler, throw any errors

/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode the authentication bytecode to disassemble
 */

const disassembleBytecodeBTC = bytecode => disassembleParsedAuthenticationInstructions(OpcodesBTC, parseBytecode(bytecode)); // TODO: assembleBytecodeBTC

const getLengthBytes = instruction => numberToLittleEndianBin(instruction.data.length, lengthBytesForPushOpcode(instruction.opcode));

const serializeAuthenticationInstruction = instruction => Uint8Array.from([instruction.opcode, ...(isPush(instruction) ? [...(isPushData(instruction.opcode) ? getLengthBytes(instruction) : []), ...instruction.data] : [])]);
const serializeParsedAuthenticationInstructionMalformed = instruction => Uint8Array.from([instruction.opcode, ...(hasMalformedLength(instruction) ? instruction.length : isPushData(instruction.opcode) ? numberToLittleEndianBin(instruction.expectedDataBytes, lengthBytesForPushOpcode(instruction.opcode)) : []), ...(hasMalformedLength(instruction) ? [] : instruction.data)]);
const serializeParsedAuthenticationInstruction = instruction => authenticationInstructionIsMalformed(instruction) ? serializeParsedAuthenticationInstructionMalformed(instruction) : serializeAuthenticationInstruction(instruction);
const serializeAuthenticationInstructions = instructions => flattenBinArray(instructions.map(serializeAuthenticationInstruction));
const serializeParsedAuthenticationInstructions = instructions => flattenBinArray(instructions.map(serializeParsedAuthenticationInstruction));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes An opcode enum, e.g. `OpcodesBCH`
 */

const generateBytecodeMap = opcodes => Object.entries(opcodes).filter(entry => typeof entry[1] === 'number').reduce((identifiers, pair) => ({ ...identifiers,
  [pair[0]]: Uint8Array.of(pair[1])
}), {});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/signing-serialization.js

/* eslint-disable camelcase */

/**
 * A.K.A. `sighash` flags
 */

var SigningSerializationFlag;

(function (SigningSerializationFlag) {
  /**
   * A.K.A. `SIGHASH_ALL`
   */
  SigningSerializationFlag[SigningSerializationFlag["all_outputs"] = 1] = "all_outputs";
  /**
   * A.K.A `SIGHASH_NONE`
   */

  SigningSerializationFlag[SigningSerializationFlag["no_outputs"] = 2] = "no_outputs";
  /**
   * A.K.A. `SIGHASH_SINGLE`
   */

  SigningSerializationFlag[SigningSerializationFlag["corresponding_output"] = 3] = "corresponding_output";
  SigningSerializationFlag[SigningSerializationFlag["fork_id"] = 64] = "fork_id";
  /**
   * A.K.A `ANYONE_CAN_PAY`
   */

  SigningSerializationFlag[SigningSerializationFlag["single_input"] = 128] = "single_input";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));

const isDefinedSigningSerializationType = byte => {
  const baseType = // eslint-disable-next-line no-bitwise
  byte & // eslint-disable-next-line no-bitwise
  ~(SigningSerializationFlag.fork_id | SigningSerializationFlag.single_input);
  return baseType >= SigningSerializationFlag.all_outputs && baseType <= SigningSerializationFlag.corresponding_output;
};

const match = (type, flag) => // eslint-disable-next-line no-bitwise
(type[0] & flag) !== 0;

const equals = (type, flag // eslint-disable-next-line no-bitwise
) => (type[0] & 31
/* mask5Bits */
) === flag;

const shouldSerializeSingleInput = type => match(type, SigningSerializationFlag.single_input);

const shouldSerializeCorrespondingOutput = type => equals(type, SigningSerializationFlag.corresponding_output);

const shouldSerializeNoOutputs = type => equals(type, SigningSerializationFlag.no_outputs);

const emptyHash = () => new Uint8Array(32
/* sha256HashByteLength */
).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutpoints see `generateSigningSerializationBCH`
 */


const hashPrevouts = (sha256, signingSerializationType, transactionOutpoints) => shouldSerializeSingleInput(signingSerializationType) ? emptyHash() : sha256.hash(sha256.hash(transactionOutpoints));
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionSequenceNumbers see
 * `generateSigningSerializationBCH`
 */

const hashSequence = (sha256, signingSerializationType, transactionSequenceNumbers) => !shouldSerializeSingleInput(signingSerializationType) && !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? sha256.hash(sha256.hash(transactionSequenceNumbers)) : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType the signing serialization type to test
 * @param transactionOutputs see `generateSigningSerializationBCH`
 * @param correspondingOutput see `generateSigningSerializationBCH`
 */

const hashOutputs = (sha256, signingSerializationType, transactionOutputs, correspondingOutput) => !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? sha256.hash(sha256.hash(transactionOutputs)) : shouldSerializeCorrespondingOutput(signingSerializationType) ? correspondingOutput === undefined ? emptyHash() : sha256.hash(sha256.hash(correspondingOutput)) : emptyHash();
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * @param version the version number of the transaction
 * @param transactionOutpoints the serialization of all input outpoints (A.K.A.
 * `hashPrevouts`) â used if `ANYONECANPAY` is not set
 * @param transactionSequenceNumbers the serialization of all input sequence
 * numbers. (A.K.A. `hashSequence`) â used if none of `ANYONECANPAY`, `SINGLE`,
 * or `NONE` are set.
 * @param outpointTransactionHash the big-endian (standard) transaction hash of
 * the outpoint being spent.
 * @param outpointIndex the index of the outpoint being spent in
 * `outpointTransactionHash`
 * @param coveredBytecode the script currently being executed, beginning at the
 * `lastCodeSeparator`.
 * @param outputValue the value of the outpoint in satoshis
 * @param sequenceNumber the sequence number of the input (A.K.A. `nSequence`)
 * @param correspondingOutput the serialization of the output at the same index
 * as this input (A.K.A. `hashOutputs` with `SIGHASH_SINGLE`) â only used if
 * `SINGLE` is set
 * @param transactionOutputs the serialization of output amounts and locking
 * bytecode values (A.K.A. `hashOutputs` with `SIGHASH_ALL`) â only used if
 * `ALL` is set
 * @param locktime the locktime of the transaction
 * @param signingSerializationType the signing serialization type of the
 * signature (A.K.A. `sighash` type)
 * @param forkId while a bitcoin-encoded signature only includes a single byte
 * to encode the signing serialization type, a 3-byte forkId can be appended to
 * provide replay-protection between different forks. (See Bitcoin Cash's Replay
 * Protected Sighash spec for details.)
 */

const generateSigningSerializationBCH = (sha256, version, transactionOutpoints, transactionSequenceNumbers, outpointTransactionHash, outpointIndex, coveredBytecode, outputValue, sequenceNumber, correspondingOutput, transactionOutputs, locktime, signingSerializationType, forkId = new Uint8Array([0, 0, 0])) => new Uint8Array([...numberToBinUint32LE(version), ...hashPrevouts(sha256, signingSerializationType, transactionOutpoints), ...hashSequence(sha256, signingSerializationType, transactionSequenceNumbers), ...outpointTransactionHash.slice().reverse(), ...numberToBinUint32LE(outpointIndex), ...Uint8Array.from([...bigIntToBitcoinVarInt(BigInt(coveredBytecode.length)), ...coveredBytecode]), ...bigIntToBinUint64LE(outputValue), ...numberToBinUint32LE(sequenceNumber), ...hashOutputs(sha256, signingSerializationType, transactionOutputs, correspondingOutput), ...numberToBinUint32LE(locktime), ...signingSerializationType, ...forkId]);
/**
 * @param signingSerializationType the 32-bit number indicating the signing
 * serialization algorithm to use
 */

const isLegacySigningSerialization = signingSerializationType => {
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  const forkValue = signingSerializationType >> 8; // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers

  const newForkValue = forkValue ^ 0xdead | 0xff0000; // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers

  const sighashType = newForkValue << 8 | signingSerializationType & 0xff; // eslint-disable-next-line no-bitwise

  return (sighashType & SigningSerializationFlag.fork_id) === 0;
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/encoding.js


const isValidUncompressedPublicKeyEncoding = publicKey => publicKey.length === 65
/* uncompressedByteLength */
&& publicKey[0] === 4
/* uncompressedHeaderByte */
;
const isValidCompressedPublicKeyEncoding = publicKey => publicKey.length === 33
/* compressedByteLength */
&& (publicKey[0] === 2
/* compressedHeaderByteEven */
|| publicKey[0] === 3
/* compressedHeaderByteOdd */
);
const isValidPublicKeyEncoding = publicKey => isValidCompressedPublicKeyEncoding(publicKey) || isValidUncompressedPublicKeyEncoding(publicKey);

const isNegative = value => // eslint-disable-next-line no-bitwise
(value & 128
/* negative */
) !== 0;

const hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);

const isValidInteger = (signature, tagIndex, length, valueIndex) => signature[tagIndex] === 2
/* integerTagType */
&& length !== 0 && !isNegative(signature[valueIndex]) && !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use `isValidSignatureEncodingBCH`.
 *
 * @internalRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity


const isValidSignatureEncodingDER = signature => {
  const correctLengthRange = signature.length > 8
  /* minimumLength */
  && signature.length < 72
  /* maximumLength */
  ;
  const correctSequenceTagType = signature[0
  /* sequenceTagIndex */
  ] === 48
  /* sequenceTagType */
  ;
  const correctSequenceLength = signature[1
  /* sequenceLengthIndex */
  ] === signature.length - 2
  /* sequenceMetadataBytes */
  ;
  const rLength = signature[3
  /* rLengthIndex */
  ];

  if (rLength === undefined) {
    return false;
  }

  const consistentRLength = rLength <= signature.length - 7
  /* minimumNonRValueBytes */
  ;
  const rIsValid = isValidInteger(signature, 2
  /* rTagIndex */
  , rLength, 4
  /* rValueIndex */
  );
  const sTagIndex = 4
  /* rValueIndex */
  + rLength; // eslint-disable-line @typescript-eslint/restrict-plus-operands

  const sLengthIndex = sTagIndex + 1;
  const sLength = signature[sLengthIndex];

  if (sLength === undefined) {
    return false;
  }

  const sValueIndex = sLengthIndex + 1;
  const consistentSLength = sValueIndex + sLength === signature.length;
  const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
  return correctLengthRange && correctSequenceTagType && correctSequenceLength && consistentRLength && rIsValid && consistentSLength && sIsValid;
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature the full transaction signature
 */

const isValidSignatureEncodingBCHTransaction = transactionSignature => transactionSignature.length === 0 || transactionSignature.length === ConsensusBCH.schnorrSignatureLength + 1 || isDefinedSigningSerializationType(transactionSignature[transactionSignature.length - 1]) && isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1));
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param signature a signature which passes `isValidSignatureEncoding`
 */

const decodeBitcoinSignature = encodedSignature => ({
  signature: encodedSignature.slice(0, encodedSignature.length - 1),
  signingSerializationType: new Uint8Array([encodedSignature[encodedSignature.length - 1]])
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/crypto.js









const opRipemd160 = ripemd160 => state => useOneStackItem(state, (nextState, value) => pushToStack(nextState, ripemd160.hash(value)));
const opSha1 = sha1 => state => useOneStackItem(state, (nextState, value) => pushToStack(nextState, sha1.hash(value)));
const opSha256 = sha256 => state => useOneStackItem(state, (nextState, value) => pushToStack(nextState, sha256.hash(value)));
const opHash160 = (sha256, ripemd160) => state => useOneStackItem(state, (nextState, value) => pushToStack(nextState, ripemd160.hash(sha256.hash(value))));
const opHash256 = sha256 => state => useOneStackItem(state, (nextState, value) => pushToStack(nextState, sha256.hash(sha256.hash(value))));
const opCodeSeparator = () => state => {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.lastCodeSeparator = state.ip;
  return state;
};
const opCheckSig = (sha256, secp256k1, flags) => s => // eslint-disable-next-line complexity
useTwoStackItems(s, (state, bitcoinEncodedSignature, publicKey) => {
  if (!isValidPublicKeyEncoding(publicKey)) {
    return applyError(AuthenticationErrorCommon.invalidPublicKeyEncoding, state);
  }

  if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature)) {
    return applyError(AuthenticationErrorCommon.invalidSignatureEncoding, state);
  }

  const coveredBytecode = serializeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
  const {
    signingSerializationType,
    signature
  } = decodeBitcoinSignature(bitcoinEncodedSignature);
  const serialization = generateSigningSerializationBCH(sha256, state.version, state.transactionOutpoints, state.transactionSequenceNumbers, state.outpointTransactionHash, state.outpointIndex, coveredBytecode, state.outputValue, state.sequenceNumber, state.correspondingOutput, state.transactionOutputs, state.locktime, signingSerializationType);
  const digest = sha256.hash(sha256.hash(serialization));
  const useSchnorr = signature.length === ConsensusBCH.schnorrSignatureLength;
  const success = useSchnorr ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
  return !success && flags.requireNullSignatureFailures && signature.length !== 0 ? applyError(AuthenticationErrorCommon.nonNullSignatureFailure, state) : pushToStack(state, booleanToScriptNumber(success));
});
const opCheckMultiSig = (sha256, secp256k1, flags) => s => useOneScriptNumber(s, (state, publicKeysValue) => {
  const potentialPublicKeys = Number(publicKeysValue);

  if (potentialPublicKeys < 0) {
    return applyError(AuthenticationErrorCommon.invalidNaturalNumber, state);
  }

  if (potentialPublicKeys > 20
  /* maximumPublicKeys */
  ) {
      return applyError(AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount, state);
    }

  const publicKeys = // eslint-disable-next-line functional/immutable-data
  potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : []; // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

  state.operationCount += potentialPublicKeys;
  return state.operationCount > ConsensusCommon.maximumOperationCount ? applyError(AuthenticationErrorCommon.exceededMaximumOperationCount, state) : useOneScriptNumber(state, (nextState, approvingKeys) => {
    const requiredApprovingPublicKeys = Number(approvingKeys);

    if (requiredApprovingPublicKeys < 0) {
      return applyError(AuthenticationErrorCommon.invalidNaturalNumber, nextState);
    }

    if (requiredApprovingPublicKeys > potentialPublicKeys) {
      return applyError(AuthenticationErrorCommon.insufficientPublicKeys, nextState);
    }

    const signatures = requiredApprovingPublicKeys > 0 ? // eslint-disable-next-line functional/immutable-data
    nextState.stack.splice(-requiredApprovingPublicKeys) : [];
    return useOneStackItem(nextState, // eslint-disable-next-line complexity
    (finalState, protocolBugValue) => {
      if (flags.requireBugValueZero && protocolBugValue.length !== 0) {
        return applyError(AuthenticationErrorCommon.invalidProtocolBugValue, finalState);
      }

      const coveredBytecode = serializeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
      let approvingPublicKeys = 0; // eslint-disable-line functional/no-let

      let remainingSignatures = signatures.length; // eslint-disable-line functional/no-let

      let remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
      // eslint-disable-next-line functional/no-loop-statement

      while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
        const publicKey = publicKeys[remainingPublicKeys - 1];
        const bitcoinEncodedSignature = signatures[remainingSignatures - 1];

        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(AuthenticationErrorCommon.invalidPublicKeyEncoding, finalState);
        }

        if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature)) {
          return applyError(AuthenticationErrorCommon.invalidSignatureEncoding, finalState);
        }

        const {
          signingSerializationType,
          signature
        } = decodeBitcoinSignature(bitcoinEncodedSignature);
        const serialization = generateSigningSerializationBCH(sha256, finalState.version, finalState.transactionOutpoints, finalState.transactionSequenceNumbers, finalState.outpointTransactionHash, finalState.outpointIndex, coveredBytecode, finalState.outputValue, finalState.sequenceNumber, finalState.correspondingOutput, finalState.transactionOutputs, finalState.locktime, signingSerializationType);
        const digest = sha256.hash(sha256.hash(serialization));

        if (signature.length === ConsensusBCH.schnorrSignatureLength) {
          return applyError(AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig, finalState);
        }

        const signed = secp256k1.verifySignatureDERLowS(signature, publicKey, digest); // eslint-disable-next-line functional/no-conditional-statement

        if (signed) {
          approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statement

          remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statement
        }

        remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statement
      }

      const success = approvingPublicKeys === requiredApprovingPublicKeys;

      if (!success && flags.requireNullSignatureFailures && !signatures.every(signature => signature.length === 0)) {
        return applyError(AuthenticationErrorCommon.nonNullSignatureFailure, finalState);
      }

      return pushToStack(finalState, booleanToScriptNumber(success));
    });
  }, flags.requireMinimalEncoding);
}, flags.requireMinimalEncoding);
const opCheckSigVerify = (sha256, secp256k1, flags) => combineOperations(opCheckSig(sha256, secp256k1, flags), opVerify());
const opCheckMultiSigVerify = (sha256, secp256k1, flags) => combineOperations(opCheckMultiSig(sha256, secp256k1, flags), opVerify());
const cryptoOperations = (sha1, sha256, ripemd160, secp256k1, flags) => ({
  [OpcodesCommon.OP_RIPEMD160]: opRipemd160(ripemd160),
  [OpcodesCommon.OP_SHA1]: opSha1(sha1),
  [OpcodesCommon.OP_SHA256]: opSha256(sha256),
  [OpcodesCommon.OP_HASH160]: opHash160(sha256, ripemd160),
  [OpcodesCommon.OP_HASH256]: opHash256(sha256),
  [OpcodesCommon.OP_CODESEPARATOR]: opCodeSeparator(),
  [OpcodesCommon.OP_CHECKSIG]: opCheckSig(sha256, secp256k1, flags),
  [OpcodesCommon.OP_CHECKSIGVERIFY]: opCheckSigVerify(sha256, secp256k1, flags),
  [OpcodesCommon.OP_CHECKMULTISIG]: opCheckMultiSig(sha256, secp256k1, flags),
  [OpcodesCommon.OP_CHECKMULTISIGVERIFY]: opCheckMultiSigVerify(sha256, secp256k1, flags)
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/nop.js


const opNop = flags => state => flags.disallowUpgradableNops ? applyError(AuthenticationErrorCommon.calledUpgradableNop, state) : state;
const nonOperations = flags => ({
  [OpcodesCommon.OP_NOP]: opNop(flags),
  [OpcodesCommon.OP_NOP1]: opNop(flags),
  [OpcodesCommon.OP_NOP4]: opNop(flags),
  [OpcodesCommon.OP_NOP5]: opNop(flags),
  [OpcodesCommon.OP_NOP6]: opNop(flags),
  [OpcodesCommon.OP_NOP7]: opNop(flags),
  [OpcodesCommon.OP_NOP8]: opNop(flags),
  [OpcodesCommon.OP_NOP9]: opNop(flags),
  [OpcodesCommon.OP_NOP10]: opNop(flags)
});
/**
 * "Disabled" operations are explicitly forbidden from occurring anywhere in a
 * script, even within an unexecuted branch.
 */

const disabledOperation = () => state => applyError(AuthenticationErrorCommon.unknownOpcode, state);
const disabledOperations = () => ({
  [OpcodesCommon.OP_CAT]: disabledOperation(),
  [OpcodesCommon.OP_SUBSTR]: disabledOperation(),
  [OpcodesCommon.OP_LEFT]: disabledOperation(),
  [OpcodesCommon.OP_RIGHT]: disabledOperation(),
  [OpcodesCommon.OP_INVERT]: disabledOperation(),
  [OpcodesCommon.OP_AND]: disabledOperation(),
  [OpcodesCommon.OP_OR]: disabledOperation(),
  [OpcodesCommon.OP_XOR]: disabledOperation(),
  [OpcodesCommon.OP_2MUL]: disabledOperation(),
  [OpcodesCommon.OP_2DIV]: disabledOperation(),
  [OpcodesCommon.OP_MUL]: disabledOperation(),
  [OpcodesCommon.OP_DIV]: disabledOperation(),
  [OpcodesCommon.OP_MOD]: disabledOperation(),
  [OpcodesCommon.OP_LSHIFT]: disabledOperation(),
  [OpcodesCommon.OP_RSHIFT]: disabledOperation()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/push.js






var PushOperationConstants;

(function (PushOperationConstants) {
  PushOperationConstants[PushOperationConstants["OP_0"] = 0] = "OP_0";
  /**
   * OP_PUSHBYTES_75
   */

  PushOperationConstants[PushOperationConstants["maximumPushByteOperationSize"] = 75] = "maximumPushByteOperationSize";
  PushOperationConstants[PushOperationConstants["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  PushOperationConstants[PushOperationConstants["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  PushOperationConstants[PushOperationConstants["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  /**
   * OP_PUSHDATA_4
   */

  PushOperationConstants[PushOperationConstants["highestPushDataOpcode"] = 78] = "highestPushDataOpcode";
  /**
   * For OP_1 to OP_16, `opcode` is the number offset by `0x50` (80):
   *
   * `OP_N = 0x50 + N`
   *
   * OP_0 is really OP_PUSHBYTES_0 (`0x00`), so it does not follow this pattern.
   */

  PushOperationConstants[PushOperationConstants["pushNumberOpcodesOffset"] = 80] = "pushNumberOpcodesOffset";
  /** OP_1 through OP_16 */

  PushOperationConstants[PushOperationConstants["pushNumberOpcodes"] = 16] = "pushNumberOpcodes";
  PushOperationConstants[PushOperationConstants["negativeOne"] = 129] = "negativeOne";
  PushOperationConstants[PushOperationConstants["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  /**
   * 256 - 1
   */

  PushOperationConstants[PushOperationConstants["maximumPushData1Size"] = 255] = "maximumPushData1Size";
  /**
   * Standard consensus parameter for most Bitcoin forks.
   */

  PushOperationConstants[PushOperationConstants["maximumPushSize"] = 520] = "maximumPushSize";
  /**
   * 256 ** 2 - 1
   */

  PushOperationConstants[PushOperationConstants["maximumPushData2Size"] = 65535] = "maximumPushData2Size";
  /**
   * 256 ** 4 - 1
   */

  PushOperationConstants[PushOperationConstants["maximumPushData4Size"] = 4294967295] = "maximumPushData4Size";
})(PushOperationConstants || (PushOperationConstants = {}));

var push_Bytes;

(function (Bytes) {
  Bytes[Bytes["Uint8"] = 1] = "Uint8";
  Bytes[Bytes["Uint16"] = 2] = "Uint16";
  Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(push_Bytes || (push_Bytes = {}));
/**
 * Returns the minimal bytecode required to push the provided `data` to the
 * stack.
 *
 * @remarks
 * This method conservatively encodes a `Uint8Array` as a data push. For Script
 * Numbers which can be pushed using a single opcode (-1 through 16), the
 * equivalent bytecode value is returned. Other `data` values will be prefixed
 * with the proper opcode and push length bytes (if necessary) to create the
 * minimal push instruction.
 *
 * Note, while some single-byte Script Number pushes will be minimally-encoded
 * by this method, all larger inputs will be encoded as-is (it cannot be assumed
 * that inputs are intended to be used as Script Numbers). To encode the push of
 * a Script Number, minimally-encode the number before passing it to this
 * method, e.g.:
 * `encodeDataPush(bigIntToScriptNumber(parseBytesAsScriptNumber(nonMinimalNumber)))`.
 *
 * The maximum `bytecode` length which can be encoded for a push in the Bitcoin
 * system is `4294967295` (~4GB). This method assumes a smaller input â if
 * `bytecode` has the potential to be longer, it should be checked (and the
 * error handled) prior to calling this method.
 *
 * @param data the Uint8Array to push to the stack
 */
// eslint-disable-next-line complexity


const encodeDataPush = data => data.length <= PushOperationConstants.maximumPushByteOperationSize ? data.length === 0 ? Uint8Array.of(0) : data.length === 1 ? data[0] !== 0 && data[0] <= PushOperationConstants.pushNumberOpcodes ? Uint8Array.of(data[0] + PushOperationConstants.pushNumberOpcodesOffset) : data[0] === PushOperationConstants.negativeOne ? Uint8Array.of(PushOperationConstants.OP_1NEGATE) : Uint8Array.from([1, ...data]) : Uint8Array.from([data.length, ...data]) : data.length <= PushOperationConstants.maximumPushData1Size ? Uint8Array.from([PushOperationConstants.OP_PUSHDATA_1, ...numberToLittleEndianBin(data.length, push_Bytes.Uint8), ...data]) : data.length <= PushOperationConstants.maximumPushData2Size ? Uint8Array.from([PushOperationConstants.OP_PUSHDATA_2, ...numberToLittleEndianBin(data.length, push_Bytes.Uint16), ...data]) : Uint8Array.from([PushOperationConstants.OP_PUSHDATA_4, ...numberToLittleEndianBin(data.length, push_Bytes.Uint32), ...data]);
/**
 * Returns true if the provided `data` is minimally-encoded by the provided
 * `opcode`.
 * @param opcode the opcode used to push `data`
 * @param data the contents of the push
 */
// eslint-disable-next-line complexity

const isMinimalDataPush = (opcode, data) => data.length === 0 ? opcode === PushOperationConstants.OP_0 : data.length === 1 ? data[0] >= 1 && data[0] <= PushOperationConstants.pushNumberOpcodes ? opcode === data[0] + PushOperationConstants.pushNumberOpcodesOffset : data[0] === PushOperationConstants.negativeOne ? opcode === PushOperationConstants.OP_1NEGATE : true : data.length <= PushOperationConstants.maximumPushByteOperationSize ? opcode === data.length : data.length <= PushOperationConstants.maximumPushData1Size ? opcode === PushOperationConstants.OP_PUSHDATA_1 : data.length <= PushOperationConstants.maximumPushData2Size ? opcode === PushOperationConstants.OP_PUSHDATA_2 : true;
const pushByteOpcodes = [OpcodesCommon.OP_PUSHBYTES_1, OpcodesCommon.OP_PUSHBYTES_2, OpcodesCommon.OP_PUSHBYTES_3, OpcodesCommon.OP_PUSHBYTES_4, OpcodesCommon.OP_PUSHBYTES_5, OpcodesCommon.OP_PUSHBYTES_6, OpcodesCommon.OP_PUSHBYTES_7, OpcodesCommon.OP_PUSHBYTES_8, OpcodesCommon.OP_PUSHBYTES_9, OpcodesCommon.OP_PUSHBYTES_10, OpcodesCommon.OP_PUSHBYTES_11, OpcodesCommon.OP_PUSHBYTES_12, OpcodesCommon.OP_PUSHBYTES_13, OpcodesCommon.OP_PUSHBYTES_14, OpcodesCommon.OP_PUSHBYTES_15, OpcodesCommon.OP_PUSHBYTES_16, OpcodesCommon.OP_PUSHBYTES_17, OpcodesCommon.OP_PUSHBYTES_18, OpcodesCommon.OP_PUSHBYTES_19, OpcodesCommon.OP_PUSHBYTES_20, OpcodesCommon.OP_PUSHBYTES_21, OpcodesCommon.OP_PUSHBYTES_22, OpcodesCommon.OP_PUSHBYTES_23, OpcodesCommon.OP_PUSHBYTES_24, OpcodesCommon.OP_PUSHBYTES_25, OpcodesCommon.OP_PUSHBYTES_26, OpcodesCommon.OP_PUSHBYTES_27, OpcodesCommon.OP_PUSHBYTES_28, OpcodesCommon.OP_PUSHBYTES_29, OpcodesCommon.OP_PUSHBYTES_30, OpcodesCommon.OP_PUSHBYTES_31, OpcodesCommon.OP_PUSHBYTES_32, OpcodesCommon.OP_PUSHBYTES_33, OpcodesCommon.OP_PUSHBYTES_34, OpcodesCommon.OP_PUSHBYTES_35, OpcodesCommon.OP_PUSHBYTES_36, OpcodesCommon.OP_PUSHBYTES_37, OpcodesCommon.OP_PUSHBYTES_38, OpcodesCommon.OP_PUSHBYTES_39, OpcodesCommon.OP_PUSHBYTES_40, OpcodesCommon.OP_PUSHBYTES_41, OpcodesCommon.OP_PUSHBYTES_42, OpcodesCommon.OP_PUSHBYTES_43, OpcodesCommon.OP_PUSHBYTES_44, OpcodesCommon.OP_PUSHBYTES_45, OpcodesCommon.OP_PUSHBYTES_46, OpcodesCommon.OP_PUSHBYTES_47, OpcodesCommon.OP_PUSHBYTES_48, OpcodesCommon.OP_PUSHBYTES_49, OpcodesCommon.OP_PUSHBYTES_50, OpcodesCommon.OP_PUSHBYTES_51, OpcodesCommon.OP_PUSHBYTES_52, OpcodesCommon.OP_PUSHBYTES_53, OpcodesCommon.OP_PUSHBYTES_54, OpcodesCommon.OP_PUSHBYTES_55, OpcodesCommon.OP_PUSHBYTES_56, OpcodesCommon.OP_PUSHBYTES_57, OpcodesCommon.OP_PUSHBYTES_58, OpcodesCommon.OP_PUSHBYTES_59, OpcodesCommon.OP_PUSHBYTES_60, OpcodesCommon.OP_PUSHBYTES_61, OpcodesCommon.OP_PUSHBYTES_62, OpcodesCommon.OP_PUSHBYTES_63, OpcodesCommon.OP_PUSHBYTES_64, OpcodesCommon.OP_PUSHBYTES_65, OpcodesCommon.OP_PUSHBYTES_66, OpcodesCommon.OP_PUSHBYTES_67, OpcodesCommon.OP_PUSHBYTES_68, OpcodesCommon.OP_PUSHBYTES_69, OpcodesCommon.OP_PUSHBYTES_70, OpcodesCommon.OP_PUSHBYTES_71, OpcodesCommon.OP_PUSHBYTES_72, OpcodesCommon.OP_PUSHBYTES_73, OpcodesCommon.OP_PUSHBYTES_74, OpcodesCommon.OP_PUSHBYTES_75];

const executionIsActive = state => state.executionStack.every(item => item);

const pushOperation = (flags, maximumPushSize = PushOperationConstants.maximumPushSize) => state => {
  const instruction = state.instructions[state.ip];
  return instruction.data.length > maximumPushSize ? applyError(AuthenticationErrorCommon.exceedsMaximumPush, state) : executionIsActive(state) ? flags.requireMinimalEncoding && !isMinimalDataPush(instruction.opcode, instruction.data) ? applyError(AuthenticationErrorCommon.nonMinimalPush, state) : pushToStack(state, instruction.data) : state;
};
const pushOperations = (flags, maximumPushSize = PushOperationConstants.maximumPushSize) => {
  const push = pushOperation(flags, maximumPushSize);
  return hex_range(PushOperationConstants.highestPushDataOpcode + 1).reduce((group, i) => ({ ...group,
    [i]: push
  }), {});
};
const pushNumberOpcodes = [OpcodesCommon.OP_1NEGATE, OpcodesCommon.OP_1, OpcodesCommon.OP_2, OpcodesCommon.OP_3, OpcodesCommon.OP_4, OpcodesCommon.OP_5, OpcodesCommon.OP_6, OpcodesCommon.OP_7, OpcodesCommon.OP_8, OpcodesCommon.OP_9, OpcodesCommon.OP_10, OpcodesCommon.OP_11, OpcodesCommon.OP_12, OpcodesCommon.OP_13, OpcodesCommon.OP_14, OpcodesCommon.OP_15, OpcodesCommon.OP_16];
const op1NegateValue = -1;
const pushNumberOperations = () => pushNumberOpcodes.map((opcode, i) => [opcode, [op1NegateValue, ...hex_range(PushOperationConstants.pushNumberOpcodes, 1)].map(BigInt).map(bigIntToScriptNumber)[i]]).reduce((group, pair) => ({ ...group,
  [pair[0]]: state => pushToStack(state, pair[1].slice())
}), {});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/splice.js



const opSize = () => state => useOneStackItem(state, (nextState, item) => pushToStack(nextState, item, bigIntToScriptNumber(BigInt(item.length))));
const spliceOperations = () => ({
  [OpcodesCommon.OP_SIZE]: opSize()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/stack.js




const opToAltStack = () => state => useOneStackItem(state, (nextState, item) => {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  nextState.alternateStack.push(item);
  return nextState;
});
const opFromAltStack = () => state => {
  // eslint-disable-next-line functional/immutable-data
  const item = state.alternateStack.pop();

  if (item === undefined) {
    return applyError(AuthenticationErrorCommon.emptyAlternateStack, state);
  }

  return pushToStack(state, item);
};
const op2Drop = () => state => useTwoStackItems(state, nextState => nextState);
const op2Dup = () => state => useTwoStackItems(state, (nextState, a, b) => pushToStack(nextState, a, b, a.slice(), b.slice()));
const op3Dup = () => state => useThreeStackItems(state, (nextState, a, b, c) => pushToStack(nextState, a, b, c, a.slice(), b.slice(), c.slice()));
const op2Over = () => state => useFourStackItems(state, (nextState, a, b, c, d) => pushToStack(nextState, a, b, c, d, a.slice(), b.slice()));
const op2Rot = () => state => useSixStackItems(state, (nextState, a, b, c, d, e, f) => pushToStack(nextState, c, d, e, f, a, b));
const op2Swap = () => state => useFourStackItems(state, (nextState, a, b, c, d) => pushToStack(nextState, c, d, a, b));
const opIfDup = () => state => useOneStackItem(state, (nextState, item) => pushToStack(nextState, ...(stackItemIsTruthy(item) ? [item, item.slice()] : [item])));
const opDepth = () => state => pushToStack(state, bigIntToScriptNumber(BigInt(state.stack.length)));
const opDrop = () => state => useOneStackItem(state, nextState => nextState);
const opDup = () => state => useOneStackItem(state, (nextState, item) => pushToStack(nextState, item, item.slice()));
const opNip = () => state => useTwoStackItems(state, (nextState, _, b) => pushToStack(nextState, b));
const opOver = () => state => useTwoStackItems(state, (nextState, a, b) => pushToStack(nextState, a, b, a.slice()));
const opPick = flags => state => useOneScriptNumber(state, (nextState, depth) => {
  const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];

  if (item === undefined) {
    return applyError(AuthenticationErrorCommon.invalidStackIndex, state);
  }

  return pushToStack(nextState, item.slice());
}, flags.requireMinimalEncoding);
const opRoll = flags => state => useOneScriptNumber(state, (nextState, depth) => {
  const index = nextState.stack.length - 1 - Number(depth);

  if (index < 0 || index > nextState.stack.length - 1) {
    return applyError(AuthenticationErrorCommon.invalidStackIndex, state);
  } // eslint-disable-next-line functional/immutable-data


  return pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
}, flags.requireMinimalEncoding);
const opRot = () => state => useThreeStackItems(state, (nextState, a, b, c) => pushToStack(nextState, b, c, a));
const opSwap = () => state => useTwoStackItems(state, (nextState, a, b) => pushToStack(nextState, b, a));
const opTuck = () => state => useTwoStackItems(state, (nextState, a, b) => pushToStack(nextState, b.slice(), a, b));
const stackOperations = flags => ({
  [OpcodesCommon.OP_TOALTSTACK]: opToAltStack(),
  [OpcodesCommon.OP_FROMALTSTACK]: opFromAltStack(),
  [OpcodesCommon.OP_2DROP]: op2Drop(),
  [OpcodesCommon.OP_2DUP]: op2Dup(),
  [OpcodesCommon.OP_3DUP]: op3Dup(),
  [OpcodesCommon.OP_2OVER]: op2Over(),
  [OpcodesCommon.OP_2ROT]: op2Rot(),
  [OpcodesCommon.OP_2SWAP]: op2Swap(),
  [OpcodesCommon.OP_IFDUP]: opIfDup(),
  [OpcodesCommon.OP_DEPTH]: opDepth(),
  [OpcodesCommon.OP_DROP]: opDrop(),
  [OpcodesCommon.OP_DUP]: opDup(),
  [OpcodesCommon.OP_NIP]: opNip(),
  [OpcodesCommon.OP_OVER]: opOver(),
  [OpcodesCommon.OP_PICK]: opPick(flags),
  [OpcodesCommon.OP_ROLL]: opRoll(flags),
  [OpcodesCommon.OP_ROT]: opRot(),
  [OpcodesCommon.OP_SWAP]: opSwap(),
  [OpcodesCommon.OP_TUCK]: opTuck()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/time.js



var Bits;

(function (Bits) {
  Bits[Bits["sequenceLocktimeDisableFlag"] = 31] = "sequenceLocktimeDisableFlag";
  Bits[Bits["sequenceLocktimeTypeFlag"] = 22] = "sequenceLocktimeTypeFlag";
})(Bits || (Bits = {}));

var time_Constants;

(function (Constants) {
  Constants[Constants["LocktimeScriptNumberByteLength"] = 5] = "LocktimeScriptNumberByteLength";
  Constants[Constants["LocktimeThreshold"] = 500000000] = "LocktimeThreshold";
  Constants[Constants["maximumSequenceNumber"] = 4294967295] = "maximumSequenceNumber";
  Constants[Constants["sequenceLocktimeTransactionVersionMinimum"] = 2] = "sequenceLocktimeTransactionVersionMinimum"; // eslint-disable-next-line no-bitwise

  Constants[Constants["sequenceLocktimeDisableFlag"] = 2147483648] = "sequenceLocktimeDisableFlag"; // eslint-disable-next-line no-bitwise

  Constants[Constants["sequenceLocktimeTypeFlag"] = 4194304] = "sequenceLocktimeTypeFlag";
  Constants[Constants["sequenceGranularity"] = 9] = "sequenceGranularity";
  Constants[Constants["sequenceLocktimeMask"] = 65535] = "sequenceLocktimeMask";
})(time_Constants || (time_Constants = {}));

const readLocktime = (state, operation, flags) => {
  const item = state.stack[state.stack.length - 1];

  if (item === undefined) {
    return applyError(AuthenticationErrorCommon.emptyStack, state);
  }

  const parsedLocktime = parseBytesAsScriptNumber(item, flags.requireMinimalEncoding, time_Constants.LocktimeScriptNumberByteLength);

  if (isScriptNumberError(parsedLocktime)) {
    return applyError(AuthenticationErrorCommon.invalidScriptNumber, state);
  }

  const locktime = Number(parsedLocktime);

  if (locktime < 0) {
    return applyError(AuthenticationErrorCommon.negativeLocktime, state);
  }

  return operation(state, locktime);
};

const locktimeTypesAreCompatible = (locktime, requiredLocktime) => locktime < time_Constants.LocktimeThreshold && requiredLocktime < time_Constants.LocktimeThreshold || locktime >= time_Constants.LocktimeThreshold && requiredLocktime >= time_Constants.LocktimeThreshold;

const opCheckLockTimeVerify = flags => state => readLocktime(state, (nextState, requiredLocktime) => {
  if (!locktimeTypesAreCompatible(nextState.locktime, requiredLocktime)) {
    return applyError(AuthenticationErrorCommon.incompatibleLocktimeType, nextState);
  }

  if (requiredLocktime > nextState.locktime) {
    return applyError(AuthenticationErrorCommon.unsatisfiedLocktime, nextState);
  }

  if (nextState.sequenceNumber === time_Constants.maximumSequenceNumber) {
    return applyError(AuthenticationErrorCommon.locktimeDisabled, nextState);
  }

  return nextState;
}, flags); // eslint-disable-next-line no-bitwise

const includesFlag = (value, flag) => (value & flag) !== 0;

const opCheckSequenceVerify = flags => state => readLocktime(state, // eslint-disable-next-line complexity
(nextState, requiredSequence) => {
  const sequenceLocktimeDisabled = includesFlag(requiredSequence, time_Constants.sequenceLocktimeDisableFlag);

  if (sequenceLocktimeDisabled) {
    return nextState;
  }

  if (nextState.version < time_Constants.sequenceLocktimeTransactionVersionMinimum) {
    return applyError(AuthenticationErrorCommon.checkSequenceUnavailable, nextState);
  }

  if (includesFlag(nextState.sequenceNumber, time_Constants.sequenceLocktimeDisableFlag)) {
    return applyError(AuthenticationErrorCommon.unmatchedSequenceDisable, nextState);
  }

  if (includesFlag(requiredSequence, time_Constants.sequenceLocktimeTypeFlag) !== includesFlag(nextState.sequenceNumber, time_Constants.sequenceLocktimeTypeFlag)) {
    return applyError(AuthenticationErrorCommon.incompatibleSequenceType, nextState);
  }

  if ( // eslint-disable-next-line no-bitwise
  (requiredSequence & time_Constants.sequenceLocktimeMask) > ( // eslint-disable-next-line no-bitwise
  nextState.sequenceNumber & time_Constants.sequenceLocktimeMask)) {
    return applyError(AuthenticationErrorCommon.unsatisfiedSequenceNumber, nextState);
  }

  return nextState;
}, flags);
const timeOperations = flags => ({
  [OpcodesCommon.OP_CHECKLOCKTIMEVERIFY]: opCheckLockTimeVerify(flags),
  [OpcodesCommon.OP_CHECKSEQUENCEVERIFY]: opCheckSequenceVerify(flags)
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/descriptions.js
var OpcodeDescriptionsCommon;

(function (OpcodeDescriptionsCommon) {
  OpcodeDescriptionsCommon["OP_0"] = "Push the Script Number 0 onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsCommon["OP_1NEGATE"] = "Push the Script Number -1 onto the stack.";
  OpcodeDescriptionsCommon["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_1"] = "Push the Script Number 1 onto the stack.";
  OpcodeDescriptionsCommon["OP_2"] = "Push the Script Number 2 onto the stack.";
  OpcodeDescriptionsCommon["OP_3"] = "Push the Script Number 3 onto the stack.";
  OpcodeDescriptionsCommon["OP_4"] = "Push the Script Number 4 onto the stack.";
  OpcodeDescriptionsCommon["OP_5"] = "Push the Script Number 5 onto the stack.";
  OpcodeDescriptionsCommon["OP_6"] = "Push the Script Number 6 onto the stack.";
  OpcodeDescriptionsCommon["OP_7"] = "Push the Script Number 7 onto the stack.";
  OpcodeDescriptionsCommon["OP_8"] = "Push the Script Number 8 onto the stack.";
  OpcodeDescriptionsCommon["OP_9"] = "Push the Script Number 9 onto the stack.";
  OpcodeDescriptionsCommon["OP_10"] = "Push the Script Number 10 onto the stack.";
  OpcodeDescriptionsCommon["OP_11"] = "Push the Script Number 11 onto the stack.";
  OpcodeDescriptionsCommon["OP_12"] = "Push the Script Number 12 onto the stack.";
  OpcodeDescriptionsCommon["OP_13"] = "Push the Script Number 13 onto the stack.";
  OpcodeDescriptionsCommon["OP_14"] = "Push the Script Number 14 onto the stack.";
  OpcodeDescriptionsCommon["OP_15"] = "Push the Script Number 15 onto the stack.";
  OpcodeDescriptionsCommon["OP_16"] = "Push the Script Number 16 onto the stack.";
  OpcodeDescriptionsCommon["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsCommon["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until the matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsCommon["OP_NOTIF"] = "Evaluate OP_NOT followed by OP_IF.";
  OpcodeDescriptionsCommon["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsCommon["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsCommon["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsCommon["OP_ENDIF"] = "End the current OP_IF ... OP_ENDIF block.";
  OpcodeDescriptionsCommon["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsCommon["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsCommon["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsCommon["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsCommon["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsCommon["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsCommon["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsCommon["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsCommon["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsCommon["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsCommon["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsCommon["OP_DEPTH"] = "Push the current number of stack items as a Script Number.";
  OpcodeDescriptionsCommon["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsCommon["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsCommon["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsCommon["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsCommon["OP_PICK"] = "Pop the top item from the stack as a Script Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsCommon["OP_ROLL"] = "Pop the top item from the stack as a Script Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsCommon["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsCommon["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsCommon["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsCommon["OP_CAT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this concatenated two stack items.)";
  OpcodeDescriptionsCommon["OP_SUBSTR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section of a stack item.)";
  OpcodeDescriptionsCommon["OP_LEFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the left of a point in a stack item.)";
  OpcodeDescriptionsCommon["OP_RIGHT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the right of a point in a stack item.)";
  OpcodeDescriptionsCommon["OP_SIZE"] = "Push the byte-length of the top stack item as a Script Number.";
  OpcodeDescriptionsCommon["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsCommon["OP_AND"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean AND on each bit in two stack items.)";
  OpcodeDescriptionsCommon["OP_OR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean OR on each bit in two stack items.)";
  OpcodeDescriptionsCommon["OP_XOR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean XOR on each bit in two stack items.)";
  OpcodeDescriptionsCommon["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a Script Number 1, otherwise push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsCommon["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_1ADD"] = "Pop the top item from the stack as a Script Number, add 1, then push the result.";
  OpcodeDescriptionsCommon["OP_1SUB"] = "Pop the top item from the stack as a Script Number, subtract 1, then push the result.";
  OpcodeDescriptionsCommon["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a Script Number by 2.)";
  OpcodeDescriptionsCommon["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a Script Number by 2.)";
  OpcodeDescriptionsCommon["OP_NEGATE"] = "Pop the top item from the stack as a Script Number, negate it, then push the result.";
  OpcodeDescriptionsCommon["OP_ABS"] = "Pop the top item from the stack as a Script Number, take its absolute value, then push the result.";
  OpcodeDescriptionsCommon["OP_NOT"] = "Pop the top item from the stack as a Script Number. If its value is 0, push a Script Number 1, otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_0NOTEQUAL"] = "Pop the top item from the stack as a Script Number. If its value is not 0, push a Script Number 1, otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_ADD"] = "Pop the top two items from the stack as Script Numbers. Add them, then push the result.";
  OpcodeDescriptionsCommon["OP_SUB"] = "Pop the top two items from the stack as Script Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsCommon["OP_MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied two Script Numbers.)";
  OpcodeDescriptionsCommon["OP_DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided two Script Numbers.)";
  OpcodeDescriptionsCommon["OP_MOD"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned the remainder after dividing one Script Number by another.)";
  OpcodeDescriptionsCommon["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsCommon["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsCommon["OP_BOOLAND"] = "Pop the top two items from the stack as Script Numbers. If neither value is a Script Number 0, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_BOOLOR"] = "Pop the top two items from the stack as Script Numbers. If either value is a Script Number 1, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_NUMEQUAL"] = "Pop the top two items from the stack as Script Numbers. If the values are equal, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as Script Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsCommon["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as Script Numbers. If the values are not equal, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_LESSTHAN"] = "Pop the top two items from the stack as Script Numbers. If the second item is less than top item, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_GREATERTHAN"] = "Pop the top two items from the stack as Script Numbers. If the second item is greater than top item, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as Script Numbers. If the second item is less than or equal to the top item, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as Script Numbers. If the second item is greater than or equal to the top item, push a Script Number 1. Otherwise, push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_MIN"] = "Pop the top two items from the stack as Script Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsCommon["OP_MAX"] = "Pop the top two items from the stack as Script Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsCommon["OP_WITHIN"] = "Pop the top three items from the stack as Script Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a Script Number 1. Otherwise, push a Script Number 0. (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsCommon["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsCommon["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsCommon["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsCommon["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsCommon["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsCommon["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsCommon["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a Script Number 1, otherwise push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsCommon["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the Script Number of public keys, then pop each of those public keys. Next, pop the Script Number of required signatures, then pop each of those signatures. Finally, pop a final Script Number which must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a Script Number 1, otherwise push a Script Number 0.";
  OpcodeDescriptionsCommon["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the Script Number of public keys, then pop each of those public keys. Next, pop the Script Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final Script Number which must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsCommon["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a Script Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled by a maximized sequence number, error.";
  OpcodeDescriptionsCommon["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after a relative block time or height has passed since the creation of the output being spent: read the top item on the stack as a Script Number (without removing it), and compare it to the input's sequence number. If the required locktime has not passed, or if locktime has been disabled by a flag or the transaction version, error.";
  OpcodeDescriptionsCommon["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsCommon["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
})(OpcodeDescriptionsCommon || (OpcodeDescriptionsCommon = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/common.js





























var ConsensusCommon;

(function (ConsensusCommon) {
  /**
   * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  ConsensusCommon[ConsensusCommon["maximumScriptNumberLength"] = 4] = "maximumScriptNumberLength";
  /**
   * A.K.A. `MAX_OPS_PER_SCRIPT`
   */

  ConsensusCommon[ConsensusCommon["maximumOperationCount"] = 201] = "maximumOperationCount";
  /**
   * A.K.A. `MAX_SCRIPT_SIZE`
   */

  ConsensusCommon[ConsensusCommon["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
  /**
   * A.K.A. `MAX_STACK_SIZE`
   */

  ConsensusCommon[ConsensusCommon["maximumStackDepth"] = 1000] = "maximumStackDepth";
})(ConsensusCommon || (ConsensusCommon = {}));

const undefinedOperation = () => ({
  undefined: conditionallyEvaluate(state => applyError(AuthenticationErrorCommon.unknownOpcode, state))
});
const checkLimitsCommon = operation => state => {
  const nextState = operation(state);
  return nextState.stack.length + nextState.alternateStack.length > ConsensusCommon.maximumStackDepth ? applyError(AuthenticationErrorCommon.exceededMaximumStackDepth, nextState) : nextState.operationCount > ConsensusCommon.maximumOperationCount ? applyError(AuthenticationErrorCommon.exceededMaximumOperationCount, nextState) : nextState;
};
const commonOperations = (sha1, sha256, ripemd160, secp256k1, flags) => {
  const unconditionalOperations = { ...disabledOperations(),
    ...pushOperations(flags),
    ...mapOverOperations(unconditionalFlowControlOperations(flags), incrementOperationCount)
  };
  const conditionalOperations = mapOverOperations({ ...pushNumberOperations(),
    [OpcodesCommon.OP_RESERVED]: reservedOperation()
  }, conditionallyEvaluate);
  const incrementingOperations = mapOverOperations({ ...arithmeticOperations(flags),
    ...bitwiseOperations(),
    ...cryptoOperations(sha1, sha256, ripemd160, secp256k1, flags),
    ...conditionalFlowControlOperations(),
    ...stackOperations(flags),
    ...spliceOperations(),
    ...timeOperations(flags),
    ...nonOperations(flags)
  }, conditionallyEvaluate, incrementOperationCount);
  return mapOverOperations({ ...unconditionalOperations,
    ...incrementingOperations,
    ...conditionalOperations
  }, checkLimitsCommon);
};
const cloneStack = stack => stack.reduce((newStack, element) => {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  newStack.push(element.slice());
  return newStack;
}, []);
const createAuthenticationProgramInternalStateCommon = (instructions, stack = []) => ({
  alternateStack: [],
  executionStack: [],
  instructions,
  ip: 0,
  lastCodeSeparator: -1,
  operationCount: 0,
  signatureOperationsCount: 0,
  stack
});
const createAuthenticationProgramExternalStateCommon = program => ({
  correspondingOutput: program.inputIndex < program.spendingTransaction.outputs.length ? serializeOutput(program.spendingTransaction.outputs[program.inputIndex]) : undefined,
  locktime: program.spendingTransaction.locktime,
  outpointIndex: program.spendingTransaction.inputs[program.inputIndex].outpointIndex,
  outpointTransactionHash: program.spendingTransaction.inputs[program.inputIndex].outpointTransactionHash,
  outputValue: program.sourceOutput.satoshis,
  sequenceNumber: program.spendingTransaction.inputs[program.inputIndex].sequenceNumber,
  transactionOutpoints: serializeOutpoints(program.spendingTransaction.inputs),
  transactionOutputs: serializeOutputsForSigning(program.spendingTransaction.outputs),
  transactionSequenceNumbers: serializeSequenceNumbers(program.spendingTransaction.inputs),
  version: program.spendingTransaction.version
});
const createAuthenticationProgramStateCommon = (instructions, stack, externalState) => ({ ...createAuthenticationProgramInternalStateCommon(instructions, stack),
  ...externalState
});
const cloneAuthenticationProgramStateCommon = state => ({ ...(state.error === undefined ? {} : {
    error: state.error
  }),
  alternateStack: state.alternateStack.slice(),
  correspondingOutput: state.correspondingOutput,
  executionStack: state.executionStack.slice(),
  instructions: state.instructions.slice(),
  ip: state.ip,
  lastCodeSeparator: state.lastCodeSeparator,
  locktime: state.locktime,
  operationCount: state.operationCount,
  outpointIndex: state.outpointIndex,
  outpointTransactionHash: state.outpointTransactionHash.slice(),
  outputValue: state.outputValue,
  sequenceNumber: state.sequenceNumber,
  signatureOperationsCount: state.signatureOperationsCount,
  stack: state.stack.slice(),
  transactionOutpoints: state.transactionOutpoints,
  transactionOutputs: state.transactionOutputs,
  transactionSequenceNumbers: state.transactionSequenceNumbers,
  version: state.version
});
/**
 * This is a meaningless but complete `CommonExternalProgramState`, useful for
 * testing and debugging.
 */

const createAuthenticationProgramExternalStateCommonEmpty = () => ({
  correspondingOutput: Uint8Array.of(1
  /* correspondingOutput */
  ),
  locktime: 0,
  outpointIndex: 0,
  outpointTransactionHash: new Uint8Array(32
  /* length */
  ).fill(5
  /* outpointTransactionHash */
  ),
  outputValue: BigInt(0),
  sequenceNumber: 0,
  transactionOutpoints: Uint8Array.of(2
  /* transactionOutpoints */
  ),
  transactionOutputs: Uint8Array.of(3
  /* transactionOutputs */
  ),
  transactionSequenceNumbers: Uint8Array.of(4
  /* transactionSequenceNumbers */
  ),
  version: 0
});
/**
 * Create an "empty" CommonProgramState, suitable for testing a VM/compiler.
 */

const createAuthenticationProgramStateCommonEmpty = (instructions, stack = []) => ({ ...createAuthenticationProgramInternalStateCommon(instructions, stack),
  ...createAuthenticationProgramExternalStateCommonEmpty()
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/common/combinators.js


const incrementOperationCount = operation => state => {
  const nextState = operation(state); // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

  nextState.operationCount += 1;
  return nextState;
};
const conditionallyEvaluate = operation => state => state.executionStack.every(item => item) ? operation(state) : state;
/**
 * Map a function over each operation in an `InstructionSet.operations` object,
 * assigning the result to the same `opcode` in the resulting object.
 * @param operations an operations map from an `InstructionSet`
 * @param combinator a function to apply to each operation
 */

const mapOverOperations = (operations, ...combinators) => Object.keys(operations).reduce((result, operation) => ({ ...result,
  [operation]: combinators.reduce((op, combinator) => combinator(op), operations[parseInt(operation, 10)])
}), {});
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */

const useOneStackItem = (state, operation) => {
  // eslint-disable-next-line functional/immutable-data
  const item = state.stack.pop();

  if (item === undefined) {
    return applyError(AuthenticationErrorCommon.emptyStack, state);
  }

  return operation(state, item);
};
const useTwoStackItems = (state, operation) => useOneStackItem(state, (nextState, valueTwo) => useOneStackItem(nextState, (lastState, valueTop) => operation(lastState, valueTop, valueTwo)));
const useThreeStackItems = (state, operation) => useOneStackItem(state, (nextState, valueThree) => useTwoStackItems(nextState, (lastState, valueTop, valueTwo) => operation(lastState, valueTop, valueTwo, valueThree)));
const useFourStackItems = (state, operation) => useTwoStackItems(state, (nextState, valueThree, valueFour) => useTwoStackItems(nextState, (lastState, valueTop, valueTwo) => operation(lastState, valueTop, valueTwo, valueThree, valueFour)));
const useSixStackItems = (state, operation) => useFourStackItems(state, (nextState, valueThree, valueFour, valueFive, valueSix) => useTwoStackItems(nextState, (lastState, valueTop, valueTwo) => operation(lastState, valueTop, valueTwo, valueThree, valueFour, valueFive, valueSix)));
const combinators_normalMaximumScriptNumberByteLength = 4;
const useOneScriptNumber = (state, operation, requireMinimalEncoding, maximumScriptNumberByteLength = combinators_normalMaximumScriptNumberByteLength) => useOneStackItem(state, (nextState, item) => {
  const value = parseBytesAsScriptNumber(item, requireMinimalEncoding, maximumScriptNumberByteLength);

  if (isScriptNumberError(value)) {
    return applyError(AuthenticationErrorCommon.invalidScriptNumber, state);
  }

  return operation(nextState, value);
});
const useTwoScriptNumbers = (state, operation, requireMinimalEncoding, maximumScriptNumberByteLength = combinators_normalMaximumScriptNumberByteLength) => useOneScriptNumber(state, (nextState, secondValue) => useOneScriptNumber(nextState, (lastState, firstValue) => operation(lastState, firstValue, secondValue), requireMinimalEncoding, maximumScriptNumberByteLength), requireMinimalEncoding, maximumScriptNumberByteLength);
const useThreeScriptNumbers = (state, operation, requireMinimalEncoding, maximumScriptNumberByteLength = combinators_normalMaximumScriptNumberByteLength) => useTwoScriptNumbers(state, (nextState, secondValue, thirdValue) => useOneScriptNumber(nextState, (lastState, firstValue) => operation(lastState, firstValue, secondValue, thirdValue), requireMinimalEncoding, maximumScriptNumberByteLength), requireMinimalEncoding, maximumScriptNumberByteLength);
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state the state to update and return
 * @param data the value to push to the stack
 */

const pushToStack = (state, ...data) => {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.stack.push(...data);
  return state;
}; // TODO: if firstOperation errors, secondOperation might overwrite the error

const combineOperations = (firstOperation, secondOperation) => state => secondOperation(firstOperation(state));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-errors.js
var AuthenticationErrorBCH;

(function (AuthenticationErrorBCH) {
  AuthenticationErrorBCH["exceededMaximumOperationCount"] = "Program exceeded the maximum operation count (201 operations).";
  AuthenticationErrorBCH["exceededMaximumStackItemLength"] = "Program attempted to push a stack item which exceeded the maximum stack item length (520 bytes).";
  AuthenticationErrorBCH["exceededMaximumScriptNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence which cannot be encoded within the maximum Script Number length (4 bytes).";
  AuthenticationErrorBCH["divisionByZero"] = "Program attempted to divide a number by zero.";
  AuthenticationErrorBCH["insufficientLength"] = "Program called an OP_NUM2BIN operation with an insufficient byte length to re-encode the provided number.";
  AuthenticationErrorBCH["invalidSplitIndex"] = "Program called an OP_SPLIT operation with an invalid index.";
  AuthenticationErrorBCH["malformedP2shBytecode"] = "Redeem bytecode was malformed prior to P2SH evaluation.";
  AuthenticationErrorBCH["mismatchedBitwiseOperandLength"] = "Program attempted a bitwise operation on operands of different lengths.";
  AuthenticationErrorBCH["requiresPushOnly"] = "Unlocking bytecode may contain only push operations.";
})(AuthenticationErrorBCH || (AuthenticationErrorBCH = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-opcodes.js
var OpcodesBCH;

(function (OpcodesBCH) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesBCH[OpcodesBCH["OP_0"] = 0] = "OP_0";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCH[OpcodesBCH["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCH[OpcodesBCH["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCH[OpcodesBCH["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCH[OpcodesBCH["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCH[OpcodesBCH["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCH[OpcodesBCH["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */

  OpcodesBCH[OpcodesBCH["OP_1"] = 81] = "OP_1";
  OpcodesBCH[OpcodesBCH["OP_2"] = 82] = "OP_2";
  OpcodesBCH[OpcodesBCH["OP_3"] = 83] = "OP_3";
  OpcodesBCH[OpcodesBCH["OP_4"] = 84] = "OP_4";
  OpcodesBCH[OpcodesBCH["OP_5"] = 85] = "OP_5";
  OpcodesBCH[OpcodesBCH["OP_6"] = 86] = "OP_6";
  OpcodesBCH[OpcodesBCH["OP_7"] = 87] = "OP_7";
  OpcodesBCH[OpcodesBCH["OP_8"] = 88] = "OP_8";
  OpcodesBCH[OpcodesBCH["OP_9"] = 89] = "OP_9";
  OpcodesBCH[OpcodesBCH["OP_10"] = 90] = "OP_10";
  OpcodesBCH[OpcodesBCH["OP_11"] = 91] = "OP_11";
  OpcodesBCH[OpcodesBCH["OP_12"] = 92] = "OP_12";
  OpcodesBCH[OpcodesBCH["OP_13"] = 93] = "OP_13";
  OpcodesBCH[OpcodesBCH["OP_14"] = 94] = "OP_14";
  OpcodesBCH[OpcodesBCH["OP_15"] = 95] = "OP_15";
  OpcodesBCH[OpcodesBCH["OP_16"] = 96] = "OP_16";
  OpcodesBCH[OpcodesBCH["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCH[OpcodesBCH["OP_VER"] = 98] = "OP_VER";
  OpcodesBCH[OpcodesBCH["OP_IF"] = 99] = "OP_IF";
  OpcodesBCH[OpcodesBCH["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCH[OpcodesBCH["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCH[OpcodesBCH["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCH[OpcodesBCH["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCH[OpcodesBCH["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCH[OpcodesBCH["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCH[OpcodesBCH["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCH[OpcodesBCH["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCH[OpcodesBCH["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCH[OpcodesBCH["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCH[OpcodesBCH["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCH[OpcodesBCH["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCH[OpcodesBCH["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCH[OpcodesBCH["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCH[OpcodesBCH["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCH[OpcodesBCH["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCH[OpcodesBCH["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCH[OpcodesBCH["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCH[OpcodesBCH["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCH[OpcodesBCH["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCH[OpcodesBCH["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCH[OpcodesBCH["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCH[OpcodesBCH["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCH[OpcodesBCH["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCH[OpcodesBCH["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCH[OpcodesBCH["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCH[OpcodesBCH["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCH[OpcodesBCH["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCH[OpcodesBCH["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCH[OpcodesBCH["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCH[OpcodesBCH["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCH[OpcodesBCH["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCH[OpcodesBCH["OP_AND"] = 132] = "OP_AND";
  OpcodesBCH[OpcodesBCH["OP_OR"] = 133] = "OP_OR";
  OpcodesBCH[OpcodesBCH["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCH[OpcodesBCH["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCH[OpcodesBCH["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCH[OpcodesBCH["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCH[OpcodesBCH["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCH[OpcodesBCH["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCH[OpcodesBCH["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCH[OpcodesBCH["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCH[OpcodesBCH["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCH[OpcodesBCH["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCH[OpcodesBCH["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCH[OpcodesBCH["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCH[OpcodesBCH["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCH[OpcodesBCH["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCH[OpcodesBCH["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCH[OpcodesBCH["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCH[OpcodesBCH["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCH[OpcodesBCH["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCH[OpcodesBCH["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCH[OpcodesBCH["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCH[OpcodesBCH["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCH[OpcodesBCH["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCH[OpcodesBCH["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCH[OpcodesBCH["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCH[OpcodesBCH["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCH[OpcodesBCH["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCH[OpcodesBCH["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCH[OpcodesBCH["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCH[OpcodesBCH["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCH[OpcodesBCH["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCH[OpcodesBCH["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCH[OpcodesBCH["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCH[OpcodesBCH["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCH[OpcodesBCH["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCH[OpcodesBCH["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCH[OpcodesBCH["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCH[OpcodesBCH["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCH[OpcodesBCH["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCH[OpcodesBCH["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCH[OpcodesBCH["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCH[OpcodesBCH["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCH[OpcodesBCH["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCH[OpcodesBCH["OP_NOP1"] = 176] = "OP_NOP1";
  /**
   * Previously `OP_NOP2`
   */

  OpcodesBCH[OpcodesBCH["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  /**
   * Previously `OP_NOP2`
   */

  OpcodesBCH[OpcodesBCH["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCH[OpcodesBCH["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCH[OpcodesBCH["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCH[OpcodesBCH["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCH[OpcodesBCH["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCH[OpcodesBCH["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCH[OpcodesBCH["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCH[OpcodesBCH["OP_NOP10"] = 185] = "OP_NOP10";
  /**
   * Previously `OP_UNKNOWN186`
   */

  OpcodesBCH[OpcodesBCH["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  /**
   * Previously `OP_UNKNOWN187`
   */

  OpcodesBCH[OpcodesBCH["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  /**
   * A.K.A. `FIRST_UNDEFINED_OP_VALUE`
   */

  OpcodesBCH[OpcodesBCH["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  /**
   * A.K.A. `OP_PREFIX_BEGIN`
   */

  OpcodesBCH[OpcodesBCH["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  /**
   * A.K.A. `OP_PREFIX_END`
   */

  OpcodesBCH[OpcodesBCH["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCH[OpcodesBCH["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH || (OpcodesBCH = {}));

var OpcodeAlternateNamesBCH;

(function (OpcodeAlternateNamesBCH) {
  /**
   * A.K.A. `OP_0`
   */
  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_FALSE"] = 0] = "OP_FALSE";
  /**
   * A.K.A. `OP_0`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PUSHBYTES_0"] = 0] = "OP_PUSHBYTES_0";
  /**
   * A.K.A. `OP_1`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_TRUE"] = 81] = "OP_TRUE";
  /**
   * A.K.A. `OP_CHECKLOCKTIMEVERIFY`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_NOP2"] = 177] = "OP_NOP2";
  /**
   * A.K.A. `OP_CHECKSEQUENCEVERIFY`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_NOP3"] = 178] = "OP_NOP3";
  /**
   * A.K.A. `OP_CHECKDATASIG`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
  /**
   * A.K.A. `OP_CHECKDATASIGVERIFY`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
  /**
   * A.K.A. `OP_UNKNOWN188`
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["FIRST_UNDEFINED_OP_VALUE"] = 188] = "FIRST_UNDEFINED_OP_VALUE";
  /**
   * A.K.A. `OP_UNKNOWN240`. Some implementations have reserved opcodes
   * `0xf0` through `0xf7` for a future range of multi-byte opcodes, though none
   * are yet available on the network.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PREFIX_BEGIN"] = 240] = "OP_PREFIX_BEGIN";
  /**
   * A.K.A. `OP_UNKNOWN247`. Some implementations have reserved opcodes
   * `0xf0` through `0xf7` for a future range of multi-byte opcodes, though none
   * are yet available on the network.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PREFIX_END"] = 247] = "OP_PREFIX_END";
  /**
   * `OP_SMALLINTEGER` is used internally for template matching in the C++
   * implementation. When found on the network, it is `OP_UNKNOWN250`.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_SMALLINTEGER"] = 250] = "OP_SMALLINTEGER";
  /**
   * `OP_PUBKEYS` is used internally for template matching in the C++
   * implementation. When found on the network, it is `OP_UNKNOWN251`.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PUBKEYS"] = 251] = "OP_PUBKEYS";
  /**
   * `OP_PUBKEYHASH` is used internally for template matching in the C++
   * implementation. When found on the network, it is `OP_UNKNOWN253`.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
  /**
   * `OP_PUBKEY` is used internally for template matching in the C++
   * implementation. When found on the network, it is `OP_UNKNOWN254`.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_PUBKEY"] = 254] = "OP_PUBKEY";
  /**
   * `OP_INVALIDOPCODE` is described as such for testing in the C++
   * implementation. When found on the network, it is `OP_UNKNOWN255`.
   */

  OpcodeAlternateNamesBCH[OpcodeAlternateNamesBCH["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OpcodeAlternateNamesBCH || (OpcodeAlternateNamesBCH = {}));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-operations.js










const opCat = () => state => useTwoStackItems(state, (nextState, a, b) => a.length + b.length > ConsensusCommon.maximumStackItemLength ? applyError(AuthenticationErrorBCH.exceededMaximumStackItemLength, nextState) : pushToStack(nextState, flattenBinArray([a, b])));
const opSplit = flags => state => useOneScriptNumber(state, (nextState, value) => {
  const index = Number(value);
  return useOneStackItem(nextState, (finalState, item) => index < 0 || index > item.length ? applyError(AuthenticationErrorBCH.invalidSplitIndex, finalState) : pushToStack(finalState, item.slice(0, index), item.slice(index)));
}, flags.requireMinimalEncoding);
var bch_operations_Constants;

(function (Constants) {
  Constants[Constants["positiveSign"] = 0] = "positiveSign";
  Constants[Constants["negativeSign"] = 128] = "negativeSign";
})(bch_operations_Constants || (bch_operations_Constants = {}));

const padMinimallyEncodedScriptNumber = (scriptNumber, length) => {
  // eslint-disable-next-line functional/no-let
  let signBit = bch_operations_Constants.positiveSign; // eslint-disable-next-line functional/no-conditional-statement

  if (scriptNumber.length > 0) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise
    signBit = scriptNumber[scriptNumber.length - 1] & bch_operations_Constants.negativeSign; // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data

    scriptNumber[scriptNumber.length - 1] &= bch_operations_Constants.negativeSign - 1;
  }

  const result = Array.from(scriptNumber); // eslint-disable-next-line functional/no-loop-statement

  while (result.length < length - 1) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(0);
  } // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data


  result.push(signBit);
  return Uint8Array.from(result);
};
const opNum2Bin = () => state => useOneScriptNumber(state, (nextState, value) => {
  const targetLength = Number(value);
  return targetLength > ConsensusCommon.maximumStackItemLength ? applyError(AuthenticationErrorBCH.exceededMaximumStackItemLength, nextState) : useOneScriptNumber(nextState, (finalState, target) => {
    const minimallyEncoded = bigIntToScriptNumber(target);
    return minimallyEncoded.length > targetLength ? applyError(AuthenticationErrorBCH.insufficientLength, finalState) : minimallyEncoded.length === targetLength ? pushToStack(finalState, minimallyEncoded) : pushToStack(finalState, padMinimallyEncodedScriptNumber(minimallyEncoded, targetLength));
  }, false, ConsensusCommon.maximumStackItemLength);
}, true);
const opBin2Num = () => state => useOneScriptNumber(state, (nextState, target) => {
  const minimallyEncoded = bigIntToScriptNumber(target);
  return minimallyEncoded.length > ConsensusCommon.maximumScriptNumberLength ? applyError(AuthenticationErrorBCH.exceededMaximumScriptNumberLength, nextState) : pushToStack(nextState, minimallyEncoded);
}, false, ConsensusCommon.maximumStackItemLength);
const bitwiseOperation = combine => state => useTwoStackItems(state, (nextState, a, b) => a.length === b.length ? pushToStack(nextState, combine(a, b)) : applyError(AuthenticationErrorBCH.mismatchedBitwiseOperandLength, nextState));
const opAnd = () => bitwiseOperation((a, b) => a.map((v, i) => v & b[i]));
const opOr = () => bitwiseOperation((a, b) => a.map((v, i) => v | b[i]));
const opXor = () => bitwiseOperation((a, b) => a.map((v, i) => v ^ b[i]));
const opDiv = flags => state => useTwoScriptNumbers(state, (nextState, a, b) => b === BigInt(0) ? applyError(AuthenticationErrorBCH.divisionByZero, nextState) : pushToStack(nextState, bigIntToScriptNumber(a / b)), flags.requireMinimalEncoding);
const opMod = flags => state => useTwoScriptNumbers(state, (nextState, a, b) => b === BigInt(0) ? applyError(AuthenticationErrorBCH.divisionByZero, nextState) : pushToStack(nextState, bigIntToScriptNumber(a % b)), flags.requireMinimalEncoding);
/**
 * Validate the encoding of a raw signature â a signature without a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param signature the raw signature
 */

const isValidSignatureEncodingBCHRaw = signature => signature.length === 0 || signature.length === ConsensusBCH.schnorrSignatureLength || isValidSignatureEncodingDER(signature);
const opCheckDataSig = (sha256, secp256k1) => state => // eslint-disable-next-line complexity
useThreeStackItems(state, (nextState, signature, message, publicKey) => {
  if (!isValidSignatureEncodingBCHRaw(signature)) {
    return applyError(AuthenticationErrorCommon.invalidSignatureEncoding, nextState);
  }

  if (!isValidPublicKeyEncoding(publicKey)) {
    return applyError(AuthenticationErrorCommon.invalidPublicKeyEncoding, nextState);
  }

  const digest = sha256.hash(message);
  const useSchnorr = signature.length === ConsensusBCH.schnorrSignatureLength;
  const success = useSchnorr ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
  return !success && signature.length !== 0 ? applyError(AuthenticationErrorCommon.nonNullSignatureFailure, nextState) : pushToStack(nextState, booleanToScriptNumber(success));
});
const opCheckDataSigVerify = (sha256, secp256k1) => combineOperations(opCheckDataSig(sha256, secp256k1), opVerify());
const bitcoinCashOperations = (sha256, secp256k1, flags) => ({
  [OpcodesBCH.OP_CAT]: opCat(),
  [OpcodesBCH.OP_SPLIT]: opSplit(flags),
  [OpcodesBCH.OP_NUM2BIN]: opNum2Bin(),
  [OpcodesBCH.OP_BIN2NUM]: opBin2Num(),
  [OpcodesBCH.OP_AND]: opAnd(),
  [OpcodesBCH.OP_OR]: opOr(),
  [OpcodesBCH.OP_XOR]: opXor(),
  [OpcodesBCH.OP_DIV]: opDiv(flags),
  [OpcodesBCH.OP_MOD]: opMod(flags),
  [OpcodesBCH.OP_CHECKDATASIG]: opCheckDataSig(sha256, secp256k1),
  [OpcodesBCH.OP_CHECKDATASIGVERIFY]: opCheckDataSigVerify(sha256, secp256k1)
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-instruction-sets.js







const isPayToScriptHash = verificationInstructions => verificationInstructions.length === 3
/* length */
&& verificationInstructions[0].opcode === OpcodesBCH.OP_HASH160 && verificationInstructions[1].opcode === OpcodesBCH.OP_PUSHBYTES_20 && verificationInstructions[2
/* lastElement */
].opcode === OpcodesBCH.OP_EQUAL;
/**
 * Test a stack item for the SegWit Recovery Rules activated in `BCH_2019_05`.
 *
 * @param bytecode the stack item to test
 */
// eslint-disable-next-line complexity

const isWitnessProgram = bytecode => {
  const correctLength = bytecode.length >= 4
  /* minimumLength */
  && bytecode.length <= 42
  /* maximumLength */
  ;
  const validVersionPush = bytecode[0] === 0
  /* OP_0 */
  || bytecode[0] >= 81
  /* OP_1 */
  && bytecode[0] <= 96
  /* OP_16 */
  ;
  const correctLengthByte = bytecode[1] + 2
  /* versionAndLengthBytes */
  === bytecode.length;
  return correctLength && validVersionPush && correctLengthByte;
};
/**
 * From C++ implementation:
 * Note that IsPushOnly() *does* consider OP_RESERVED to be a push-type
 * opcode, however execution of OP_RESERVED fails, so it's not relevant to
 * P2SH/BIP62 as the scriptSig would fail prior to the P2SH special
 * validation code being executed.
 */

const isPushOperation = opcode => opcode < OpcodesBCH.OP_16;
/**
 * This library's supported versions of the BCH virtual machine. "Strict"
 * versions (A.K.A. `isStandard` from the C++ implementations) enable additional
 * validation which is commonly used on the P2P network before relaying
 * transactions. Transactions which fail these rules are often called
 * "non-standard" â the transactions can technically be included by miners in
 * valid blocks, but most network nodes will refuse to relay them.
 */


var InstructionSetBCH;

(function (InstructionSetBCH) {
  InstructionSetBCH["BCH_2019_05"] = "BCH_2019_05";
  InstructionSetBCH["BCH_2019_05_STRICT"] = "BCH_2019_05_STRICT";
  InstructionSetBCH["BCH_2019_11_SPEC"] = "BCH_2019_11";
  InstructionSetBCH["BCH_2019_11_STRICT_SPEC"] = "BCH_2019_11_STRICT";
})(InstructionSetBCH || (InstructionSetBCH = {}));

const instructionSetBCHCurrentStrict = InstructionSetBCH.BCH_2019_05_STRICT;
const getFlagsForInstructionSetBCH = instructionSet => {
  switch (instructionSet) {
    case InstructionSetBCH.BCH_2019_05:
      return {
        disallowUpgradableNops: false,
        requireBugValueZero: false,
        requireMinimalEncoding: false,
        requireNullSignatureFailures: true
      };

    case InstructionSetBCH.BCH_2019_05_STRICT:
      return {
        disallowUpgradableNops: true,
        requireBugValueZero: false,
        requireMinimalEncoding: true,
        requireNullSignatureFailures: true
      };

    case InstructionSetBCH.BCH_2019_11_SPEC:
      return {
        disallowUpgradableNops: false,
        requireBugValueZero: true,
        requireMinimalEncoding: true,
        requireNullSignatureFailures: true
      };

    case InstructionSetBCH.BCH_2019_11_STRICT_SPEC:
      return {
        disallowUpgradableNops: true,
        requireBugValueZero: true,
        requireMinimalEncoding: true,
        requireNullSignatureFailures: true
      };

    default:
      return new Error(`${instructionSet} is not an instruction set.`);
  }
};
/**
 * Initialize a new instruction set for the BCH virtual machine.
 *
 * @param flags an object configuring the flags for this vm (see
 * `getFlagsForInstructionSetBCH`)
 * @param sha1 a Sha1 implementation
 * @param sha256 a Sha256 implementation
 * @param ripemd160 a Ripemd160 implementation
 * @param secp256k1 a Secp256k1 implementation
 */

const createInstructionSetBCH = (flags, sha1, sha256, ripemd160, secp256k1) => ({
  clone: cloneAuthenticationProgramStateCommon,
  continue: state => state.error === undefined && state.ip < state.instructions.length,
  // eslint-disable-next-line complexity
  evaluate: (program, stateEvaluate) => {
    var _p2shStack$pop;

    const {
      unlockingBytecode
    } = program.spendingTransaction.inputs[program.inputIndex];
    const {
      lockingBytecode
    } = program.sourceOutput;
    const unlockingInstructions = parseBytecode(unlockingBytecode);
    const lockingInstructions = parseBytecode(lockingBytecode);
    const externalState = createAuthenticationProgramExternalStateCommon(program);
    const initialState = createAuthenticationProgramStateCommon(unlockingInstructions, [], externalState);
    const unlockingResult = unlockingBytecode.length > ConsensusCommon.maximumBytecodeLength ? applyError(AuthenticationErrorCommon.exceededMaximumBytecodeLengthUnlocking, initialState) : authenticationInstructionsAreMalformed(unlockingInstructions) ? applyError(AuthenticationErrorCommon.malformedUnlockingBytecode, initialState) : lockingBytecode.length > ConsensusCommon.maximumBytecodeLength ? applyError(AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking, initialState) : authenticationInstructionsAreMalformed(lockingInstructions) ? applyError(AuthenticationErrorCommon.malformedLockingBytecode, initialState) : initialState.instructions.every(instruction => isPushOperation(instruction.opcode)) ? stateEvaluate(initialState) : applyError(AuthenticationErrorBCH.requiresPushOnly, initialState);

    if (unlockingResult.error !== undefined) {
      return unlockingResult;
    }

    const lockingResult = stateEvaluate(createAuthenticationProgramStateCommon(lockingInstructions, unlockingResult.stack, externalState));

    if (!isPayToScriptHash(lockingInstructions)) {
      return lockingResult;
    }

    const p2shStack = cloneStack(unlockingResult.stack); // eslint-disable-next-line functional/immutable-data

    const p2shScript = (_p2shStack$pop = p2shStack.pop()) !== null && _p2shStack$pop !== void 0 ? _p2shStack$pop : Uint8Array.of();

    if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
      return lockingResult;
    }

    const p2shInstructions = parseBytecode(p2shScript);
    return authenticationInstructionsAreMalformed(p2shInstructions) ? { ...lockingResult,
      error: AuthenticationErrorBCH.malformedP2shBytecode
    } : stateEvaluate(createAuthenticationProgramStateCommon(p2shInstructions, p2shStack, externalState));
  },
  operations: { ...commonOperations(sha1, sha256, ripemd160, secp256k1, flags),
    ...mapOverOperations(bitcoinCashOperations(sha256, secp256k1, flags), conditionallyEvaluate, incrementOperationCount, checkLimitsCommon)
  },
  ...undefinedOperation(),
  verify: state => state.error === undefined && state.executionStack.length === 0 && state.stack.length === 1 && stackItemIsTruthy(state.stack[0])
});
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch-descriptions.js

var OpcodeDescriptionsUniqueBCH;

(function (OpcodeDescriptionsUniqueBCH) {
  OpcodeDescriptionsUniqueBCH["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsUniqueBCH["OP_SPLIT"] = "Pop the top item from the stack as an index (Script Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsUniqueBCH["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (Script Number) and the next item as a Script Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsUniqueBCH["OP_BIN2NUM"] = "Pop the top item from the stack as a Script Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsUniqueBCH["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsUniqueBCH["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsUniqueBCH["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsUniqueBCH["OP_DIV"] = "Pop the top item from the stack as a denominator (Script Number) and the next as a numerator (Script Number). Divide and push the result to the stack.";
  OpcodeDescriptionsUniqueBCH["OP_MOD"] = "Pop the top item from the stack as a denominator (Script Number) and the next as a numerator (Script Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsUniqueBCH["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a Script Number 1, otherwise push a Script Number 0.";
  OpcodeDescriptionsUniqueBCH["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
})(OpcodeDescriptionsUniqueBCH || (OpcodeDescriptionsUniqueBCH = {}));
/**
 * A map of descriptions for each Bitcoin Cash opcode.
 */


const OpcodeDescriptionsBCH = { ...OpcodeDescriptionsCommon,
  ...OpcodeDescriptionsUniqueBCH
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/fixtures/bitcoin-abc/bitcoin-abc-utils.js




const bitcoinABCOpcodes = Object.entries(generateBytecodeMap(OpcodesBCH)).reduce((acc, cur) => ({ ...acc,
  [cur[0].slice('OP_'.length)]: cur[1]
}), {
  PUSHDATA1: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_1),
  PUSHDATA2: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_2),
  PUSHDATA4: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_4)
});
/**
 * Convert a string from Bitcoin ABC's `script_tests.json` text-format to
 * bytecode. The string must be valid â this method attempts to convert all
 * unmatched tokens to `BigInt`s.
 *
 * @internalRemarks
 * This method doesn't use {@link compileScript} because of a slight
 * incompatibility in the languages. In BTL, BigIntLiterals are a primitive
 * type, and must be surrounded by a push statement (e.g. `<100>`) to push a
 * number to the stack. In the `script_tests.json` text-format, numbers are
 * assumed to be pushed. We could implement a transformation after the
 * compiler's parse step, but because this format doesn't require any other
 * features of the compiler, we opt to implement this as a simple method.
 * @param abcScript the script in Bitcoin ABC's `script_tests.json` text-format
 */

const assembleBitcoinABCScript = abcScript => flattenBinArray(abcScript.split(' ').filter(token => token !== '').map(token => token.startsWith('0x') ? hexToBin(token.slice('0x'.length)) : token.startsWith("'") ? encodeDataPush(utf8ToBin(token.slice(1, token.length - 1))) : bitcoinABCOpcodes[token] === undefined ? encodeDataPush(bigIntToScriptNumber(BigInt(token))) : bitcoinABCOpcodes[token]));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/bch/bch.js










/**
 * Initialize a virtual machine using the provided BCH instruction set.
 *
 * @param instructionSet the VM version to instantiate â by default, the current
 * "strict" VM is used (`instructionSetBCHCurrentStrict`)
 */

const instantiateVirtualMachineBCH = async (instructionSet = instructionSetBCHCurrentStrict) => {
  const [sha1, sha256, ripemd160, secp256k1] = await Promise.all([instantiateSha1(), instantiateSha256(), instantiateRipemd160(), instantiateSecp256k1()]);
  return createAuthenticationVirtualMachine(createInstructionSetBCH(getFlagsForInstructionSetBCH(instructionSet), sha1, sha256, ripemd160, secp256k1));
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/instruction-sets/instruction-sets.js




// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/errors.js
const getResolutionErrors = compiledScript => compiledScript.reduce((errors, segment) => {
  switch (segment.type) {
    case 'error':
      return [...errors, {
        error: segment.value,
        range: segment.range
      }];

    case 'push':
    case 'evaluation':
      return [...errors, ...getResolutionErrors(segment.value)];

    default:
      return errors;
  }
}, []); // export const getReductionErrors = () => {};
// EXTERNAL MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/parsimmon.js
var parsimmon = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/parse.js

/**
 * TODO: `@types/parsimmon` is not in use because of some early hacks. Ideally,
 * this can be cleaned up by converting parsimmon.js to TypeScript, and trimming
 * out the parts we don't need.
 */

/* eslint-disable sort-keys */

const authenticationScriptParser = parsimmon["createLanguage"]({
  script: r => parsimmon["seqMap"](parsimmon["optWhitespace"], r.expression.sepBy(parsimmon["optWhitespace"]).node('Script'), parsimmon["optWhitespace"], (_, expressions) => expressions),
  expression: r => parsimmon["alt"](r.comment, r.push, r.evaluation, r.utf8, r.hex, r.bigint, r.identifier),
  comment: r => parsimmon["alt"](r.singleLineComment, r.multiLineComment).node('Comment'),
  singleLineComment: () => parsimmon["seqMap"](parsimmon["string"]('//').desc("the start of a single-line comment ('//')"), parsimmon["regexp"](/[^\n]*/u), (__, comment) => comment.trim()),
  multiLineComment: () => parsimmon["seqMap"](parsimmon["string"]('/*').desc("the start of a multi-line comment ('/*')"), parsimmon["regexp"](/[\s\S]*(?=\*\/)/u).desc("the end of this multi-line comment ('*/')"), parsimmon["string"]('*/'), (__, comment) => comment.trim()),
  push: r => parsimmon["seqMap"](parsimmon["string"]('<').desc("the start of a push statement ('<')"), r.script, parsimmon["string"]('>').desc("the end of this push statement ('>')"), (_, push) => push).node('Push'),
  evaluation: r => parsimmon["seqMap"](parsimmon["string"]('$').desc("the start of an evaluation ('$')"), parsimmon["string"]('(').desc("the opening parenthesis of this evaluation ('(')"), r.script, parsimmon["string"](')').desc("the closing parenthesis of this evaluation (')')"), (_, __, evaluation) => evaluation).node('Evaluation'),
  identifier: () => parsimmon["regexp"](/[a-zA-Z_][.a-zA-Z0-9_-]*/u).desc('a valid identifier').node('Identifier'),
  utf8: () => parsimmon["alt"](parsimmon["seqMap"](parsimmon["string"]('"').desc('a double quote (")'), parsimmon["regexp"](/[^"]*/u), parsimmon["string"]('"').desc('a closing double quote (")'), (__, literal) => literal), parsimmon["seqMap"](parsimmon["string"]("'").desc("a single quote (')"), parsimmon["regexp"](/[^']*/u), parsimmon["string"]("'").desc("a closing single quote (')"), (__, literal) => literal)).node('UTF8Literal'),
  hex: () => parsimmon["seqMap"](parsimmon["string"]('0x').desc("a hex literal ('0x...')"), parsimmon["regexp"](/(?:[0-9a-f]{2})+/iu).desc('a valid hexadecimal string'), (__, literal) => literal).node('HexLiteral'),
  bigint: () => parsimmon["regexp"](/-?[0-9]+/u).desc('an integer literal').map(BigInt).node('BigIntLiteral')
});
const parseScript = script => authenticationScriptParser.script.parse(script);
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/reduce.js





const pluckStartPosition = range => ({
  startColumn: range.startColumn,
  startLineNumber: range.startLineNumber
});

const pluckEndPosition = range => ({
  endColumn: range.endColumn,
  endLineNumber: range.endLineNumber
});

const mergeRanges = ranges => {
  const unsortedMerged = ranges.reduce( // eslint-disable-next-line complexity
  (merged, range) => ({ ...(range.startLineNumber < merged.startLineNumber ? pluckStartPosition(range) : range.startLineNumber === merged.startLineNumber && range.startColumn < merged.startColumn ? pluckStartPosition(range) : pluckStartPosition(merged)),
    ...(range.endLineNumber > merged.endLineNumber ? pluckEndPosition(range) : range.endLineNumber === merged.endLineNumber && range.endColumn > merged.endColumn ? pluckEndPosition(range) : pluckEndPosition(merged))
  }), ranges[0]);
  return { ...pluckStartPosition(unsortedMerged),
    ...pluckEndPosition(unsortedMerged)
  };
};

const emptyReductionTraceNode = range => ({
  bytecode: Uint8Array.of(),
  range
});
/**
 * Aggregate instructions to build groups of non-malformed instructions.
 *
 * --- TODO: delete old stuff below? ââ-
 *
 * So users can write constructions like `OP_PUSHBYTES_2 0x0102` which will
 * evaluate successfully, but instructions which must read over a new-line to
 * make sense (e.g. `OP_PUSHBYTES_2\n0x0102`) should error. This allows for a
 * nice omniscient-debugging experience.
 *
 * **This makes new lines important in evaluations.** However, things
 * can only "break" when new lines are inserted, not when they are removed (e.g.
 * if a script is "minified" to a single line for deployment.)
 *
 * **Implementation note**
 * This method aggregates arrays of instructions by line... a little like
 * Automatic Semicolon Insertion in ECMAScript. ð In fact, that's a good
 * sign that we're missing a useful language construct here. Maybe instead
 * of this algorithm, we need a new type of wrapper in the language to indicate
 * that bytecode segments are intended to go together.
 *
 * Interestingly, we already use "Containers" in both pushes and evaluations, so
 * this might be quite easy. E.g. wrapping with `()` or `{}`. However, we also
 * want disassembled instructions to be valid input in BTL, so some form of this
 * line-based logic will still be required unless we also change script
 * disassembly form. E.g. instead of `OP_PUSHBYTES_2 0x0102`, something like
 * `(OP_PUSHBYTES_2 0x0102)` or `<0x0102>`. This is something to consider in
 * future versions.
 */
// eslint-disable-next-line complexity


const aggregatedParseReductionTraceNodes = nodes => {
  const aggregations = []; // eslint-disable-next-line functional/no-let

  let ip = 0; // eslint-disable-next-line functional/no-let, init-declarations

  let incomplete; // eslint-disable-next-line functional/no-loop-statement

  for (const node of nodes) {
    const bytecode = incomplete === undefined ? node.bytecode : flattenBinArray([incomplete.bytecode, node.bytecode]);
    const range = incomplete === undefined ? node.range : mergeRanges([incomplete.range, node.range]); // eslint-disable-next-line functional/no-expression-statement

    incomplete = undefined;
    const parsed = parseBytecode(bytecode); // eslint-disable-next-line functional/no-conditional-statement

    if (parsed.length === 0) {
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      aggregations.push({
        instructions: [],
        lastIp: ip,
        range
      }); // eslint-disable-next-line functional/no-conditional-statement
    } else if (authenticationInstructionsAreNotMalformed(parsed)) {
      // eslint-disable-next-line functional/no-expression-statement
      ip += parsed.length; // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

      aggregations.push({
        instructions: parsed,
        lastIp: ip,
        range
      }); // eslint-disable-next-line functional/no-conditional-statement
    } else {
      // eslint-disable-next-line functional/no-expression-statement
      incomplete = {
        bytecode,
        range
      };
    }
  }

  return {
    aggregations,
    success: true,
    ...(incomplete === undefined ? undefined : {
      remainingBytecode: incomplete.bytecode,
      remainingRange: incomplete.range,
      success: false
    })
  };
};
/**
 * Evaluate an array of `InstructionAggregation`s with the provided
 * `AuthenticationVirtualMachine`, matching the results back to their source
 * ranges.
 */


const evaluateInstructionAggregations = (aggregations, // eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
  var _samples, _errorSample$state$er;

  const nonEmptyAggregations = aggregations.filter(aggregation => aggregation.instructions.length > 0);
  const evaluationPlan = nonEmptyAggregations.reduce((plan, aggregation) => {
    const instructions = [...plan.instructions, ...aggregation.instructions];
    return {
      breakpoints: [...plan.breakpoints, {
        ip: aggregation.lastIp,
        range: aggregation.range
      }],
      instructions
    };
  }, {
    breakpoints: [],
    instructions: []
  });
  const trace = vm.stateDebug(getState(evaluationPlan.instructions));
  const samples = evaluationPlan.breakpoints.map(breakpoint => ({
    range: breakpoint.range,
    state: trace[breakpoint.ip - 1]
  }));
  const firstInvalidSample = samples.findIndex(sample => sample.state === undefined);
  const errorSample = (_samples = samples[firstInvalidSample - 1]) !== null && _samples !== void 0 ? _samples : samples[firstInvalidSample];
  return errorSample === undefined ? {
    samples: samples,
    success: true
  } : {
    errors: [{
      error: errorSample.state === undefined ? `Failed to reduce evaluation: vm.debug produced no valid program states.` : `Failed to reduce evaluation: ${(_errorSample$state$er = errorSample.state.error) !== null && _errorSample$state$er !== void 0 ? _errorSample$state$er : 'unknown error'}`,
      range: errorSample.range
    }],
    samples,
    success: false
  };
};
/**
 * Incrementally evaluate an array of `ScriptReductionTraceNode`s, returning a
 * trace of the evaluation and the resulting top stack item (`evaluationResult`)
 * if successful.
 *
 * @param nodes an array of reduced nodes
 * @param vm the `AuthenticationVirtualMachine` to use in the evaluation
 * @param getState a method which should generate a new ProgramState given an
 * array of `instructions`
 */
// eslint-disable-next-line complexity

const sampledEvaluateReductionTraceNodes = (nodes, // eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, getState) => {
  const parsed = aggregatedParseReductionTraceNodes(nodes);
  const evaluated = evaluateInstructionAggregations(parsed.aggregations, vm, getState);

  if (parsed.success && evaluated.success) {
    const samples = evaluated.samples.length > 0 ? evaluated.samples : [{
      range: parsed.aggregations[0].range,
      state: getState([])
    }];
    const lastSample = samples[samples.length - 1];
    const lastStackItem = lastSample.state.stack[lastSample.state.stack.length - 1];
    const evaluationResult = lastStackItem === undefined ? Uint8Array.of() : lastStackItem.slice();
    return {
      bytecode: evaluationResult,
      samples,
      success: true
    };
  }

  return {
    bytecode: Uint8Array.of(),
    errors: [...(parsed.success ? [] : [{
      error: `A sample is malformed and cannot be evaluated: ${disassembleBytecode(OpcodesCommon, parsed.remainingBytecode)}`,
      range: parsed.remainingRange
    }]), ...(evaluated.success ? [] : evaluated.errors)],
    samples: evaluated.samples,
    success: false
  };
};
/**
 * This method will throw an error if provided a `compiledScript` with
 * compilation errors. To check for compilation errors, use `getCompileErrors`.
 * @param compiledScript the `CompiledScript` to reduce
 * @param vm the `AuthenticationVirtualMachine` to use for evaluations
 * @param createState a method which returns the base `ProgramState` used when initializing evaluations
 */

const reduceScript = (compiledScript, // eslint-disable-next-line @typescript-eslint/no-explicit-any
vm, createState) => {
  const source = compiledScript.map(segment => {
    switch (segment.type) {
      case 'bytecode':
        return {
          bytecode: segment.value,
          range: segment.range
        };

      case 'push':
        {
          if (segment.value.length === 0) {
            return emptyReductionTraceNode(segment.range);
          }

          const push = reduceScript(segment.value, vm, createState);
          const bytecode = encodeDataPush(push.bytecode);
          return {
            bytecode,
            ...(push.errors === undefined ? undefined : {
              errors: push.errors
            }),
            range: segment.range,
            source: [push]
          };
        }

      case 'evaluation':
        {
          if (segment.value.length === 0) {
            return emptyReductionTraceNode(segment.range);
          }

          if (typeof vm === 'undefined' || typeof createState === 'undefined') {
            return {
              errors: [{
                error: 'Both a VM and a createState method are required to reduce evaluations.',
                range: segment.range
              }],
              ...emptyReductionTraceNode(segment.range)
            };
          }

          const reductionTrace = reduceScript(segment.value, vm, createState);
          const evaluated = sampledEvaluateReductionTraceNodes(reductionTrace.source, vm, createState);
          const errors = [...(reductionTrace.errors === undefined ? [] : reductionTrace.errors), ...(evaluated.success ? [] : evaluated.errors)];
          return { ...(errors.length > 0 ? {
              errors,
              ...emptyReductionTraceNode(segment.range)
            } : {
              bytecode: evaluated.bytecode,
              range: segment.range
            }),
            samples: evaluated.samples,
            source: [reductionTrace]
          };
        }

      case 'comment':
        return emptyReductionTraceNode(segment.range);

      case 'error':
        return {
          errors: [{
            error: `Tried to reduce a BTL script with resolution errors: ${segment.value}`,
            range: segment.range
          }],
          ...emptyReductionTraceNode(segment.range)
        };

      default:
        return new Error( // eslint-disable-next-line @typescript-eslint/no-explicit-any
        `"${segment.type}" is not a known segment type.`);
    }
  });
  const reduction = source.reduce((all, segment) => ({
    bytecode: [...all.bytecode, segment.bytecode],
    ranges: [...all.ranges, segment.range],
    ...(all.errors !== undefined || segment.errors !== undefined ? {
      errors: [...(all.errors === undefined ? [] : all.errors), ...(segment.errors === undefined ? [] : segment.errors)]
    } : undefined)
  }), {
    bytecode: [],
    ranges: []
  });
  return { ...(reduction.errors === undefined ? undefined : {
      errors: reduction.errors
    }),
    bytecode: flattenBinArray(reduction.bytecode),
    range: mergeRanges(reduction.ranges),
    source
  };
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/resolve.js




const pluckRange = node => ({
  endColumn: node.end.column,
  endLineNumber: node.end.line,
  startColumn: node.start.column,
  startLineNumber: node.start.line
});

var IdentifierResolutionType;

(function (IdentifierResolutionType) {
  IdentifierResolutionType["opcode"] = "opcode";
  IdentifierResolutionType["variable"] = "variable";
  IdentifierResolutionType["script"] = "script";
})(IdentifierResolutionType || (IdentifierResolutionType = {}));

var resolve_Constants;

(function (Constants) {
  Constants[Constants["hexByte"] = 2] = "hexByte";
})(resolve_Constants || (resolve_Constants = {}));

const resolveScriptSegment = (segment, resolveIdentifiers) => {
  // eslint-disable-next-line complexity
  const resolved = segment.value.map(child => {
    const range = pluckRange(child);

    switch (child.name) {
      case 'Identifier':
        {
          const identifier = child.value;
          const result = resolveIdentifiers(identifier);
          const ret = result.status ? {
            range,
            type: 'bytecode',
            value: result.bytecode,
            ...(result.type === IdentifierResolutionType.opcode ? {
              opcode: identifier
            } : result.type === IdentifierResolutionType.variable ? {
              variable: identifier
            } : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            result.type === IdentifierResolutionType.script ? {
              script: identifier,
              source: result.source
            } : {
              unknown: identifier
            })
          } : {
            range,
            type: 'error',
            value: result.error
          };
          return ret;
        }

      case 'Push':
        return {
          range,
          type: 'push',
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };

      case 'Evaluation':
        return {
          range,
          type: 'evaluation',
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };

      case 'BigIntLiteral':
        return {
          literalType: 'BigIntLiteral',
          range,
          type: 'bytecode',
          value: bigIntToScriptNumber(child.value)
        };

      case 'HexLiteral':
        return child.value.length % resolve_Constants.hexByte === 0 ? {
          literalType: 'HexLiteral',
          range,
          type: 'bytecode',
          value: hexToBin(child.value)
        } : {
          range,
          type: 'error',
          value: `Improperly formed HexLiteral. HexLiteral must have a length divisible by 2, but this HexLiteral has a length of ${child.value.length}.`
        };

      case 'UTF8Literal':
        return {
          literalType: 'UTF8Literal',
          range,
          type: 'bytecode',
          value: utf8ToBin(child.value)
        };

      case 'Comment':
        return {
          range,
          type: 'comment',
          value: child.value
        };

      default:
        return {
          range,
          type: 'error',
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value: `Unrecognized segment: ${child.name}`
        };
    }
  });
  return resolved.length === 0 ? [{
    range: pluckRange(segment),
    type: 'comment',
    value: ''
  }] : resolved;
};
var Time;

(function (Time) {
  Time[Time["msPerLocktimeSecond"] = 1000] = "msPerLocktimeSecond";
})(Time || (Time = {}));

const resolve_dateToLockTime = date => bigIntToScriptNumber(BigInt(Math.round(date.getTime() / Time.msPerLocktimeSecond)));

const articleAndVariableType = variableType => `${variableType === 'HDKey' ? 'an' : 'a'} ${variableType}`;

const attemptCompilerOperation = (identifier, operationId, variableType, environment, data) => {
  if (environment.operations !== undefined) {
    const operationsForType = environment.operations[variableType];

    if (operationsForType !== undefined) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const operation = operationsForType[operationId];

      if (operation !== undefined) {
        return operation(identifier, data, environment);
      }
    }
  }

  return `Identifer "${identifier}" refers to ${articleAndVariableType(variableType)} operation "${operationId}" which is not available to this compiler.`;
};

const variableTypeToDataProperty = {
  AddressData: 'addressData',
  HDKey: 'hdKeys',
  Key: 'keys',
  WalletData: 'walletData'
};
const defaultActionByVariableType = {
  AddressData: (identifier, data, variableId) => data.addressData !== undefined && data.addressData[variableId] !== undefined ? data.addressData[variableId] : `Identifier "${identifier}" refers to an AddressData, but no AddressData for "${variableId}" were provided in the compilation data.`,
  HDKey: identifier => `Identifier "${identifier}" refers to an HDKey, but does not specify an operation, e.g. "${identifier}.public_key".`,
  Key: identifier => `Identifier "${identifier}" refers to a Key, but does not specify an operation, e.g. "${identifier}.public_key".`,
  WalletData: (identifier, data, variableId) => data.walletData !== undefined && data.walletData[variableId] !== undefined ? data.walletData[variableId] : `Identifier "${identifier}" refers to a WalletData, but no WalletData for "${variableId}" were provided in the compilation data.`
};

const aOrAnQuotedString = word => `${['a', 'e', 'i', 'o', 'u'].includes(word[0].toLowerCase()) ? 'an' : 'a'} "${word}"`;

var BuiltInVariables;

(function (BuiltInVariables) {
  BuiltInVariables["currentBlockTime"] = "current_block_time";
  BuiltInVariables["currentBlockHeight"] = "current_block_height";
  BuiltInVariables["signingSerialization"] = "signing_serialization";
})(BuiltInVariables || (BuiltInVariables = {}));
/**
 * If the identifer can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 */
// eslint-disable-next-line complexity


const resolveAuthenticationTemplateVariable = (identifier, environment, data) => {
  const splitId = identifier.split('.');
  const variableId = splitId[0]; // eslint-disable-line prefer-destructuring

  const operationId = splitId[1];

  switch (variableId) {
    case BuiltInVariables.currentBlockHeight:
      return data.currentBlockHeight === undefined ? 'Tried to resolve the built-in variable "current_block_height", but the "currentBlockHeight" property was not provided in the compilation data.' : bigIntToScriptNumber(BigInt(data.currentBlockHeight));

    case BuiltInVariables.currentBlockTime:
      return data.currentBlockTime === undefined ? 'Tried to resolve the built-in variable "current_block_time", but the "currentBlockTime" property was not provided in the compilation data.' : resolve_dateToLockTime(data.currentBlockTime);

    case BuiltInVariables.signingSerialization:
      return operationId === undefined ? 'Tried to resolve an operation for the built-in variable "signing_serialization", but no operation was provided. Provide an operation like "signing_serialization.[operation]".' : attemptCompilerOperation(identifier, operationId, 'SigningSerialization', environment, data);

    default:
      {
        var _environment$variable;

        const selected = (_environment$variable = environment.variables) === null || _environment$variable === void 0 ? void 0 : _environment$variable[variableId];

        if (selected === undefined) {
          return false;
        }

        return data[variableTypeToDataProperty[selected.type]] === undefined ? `Identifier "${identifier}" is a ${selected.type}, but the compilation data does not include ${aOrAnQuotedString(variableTypeToDataProperty[selected.type])} property.` : operationId === undefined ? defaultActionByVariableType[selected.type](identifier, data, variableId) : attemptCompilerOperation(identifier, operationId, selected.type, environment, data);
      }
  }
};
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifer can be successfully resolved as a script, the script is
 * compiled and returned as a CompilationResultSuccess. If an error occurs in
 * compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 *
 * @param identifier the identifier of the script to be resolved
 * @param data the provided CompilationData
 * @param environment the provided CompilationEnvironment
 * @param parentIdentifier the identifier of the script which references the
 * script being resolved (for detecting circular dependencies)
 */
// eslint-disable-next-line complexity

const resolveScriptIdentifier = (identifier, data, environment, parentIdentifier) => {
  if (environment.scripts[identifier] === undefined) {
    return false;
  }

  if (parentIdentifier !== undefined && environment.sourceScriptIds !== undefined && environment.sourceScriptIds.includes(parentIdentifier)) {
    return `A circular dependency was encountered. Script "${identifier}" relies on itself to be generated. (Parent scripts: ${environment.sourceScriptIds.join(', ')})`;
  }

  const result = compileScript(identifier, data, { ...environment,
    sourceScriptIds: [...(environment.sourceScriptIds === undefined ? [] : environment.sourceScriptIds), ...(parentIdentifier === undefined ? [] : [parentIdentifier])]
  });
  return result.success ? result : `Compilation error in resolved script, ${identifier}: ${result.errors.map(({
    error,
    range
  }) => `${error} [${range.startLineNumber}, ${range.startColumn}]`).join(', ')}`;
};
/**
 * Return an `IdentifierResolutionFunction` for use in `resolveScriptSegment`.
 *
 * @param scriptId the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 * @param environment a snapshot of the context around `scriptId`. See
 * `CompilationEnvironment` for details.
 * @param data the actual variable values (private keys, shared wallet data,
 * shared address data, etc.) to use in resolving variables.
 */

const createIdentifierResolver = (scriptId, data, environment) => // eslint-disable-next-line complexity
identifier => {
  var _environment$opcodes;

  const opcodeResult = (_environment$opcodes = environment.opcodes) === null || _environment$opcodes === void 0 ? void 0 : _environment$opcodes[identifier];

  if (opcodeResult !== undefined) {
    return {
      bytecode: opcodeResult,
      status: true,
      type: IdentifierResolutionType.opcode
    };
  }

  const variableResult = resolveAuthenticationTemplateVariable(identifier, environment, data);

  if (variableResult !== false) {
    return typeof variableResult === 'string' ? {
      error: variableResult,
      status: false
    } : {
      bytecode: variableResult,
      status: true,
      type: IdentifierResolutionType.variable
    };
  }

  const scriptResult = resolveScriptIdentifier(identifier, data, environment, scriptId);

  if (scriptResult !== false) {
    return typeof scriptResult === 'string' ? {
      error: scriptResult,
      status: false
    } : {
      bytecode: scriptResult.bytecode,
      source: scriptResult.resolve,
      status: true,
      type: IdentifierResolutionType.script
    };
  }

  return {
    error: `Unknown identifier '${identifier}'.`,
    status: false
  };
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/compile.js




var Formatting;

(function (Formatting) {
  Formatting[Formatting["requiresCommas"] = 3] = "requiresCommas";
  Formatting[Formatting["requiresOr"] = 2] = "requiresOr";
})(Formatting || (Formatting = {}));
/**
 * The constant used by the parser to denote the end of the input
 */


const EOF = 'EOF';
/**
 * A text-formatting method to pretty-print the list of expected inputs
 * (`Encountered unexpected input while parsing script. Expected ...`). If
 * present, the `EOF` expectation is always moved to the end of the list.
 * @param expectedArray the alphabetized list of expected inputs produced by
 * `parseScript`
 */

const describeExpectedInput = expectedArray => {
  const newArray = expectedArray.filter(value => value !== EOF); // eslint-disable-next-line functional/no-conditional-statement

  if (newArray.length !== expectedArray.length) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    newArray.push('the end of the script');
  }

  const withoutLastElement = newArray.slice(0, newArray.length - 1);
  const lastElement = newArray[newArray.length - 1];
  return `Encountered unexpected input while parsing script. Expected ${newArray.length >= Formatting.requiresCommas ? withoutLastElement.join(', ').concat(`, or ${lastElement}`) : newArray.length === Formatting.requiresOr ? newArray.join(' or ') : lastElement}.`;
};
/**
 * Note, `compileScript` is the recommended API for using this method.
 */


const compileScriptText = (script, data, environment, scriptId) => {
  const parseResult = parseScript(script);

  if (!parseResult.status) {
    return {
      errorType: 'parse',
      errors: [{
        error: describeExpectedInput(parseResult.expected),
        range: {
          endColumn: parseResult.index.column,
          endLineNumber: parseResult.index.line,
          startColumn: parseResult.index.column,
          startLineNumber: parseResult.index.line
        }
      }],
      success: false
    };
  }

  const resolver = createIdentifierResolver(scriptId, data, environment);
  const resolvedScript = resolveScriptSegment(parseResult.value, resolver);
  const resolutionErrors = getResolutionErrors(resolvedScript);

  if (resolutionErrors.length !== 0) {
    return {
      errorType: 'resolve',
      errors: resolutionErrors,
      parse: parseResult.value,
      resolve: resolvedScript,
      success: false
    };
  }

  const reduction = reduceScript(resolvedScript, environment.vm, environment.createState);
  return { ...(reduction.errors === undefined ? {
      bytecode: reduction.bytecode,
      success: true
    } : {
      errorType: 'reduce',
      errors: reduction.errors,
      success: false
    }),
    parse: parseResult.value,
    reduce: reduction,
    resolve: resolvedScript
  };
};
/**
 * Parse, resolve, and reduce the provided BTL script using the provided`data`
 * and `environment`.
 */

const compileScript = (scriptId, data, environment) => {
  const script = environment.scripts[scriptId];

  if (script === undefined) {
    return {
      errorType: 'parse',
      errors: [{
        error: `No script with an ID of '${scriptId}' was provided in the compilation environment.`,
        range: {
          endColumn: 0,
          endLineNumber: 0,
          startColumn: 0,
          startLineNumber: 0
        }
      }],
      success: false
    };
  }

  return compileScriptText(script, data, environment, scriptId);
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/compiler.js






/* eslint-disable camelcase */

var SigningSerializationAlgorithmIdentifier;

(function (SigningSerializationAlgorithmIdentifier) {
  /**
   * A.K.A. `SIGHASH_ALL`
   */
  SigningSerializationAlgorithmIdentifier["all_outputs"] = "all_outputs";
  /**
   * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
   */

  SigningSerializationAlgorithmIdentifier["all_outputs_single_input"] = "all_outputs_single_input";
  /**
   * A.K.A. `SIGHASH_SINGLE`
   */

  SigningSerializationAlgorithmIdentifier["corresponding_output"] = "corresponding_output";
  /**
   * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
   */

  SigningSerializationAlgorithmIdentifier["corresponding_output_single_input"] = "corresponding_output_single_input";
  /**
   * A.K.A `SIGHASH_NONE`
   */

  SigningSerializationAlgorithmIdentifier["no_outputs"] = "no_outputs";
  /**
   * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
   */

  SigningSerializationAlgorithmIdentifier["no_outputs_single_input"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));

var ScriptGenerationError;

(function (ScriptGenerationError) {
  ScriptGenerationError["missingVm"] = "An evaluation is required, but no VM was provided.";
  ScriptGenerationError["missingSha256"] = "Sha256 is required, but no implementation was provided.";
  ScriptGenerationError["missingSecp256k1"] = "Secp256k1 is required, but no implementation was provided.";
})(ScriptGenerationError || (ScriptGenerationError = {})); // eslint-disable-next-line complexity


const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
  switch (algorithmIdentifier) {
    case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.all_outputs | SigningSerializationFlag.fork_id);

    case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs_single_input}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.all_outputs | SigningSerializationFlag.single_input | SigningSerializationFlag.fork_id);

    case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.corresponding_output | SigningSerializationFlag.fork_id);

    case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output_single_input}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.corresponding_output | SigningSerializationFlag.single_input | SigningSerializationFlag.fork_id);

    case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.no_outputs | SigningSerializationFlag.fork_id);

    case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs_single_input}`:
      return Uint8Array.of( // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.no_outputs | SigningSerializationFlag.single_input | SigningSerializationFlag.fork_id);

    default:
      return undefined;
  }
};

var SignatureIdentifierConstants;

(function (SignatureIdentifierConstants) {
  SignatureIdentifierConstants[SignatureIdentifierConstants["variableIdIndex"] = 0] = "variableIdIndex";
  SignatureIdentifierConstants[SignatureIdentifierConstants["signingTargetIndex"] = 2] = "signingTargetIndex";
  SignatureIdentifierConstants[SignatureIdentifierConstants["expectedSegments"] = 3] = "expectedSegments";
})(SignatureIdentifierConstants || (SignatureIdentifierConstants = {}));

const compilerOperationBCHGenerateSignature = (name, signingAlgorithm // eslint-disable-next-line complexity
) => (identifier, data, environment) => {
  const {
    keys
  } = data;
  const {
    signatures,
    privateKeys
  } = keys;

  if (signatures !== undefined && signatures[identifier] !== undefined) {
    return signatures[identifier];
  }

  const identifierSegments = identifier.split('.');

  if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
    return `Invalid signature identifier. Signatures must be of the form: "[variable_id].${name}.[signing_serialization_type]".`;
  }

  const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
  const algorithm = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
  const signingSerializationType = getSigningSerializationType(algorithm);

  if (signingSerializationType === undefined) {
    return `Unknown signing serialization algorithm, "${algorithm}".`;
  }

  if (privateKeys !== undefined && privateKeys[variableId] !== undefined) {
    const privateKey = privateKeys[variableId];
    const {
      operationData
    } = data;

    if (operationData === undefined) {
      return `Could not construct the signature "${identifier}", signing serialization data was not provided in the compilation data.`;
    }

    const {
      secp256k1
    } = environment;

    if (secp256k1 === undefined) {
      return ScriptGenerationError.missingSecp256k1;
    }

    const {
      sha256
    } = environment;

    if (sha256 === undefined) {
      return ScriptGenerationError.missingSha256;
    }

    const serialization = generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
    const digest = sha256.hash(sha256.hash(serialization));
    const bitcoinEncodedSignature = Uint8Array.from([...signingAlgorithm(secp256k1)(privateKey, digest), ...signingSerializationType]);
    return bitcoinEncodedSignature;
  }

  return `Identifier "${identifier}" refers to a signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
const compilerOperationBCHGenerateDataSignature = (name, signingAlgorithm // eslint-disable-next-line complexity
) => (identifier, data, environment) => {
  const {
    keys
  } = data;
  const {
    signatures,
    privateKeys
  } = keys;

  if (signatures !== undefined && signatures[identifier] !== undefined) {
    return signatures[identifier];
  }

  const identifierSegments = identifier.split('.');

  if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
    return `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${name}.[target_script_id]".`;
  }

  const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
  const scriptId = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
  const signingTarget = environment.scripts[scriptId];
  const compiledTarget = resolveScriptIdentifier(scriptId, data, environment);

  if (signingTarget === undefined || compiledTarget === false) {
    return `Data signature tried to sign an unknown target script, "${scriptId}".`;
  }

  if (typeof compiledTarget === 'string') {
    return compiledTarget;
  }

  if (privateKeys !== undefined && privateKeys[variableId] !== undefined) {
    const privateKey = privateKeys[variableId];
    const {
      secp256k1
    } = environment;

    if (secp256k1 === undefined) {
      return ScriptGenerationError.missingSecp256k1;
    }

    const {
      sha256
    } = environment;

    if (sha256 === undefined) {
      return ScriptGenerationError.missingSha256;
    }

    const digest = sha256.hash(compiledTarget.bytecode);
    return signingAlgorithm(secp256k1)(privateKey, digest);
  }

  return `Identifier "${identifier}" refers to a data signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
var SigningSerializationIdentifierConstants;

(function (SigningSerializationIdentifierConstants) {
  SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["operationIndex"] = 1] = "operationIndex";
  SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["expectedSegments"] = 2] = "expectedSegments";
})(SigningSerializationIdentifierConstants || (SigningSerializationIdentifierConstants = {})); // eslint-disable-next-line complexity


const compilerOperationBCHGenerateSigningSerialization = (identifier, data, environment) => {
  const identifierSegments = identifier.split('.');

  if (identifierSegments.length !== SigningSerializationIdentifierConstants.expectedSegments) {
    return `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version" or "signing_serialization.all_outputs".`;
  }

  const algorithmOrComponent = identifierSegments[SigningSerializationIdentifierConstants.operationIndex];
  const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
  const {
    operationData
  } = data;

  if (operationData === undefined) {
    return `Could not construct the signing serialization "${identifier}", signing serialization data was not provided in the compilation data.`;
  }

  const {
    sha256
  } = environment;

  if (sha256 === undefined) {
    return ScriptGenerationError.missingSha256;
  } // eslint-disable-next-line functional/no-conditional-statement


  if (signingSerializationType === undefined) {
    switch (algorithmOrComponent) {
      case 'corresponding_output':
        return operationData.correspondingOutput === undefined ? Uint8Array.of() : operationData.correspondingOutput;

      case 'corresponding_output_hash':
        return operationData.correspondingOutput === undefined ? Uint8Array.of() : sha256.hash(sha256.hash(operationData.correspondingOutput));

      case 'covered_bytecode_prefix':
        return bigIntToBitcoinVarInt(BigInt(operationData.coveredBytecode.length));

      case 'covered_bytecode':
        return operationData.coveredBytecode;

      case 'locktime':
        return numberToBinUint32LE(operationData.locktime);

      case 'outpoint_index':
        return numberToBinUint32LE(operationData.outpointIndex);

      case 'outpoint_transaction_hash':
        return operationData.outpointTransactionHash;

      case 'output_value':
        return bigIntToBinUint64LE(operationData.outputValue);

      case 'sequence_number':
        return numberToBinUint32LE(operationData.sequenceNumber);

      case 'transaction_outpoints':
        return operationData.transactionOutpoints;

      case 'transaction_outpoints_hash':
        return sha256.hash(sha256.hash(operationData.transactionOutpoints));

      case 'transaction_outputs':
        return operationData.transactionOutputs;

      case 'transaction_outputs_hash':
        return sha256.hash(sha256.hash(operationData.transactionOutputs));

      case 'transaction_sequence_numbers':
        return operationData.transactionSequenceNumbers;

      case 'transaction_sequence_numbers_hash':
        return sha256.hash(sha256.hash(operationData.transactionSequenceNumbers));

      case 'version':
        return numberToBinUint32LE(operationData.version);

      default:
        return `Unknown signing serialization algorithm or component, "${algorithmOrComponent}".`;
    }
  }

  return generateSigningSerializationBCH(sha256, operationData.version, operationData.transactionOutpoints, operationData.transactionSequenceNumbers, operationData.outpointTransactionHash, operationData.outpointIndex, operationData.coveredBytecode, operationData.outputValue, operationData.sequenceNumber, operationData.correspondingOutput, operationData.transactionOutputs, operationData.locktime, signingSerializationType);
};
/* eslint-disable camelcase */

const getCompilerOperationsBCH = () => ({
  Key: {
    data_signature: compilerOperationBCHGenerateDataSignature('data_signature', secp256k1 => secp256k1.signMessageHashDER),
    // eslint-disable-next-line complexity
    public_key: (identifier, data, environment) => {
      const {
        keys
      } = data;
      const {
        publicKeys,
        privateKeys
      } = keys;
      const [variableId] = identifier.split('.');

      if (publicKeys !== undefined && publicKeys[variableId] !== undefined) {
        return publicKeys[variableId];
      }

      if (privateKeys !== undefined && privateKeys[variableId] !== undefined) {
        const {
          secp256k1
        } = environment;
        return secp256k1 === undefined ? ScriptGenerationError.missingSecp256k1 : secp256k1.derivePublicKeyCompressed(privateKeys[variableId]);
      }

      return `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`;
    },
    schnorr_data_signature: compilerOperationBCHGenerateDataSignature('schnorr_data_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
    schnorr_signature: compilerOperationBCHGenerateSignature('schnorr_signature', secp256k1 => secp256k1.signMessageHashSchnorr),
    signature: compilerOperationBCHGenerateSignature('signature', secp256k1 => secp256k1.signMessageHashDER)
  },
  SigningSerialization: {
    corresponding_output: compilerOperationBCHGenerateSigningSerialization,
    corresponding_output_hash: compilerOperationBCHGenerateSigningSerialization,
    covered_bytecode: compilerOperationBCHGenerateSigningSerialization,
    covered_bytecode_prefix: compilerOperationBCHGenerateSigningSerialization,
    full_all_outputs: compilerOperationBCHGenerateSigningSerialization,
    full_all_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
    full_corresponding_output: compilerOperationBCHGenerateSigningSerialization,
    full_corresponding_output_single_input: compilerOperationBCHGenerateSigningSerialization,
    full_no_outputs: compilerOperationBCHGenerateSigningSerialization,
    full_no_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
    locktime: compilerOperationBCHGenerateSigningSerialization,
    outpoint_index: compilerOperationBCHGenerateSigningSerialization,
    outpoint_transaction_hash: compilerOperationBCHGenerateSigningSerialization,
    output_value: compilerOperationBCHGenerateSigningSerialization,
    sequence_number: compilerOperationBCHGenerateSigningSerialization,
    transaction_outpoints: compilerOperationBCHGenerateSigningSerialization,
    transaction_outpoints_hash: compilerOperationBCHGenerateSigningSerialization,
    transaction_outputs: compilerOperationBCHGenerateSigningSerialization,
    transaction_outputs_hash: compilerOperationBCHGenerateSigningSerialization,
    transaction_sequence_numbers: compilerOperationBCHGenerateSigningSerialization,
    transaction_sequence_numbers_hash: compilerOperationBCHGenerateSigningSerialization,
    version: compilerOperationBCHGenerateSigningSerialization
  }
});
/**
 * TODO: describe
 * @param compilationEnvironment the environment from which to create the compiler
 */

const createCompiler = compilationEnvironment => ({
  debug: (script, data) => compileScript(script, data, compilationEnvironment),
  generate: (script, data) => {
    const result = compileScript(script, data, compilationEnvironment);
    return result.success ? {
      bytecode: result.bytecode,
      success: true
    } : {
      errorType: result.errorType,
      errors: result.errors,
      success: false
    };
  }
});
const createStateCompilerBCH = // eslint-disable-next-line @typescript-eslint/no-explicit-any
instructions => createAuthenticationProgramStateCommon(instructions, [], createAuthenticationProgramExternalStateCommonEmpty());
/**
 * TODO: describe
 *
 * @param overrides a compilation environment from which properties will be used
 * to override properties of the default BCH environment
 */

const createCompilerBCH = async overrides => {
  const [sha256, secp256k1, vm] = await Promise.all([instantiateSha256(), instantiateSecp256k1(), instantiateVirtualMachineBCH(instructionSetBCHCurrentStrict)]);
  return createCompiler({ ...{
      createState: createStateCompilerBCH,
      opcodes: generateBytecodeMap(OpcodesBCH),
      operations: getCompilerOperationsBCH(),
      secp256k1,
      sha256,
      vm
    },
    ...overrides
  });
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/language/language.js






// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/templates/templates.js

// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/auth/auth.js



// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/address/bech32.js
/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
const bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore

const bech32CharacterSetIndex = {
  q: 0,
  p: 1,
  z: 2,
  r: 3,
  y: 4,
  '9': 5,
  x: 6,
  '8': 7,
  g: 8,
  f: 9,
  '2': 10,
  t: 11,
  v: 12,
  d: 13,
  w: 14,
  '0': 15,
  s: 16,
  '3': 17,
  j: 18,
  n: 19,
  '5': 20,
  '4': 21,
  k: 22,
  h: 23,
  c: 24,
  e: 25,
  '6': 26,
  m: 27,
  u: 28,
  a: 29,
  '7': 30,
  l: 31
}; // eslint-disable-line sort-keys

var BitRegroupingError;

(function (BitRegroupingError) {
  BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
  BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
  BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
// cSpell:ignore Pieter, Wuille

/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 *
 * @internalRemarks
 * Derived from: https://github.com/sipa/bech32
 * Copyright (c) 2017 Pieter Wuille, MIT License
 */


const regroupBits = (bin, sourceWordLength, resultWordLength, padding = true) => {
  let accumulator = 0;
  let bits = 0;
  const result = [];
  const maxResultInt = (1 << resultWordLength) - 1; // eslint-disable-next-line functional/no-loop-statement, @typescript-eslint/prefer-for-of, no-plusplus

  for (let p = 0; p < bin.length; ++p) {
    const value = bin[p];

    if (value < 0 || value >> sourceWordLength !== 0) {
      return BitRegroupingError.integerOutOfRange;
    }

    accumulator = accumulator << sourceWordLength | value;
    bits += sourceWordLength; // eslint-disable-next-line functional/no-loop-statement

    while (bits >= resultWordLength) {
      bits -= resultWordLength; // eslint-disable-next-line functional/immutable-data

      result.push(accumulator >> bits & maxResultInt);
    }
  }

  if (padding) {
    if (bits > 0) {
      // eslint-disable-next-line functional/immutable-data
      result.push(accumulator << resultWordLength - bits & maxResultInt);
    }
  } else if (bits >= sourceWordLength) {
    return BitRegroupingError.hasDisallowedPadding;
  } else if ((accumulator << resultWordLength - bits & maxResultInt) > 0) {
    return BitRegroupingError.requiresDisallowedPadding;
  }

  return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */

/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`.
 *
 * @param base32IntegerArray the array of 5-bit integers to encode
 */

const encodeBech32 = base32IntegerArray => {
  // eslint-disable-next-line functional/no-let
  let result = ''; // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < base32IntegerArray.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement
    result += bech32CharacterSet[base32IntegerArray[i]];
  }

  return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with `isBech32` before calling this method.
 *
 * @param validBech32 the bech32-encoded string to decode
 */

const decodeBech32 = validBech32 => {
  const result = []; // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < validBech32.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(bech32CharacterSetIndex[validBech32[i]]);
  }

  return result;
};
const nonBech32Characters = new RegExp(`[^${bech32CharacterSet}]`, 'u');
const base32WordLength = 5;
const base256WordLength = 8;
const zero = 0;
/**
 * Validate that a string is bech32 encoded (without a checksum). The string
 * must use only the bech32 character set, and it must be padded correctly, i.e.
 * it must encode a multiple of 8 bits.
 *
 * @param maybeBech32 a string to test for valid Bech32 encoding
 */

const isBech32 = maybeBech32 => {
  const expectedPadding = maybeBech32.length * base32WordLength % base256WordLength;
  const last5Bits = bech32CharacterSetIndex[maybeBech32[maybeBech32.length]];
  const onlyBech32Characters = !nonBech32Characters.test(maybeBech32);
  const noExcessivePadding = expectedPadding < base32WordLength; // eslint-disable-next-line no-bitwise

  const mask = (1 << expectedPadding) - 1; // eslint-disable-next-line no-bitwise

  const expectedPaddingIsZeroFilled = (Number(last5Bits) & mask) === zero;
  return onlyBech32Characters && noExcessivePadding && expectedPaddingIsZeroFilled;
};
var Bech32DecodingError;

(function (Bech32DecodingError) {
  Bech32DecodingError["notBech32Padded"] = "Bech32 decoding error: input is not in Bech32 padded format.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of `binToBech32Padded`.
 *
 * @param bech32Padded the padded bech32-encoded string to decode
 */


const bech32PaddedToBin = bech32Padded => {
  const result = isBech32(bech32Padded) ? regroupBits(decodeBech32(bech32Padded), base32WordLength, base256WordLength, false) : Bech32DecodingError.notBech32Padded;
  return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of `bech32PaddedToBin`.
 *
 * @param bytes the Uint8Array to bech32 encode
 */

const binToBech32Padded = bytes => encodeBech32(regroupBits(bytes, base256WordLength, base32WordLength));
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/address/cash-address.js

var CashAddressNetworkPrefix;

(function (CashAddressNetworkPrefix) {
  CashAddressNetworkPrefix["mainnet"] = "bitcoincash";
  CashAddressNetworkPrefix["testnet"] = "bchtest";
  CashAddressNetworkPrefix["regtest"] = "bchreg";
})(CashAddressNetworkPrefix || (CashAddressNetworkPrefix = {}));

const cashAddressBitToSize = {
  0: 160,
  1: 192,
  2: 224,
  3: 256,
  4: 320,
  5: 384,
  6: 448,
  7: 512
};
const cashAddressSizeToBit = {
  160: 0,
  192: 1,
  224: 2,
  256: 3,
  320: 4,
  384: 5,
  448: 6,
  512: 7
};
/**
 * The CashAddress specification standardizes the format of the version byte:
 * - Most significant bit: reserved, must be `0`
 * - next 4 bits: Address Type
 * - 3 least significant bits: Hash Size
 *
 * Only two Address Type values are currently standardized:
 * - 0 (`0b0000`): P2PKH
 * - 1 (`0b0001`): P2SH
 *
 * While both P2PKH and P2SH addresses always use 160 bit hashes, the
 * CashAddress specification standardizes other sizes for future use (or use by
 * other systems), see `CashAddressSizeBit`.
 *
 * With these constraints, only two version byte values are currently standard.
 */

var CashAddressVersionByte;

(function (CashAddressVersionByte) {
  /**
   * Pay to Public Key Hash (P2PKH): `0b00000000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0000` (P2PKH)
   * - Size bits: `000` (160 bits)
   */
  CashAddressVersionByte[CashAddressVersionByte["P2PKH"] = 0] = "P2PKH";
  /**
   * Pay to Script Hash (P2SH): `0b00001000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0001` (P2SH)
   * - Size bits: `000` (160 bits)
   */

  CashAddressVersionByte[CashAddressVersionByte["P2SH"] = 8] = "P2SH";
})(CashAddressVersionByte || (CashAddressVersionByte = {}));
/**
 * The address types currently defined in the CashAddress specification. See
 * also: `CashAddressVersionByte`.
 */


var CashAddressType;

(function (CashAddressType) {
  /**
   * Pay to Public Key Hash (P2PKH)
   */
  CashAddressType[CashAddressType["P2PKH"] = 0] = "P2PKH";
  /**
   * Pay to Script Hash (P2SH)
   */

  CashAddressType[CashAddressType["P2SH"] = 1] = "P2SH";
})(CashAddressType || (CashAddressType = {}));

const cashAddressTypeBitShift = 3;
/**
 * Encode a CashAddress version byte for the given address type and hash length.
 * See `CashAddressVersionByte` for more information.
 *
 * The `type` parameter must be a number between `0` and `15`, and `bitLength`
 * must be one of the standardized lengths. To use the contents of a variable,
 * cast it to `CashAddressType` or `CashAddressSize` respectively, e.g.:
 * ```ts
 * const type = 3 as CashAddressType;
 * const size = 160 as CashAddressSize;
 * getCashAddressVersionByte(type, size);
 * ```
 * @param type the address type of the hash being encoded
 * @param bitLength the bit length of the hash being encoded
 */

const encodeCashAddressVersionByte = (type, bitLength // eslint-disable-next-line no-bitwise
) => type << cashAddressTypeBitShift | cashAddressSizeToBit[bitLength];
const cashAddressReservedBitMask = 0b10000000;
const cashAddressTypeBits = 0b1111;
const cashAddressSizeBits = 0b111;
const empty = 0;
var CashAddressVersionByteDecodingError;

(function (CashAddressVersionByteDecodingError) {
  CashAddressVersionByteDecodingError["reservedBitSet"] = "Reserved bit is set.";
})(CashAddressVersionByteDecodingError || (CashAddressVersionByteDecodingError = {}));
/**
 * Decode a CashAddress version byte.
 * @param version the version byte to decode
 */


const decodeCashAddressVersionByte = version => // eslint-disable-next-line no-negated-condition, no-bitwise
(version & cashAddressReservedBitMask) !== empty ? CashAddressVersionByteDecodingError.reservedBitSet : {
  bitLength: cashAddressBitToSize[// eslint-disable-next-line no-bitwise
  version & cashAddressSizeBits],
  // eslint-disable-next-line no-bitwise
  type: version >>> cashAddressTypeBitShift & cashAddressTypeBits
};
/**
 * In ASCII, each pair of upper and lower case characters share the same 5 least
 * significant bits.
 */

const asciiCaseInsensitiveBits = 0b11111;
/**
 * Convert a string into an array of 5-bit numbers, representing the
 * characters in a case-insensitive way.
 * @param prefix the prefix to mask
 */

const maskCashAddressPrefix = prefix => {
  const result = []; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < prefix.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
    result.push(prefix.charCodeAt(i) & asciiCaseInsensitiveBits);
  }

  return result;
}; // prettier-ignore

const bech32GeneratorMostSignificantByte = [0x98, 0x79, 0xf3, 0xae, 0x1e]; // eslint-disable-line @typescript-eslint/no-magic-numbers
// prettier-ignore

const bech32GeneratorRemainingBytes = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470]; // eslint-disable-line @typescript-eslint/no-magic-numbers

/**
 * Perform the CashAddress polynomial modulo operation, which is based on the
 * Bech32 polynomial modulo operation, but the returned checksum is 40 bits,
 * rather than 30.
 *
 * A.K.A. `PolyMod`
 *
 * @remarks
 * Notes from Bitcoin ABC:
 * This function will compute what 8 5-bit values to XOR into the last 8 input
 * values, in order to make the checksum 0. These 8 values are packed together
 * in a single 40-bit integer. The higher bits correspond to earlier values.
 *
 * The input is interpreted as a list of coefficients of a polynomial over F
 * = GF(32), with an implicit 1 in front. If the input is [v0,v1,v2,v3,v4],
 * that polynomial is v(x) = 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4.
 * The implicit 1 guarantees that [v0,v1,v2,...] has a distinct checksum
 * from [0,v0,v1,v2,...].
 *
 * The output is a 40-bit integer whose 5-bit groups are the coefficients of
 * the remainder of v(x) mod g(x), where g(x) is the cashaddr generator, x^8
 * + {19}*x^7 + {3}*x^6 + {25}*x^5 + {11}*x^4 + {25}*x^3 + {3}*x^2 + {19}*x
 * + {1}. g(x) is chosen in such a way that the resulting code is a BCH
 * code, guaranteeing detection of up to 4 errors within a window of 1025
 * characters. Among the various possible BCH codes, one was selected to in
 * fact guarantee detection of up to 5 errors within a window of 160
 * characters and 6 errors within a window of 126 characters. In addition,
 * the code guarantee the detection of a burst of up to 8 errors.
 *
 * Note that the coefficients are elements of GF(32), here represented as
 * decimal numbers between {}. In this finite field, addition is just XOR of
 * the corresponding numbers. For example, {27} + {13} = {27 ^ 13} = {22}.
 * Multiplication is more complicated, and requires treating the bits of
 * values themselves as coefficients of a polynomial over a smaller field,
 * GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example,
 * {5} * {26} = (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 +
 * a^3 + a) = a^6 + a^5 + a^4 + a = a^3 + 1 (mod a^5 + a^3 + 1) = {9}.
 *
 * During the course of the loop below, `c` contains the bit-packed
 * coefficients of the polynomial constructed from just the values of v that
 * were processed so far, mod g(x). In the above example, `c` initially
 * corresponds to 1 mod (x), and after processing 2 inputs of v, it
 * corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the
 * starting value for `c`.
 *
 * @internalRemarks
 * Derived from the `bitcore-lib-cash` implementation, which does not require
 * BigInt: https://github.com/bitpay/bitcore
 *
 * @param v Array of 5-bit integers over which the checksum is to be computed
 */

const cashAddressPolynomialModulo = v => {
  /* eslint-disable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
  let mostSignificantByte = 0;
  let lowerBytes = 1;
  let c = 0; // eslint-disable-next-line @typescript-eslint/prefer-for-of, no-plusplus

  for (let j = 0; j < v.length; j++) {
    c = mostSignificantByte >>> 3;
    mostSignificantByte &= 0x07;
    mostSignificantByte <<= 5;
    mostSignificantByte |= lowerBytes >>> 27;
    lowerBytes &= 0x07ffffff;
    lowerBytes <<= 5;
    lowerBytes ^= v[j]; // eslint-disable-next-line no-plusplus

    for (let i = 0; i < bech32GeneratorMostSignificantByte.length; ++i) {
      // eslint-disable-next-line functional/no-conditional-statement, @typescript-eslint/strict-boolean-expressions
      if (c & 1 << i) {
        mostSignificantByte ^= bech32GeneratorMostSignificantByte[i];
        lowerBytes ^= bech32GeneratorRemainingBytes[i];
      }
    }
  }

  lowerBytes ^= 1; // eslint-disable-next-line functional/no-conditional-statement

  if (lowerBytes < 0) {
    lowerBytes ^= 1 << 31;
    lowerBytes += (1 << 30) * 2;
  }

  return mostSignificantByte * (1 << 30) * 4 + lowerBytes;
  /* eslint-enable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
};
const cash_address_base32WordLength = 5;
const cash_address_base256WordLength = 8;
/**
 * Convert the checksum returned by `cashAddressPolynomialModulo` to an array of
 * 5-bit positive integers which can be Base32 encoded.
 * @param checksum a 40 bit checksum returned by `cashAddressPolynomialModulo`
 */

const cashAddressChecksumToUint5Array = checksum => {
  const result = []; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let i = 0; i < cash_address_base256WordLength; ++i) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers, functional/immutable-data
    result.push(checksum & 31); // eslint-disable-next-line functional/no-expression-statement, @typescript-eslint/no-magic-numbers, no-param-reassign

    checksum /= 32;
  } // eslint-disable-next-line functional/immutable-data


  return result.reverse();
};
const payloadSeparator = 0;
/**
 * Encode a hash as a CashAddress-like string using the CashAddress format.
 *
 * To encode a standard CashAddress, use `encodeCashAddress`.
 *
 * @param prefix a valid prefix indicating the network for which to encode the
 * address â must be only lowercase letters
 * @param version a single byte indicating the version of this address
 * @param hash the hash to encode
 */

const encodeCashAddressFormat = (prefix, version, hash) => {
  const checksum40BitPlaceholder = [0, 0, 0, 0, 0, 0, 0, 0];
  const payloadContents = regroupBits(Uint8Array.from([version, ...hash]), cash_address_base256WordLength, cash_address_base32WordLength);
  const checksumContents = [...maskCashAddressPrefix(prefix), payloadSeparator, ...payloadContents, ...checksum40BitPlaceholder];
  const checksum = cashAddressPolynomialModulo(checksumContents);
  const payload = [...payloadContents, ...cashAddressChecksumToUint5Array(checksum)];
  return `${prefix}:${encodeBech32(payload)}`;
};
var CashAddressEncodingError;

(function (CashAddressEncodingError) {
  CashAddressEncodingError["unsupportedHashLength"] = "CashAddress encoding error: a hash of this length can not be encoded as a valid CashAddress.";
})(CashAddressEncodingError || (CashAddressEncodingError = {}));

const isValidBitLength = bitLength => cashAddressSizeToBit[bitLength] !== undefined;
/**
 * Encode a hash as a CashAddress.
 *
 * For other address standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `encodeCashAddressFormat`.
 *
 * @param prefix a valid prefix indicating the network for which to encode the
 * address (usually a `CashAddressNetworkPrefix`) â must be only lowercase
 * letters
 * @param type the `CashAddressType` to encode in the version byte â usually a
 * `CashAddressType`
 * @param hash the hash to encode (for P2PKH, the public key hash; for P2SH, the
 * redeeming bytecode hash)
 */


const encodeCashAddress = (prefix, type, hash) => {
  const bitLength = hash.length * cash_address_base256WordLength;

  if (!isValidBitLength(bitLength)) {
    return CashAddressEncodingError.unsupportedHashLength;
  }

  return encodeCashAddressFormat(prefix, encodeCashAddressVersionByte(type, bitLength), hash);
};
var CashAddressDecodingError;

(function (CashAddressDecodingError) {
  CashAddressDecodingError["invalidFormat"] = "CashAddress decoding error: CashAddresses should be of the form \"prefix:payload\".";
  CashAddressDecodingError["malformedPayload"] = "CashAddress decoding error: the payload is not properly encoded.";
  CashAddressDecodingError["invalidChecksum"] = "CashAddress decoding error: please review the address for errors.";
  CashAddressDecodingError["reservedByte"] = "CashAddress decoding error: unknown CashAddress version, reserved byte set.";
  CashAddressDecodingError["mismatchedHashLength"] = "CashAddress decoding error: mismatched hash length for specified address version.";
})(CashAddressDecodingError || (CashAddressDecodingError = {}));
/**
 * Decode and validate a string using the CashAddress format. This is more
 * lenient than `decodeCashAddress`, which also validates the contents of the
 * version byte.
 *
 * Note, this method requires `address` to include a network prefix. To
 * decode a string with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address the CashAddress-like string to decode
 */
// eslint-disable-next-line complexity


const decodeCashAddressFormat = address => {
  const parts = address.toLowerCase().split(':'); // eslint-disable-next-line @typescript-eslint/no-magic-numbers

  if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
    return CashAddressDecodingError.invalidFormat;
  }

  const [prefix, payload] = parts;

  if (!isBech32(payload)) {
    return CashAddressDecodingError.malformedPayload;
  }

  const decodedPayload = decodeBech32(payload);
  const polynomial = [...maskCashAddressPrefix(prefix), payloadSeparator, ...decodedPayload];

  if (cashAddressPolynomialModulo(polynomial) !== 0) {
    return CashAddressDecodingError.invalidChecksum;
  }

  const checksum40BitPlaceholderLength = 8;
  const payloadContents = regroupBits(decodedPayload.slice(0, -checksum40BitPlaceholderLength), cash_address_base32WordLength, cash_address_base256WordLength, false);

  if (typeof payloadContents === 'string') {
    return payloadContents;
  }

  const [version, ...hashContents] = payloadContents;
  const hash = Uint8Array.from(hashContents);
  return {
    hash,
    prefix,
    version
  };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * For other address-like standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `decodeCashAddressFormat`.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address the CashAddress to decode
 */

const decodeCashAddress = address => {
  const decoded = decodeCashAddressFormat(address);

  if (typeof decoded === 'string') {
    return decoded;
  }

  const info = decodeCashAddressVersionByte(decoded.version);

  if (info === CashAddressVersionByteDecodingError.reservedBitSet) {
    return CashAddressDecodingError.reservedByte;
  }

  if (decoded.hash.length * cash_address_base256WordLength !== info.bitLength) {
    return CashAddressDecodingError.mismatchedHashLength;
  }

  return {
    hash: decoded.hash,
    prefix: decoded.prefix,
    type: info.type
  };
};
/**
 * Attempt to decode and validate a CashAddress against a list of possible
 * prefixes. If the correct prefix is known, use `decodeCashAddress`.
 *
 * @param address the CashAddress to decode
 * @param possiblePrefixes the network prefixes to try
 */
// decodeCashAddressWithoutPrefix

const decodeCashAddressFormatWithoutPrefix = (address, possiblePrefixes = [CashAddressNetworkPrefix.mainnet, CashAddressNetworkPrefix.testnet, CashAddressNetworkPrefix.regtest]) => {
  // eslint-disable-next-line functional/no-loop-statement
  for (const prefix of possiblePrefixes) {
    const attempt = decodeCashAddressFormat(`${prefix}:${address}`);

    if (attempt !== CashAddressDecodingError.invalidChecksum) {
      return attempt;
    }
  }

  return CashAddressDecodingError.invalidChecksum;
};
const asciiLowerCaseStart = 96;
/**
 * Convert a CashAddress polynomial to CashAddress string format.
 *
 * @internalRemarks
 * CashAddress polynomials take the form:
 *
 * `[lowest 5 bits of each prefix character] 0 [payload + checksum]`
 *
 * This method remaps the 5-bit integers in the prefix location to the matching
 * ASCII lowercase characters, replaces the separator with `:`, and then Bech32
 * encodes the remaining payload and checksum.
 *
 * @param polynomial an array of 5-bit integers representing the terms of a
 * CashAddress polynomial
 */

const cashAddressPolynomialToCashAddress = polynomial => {
  const separatorPosition = polynomial.indexOf(0);
  const prefix = polynomial.slice(0, separatorPosition).map(integer => String.fromCharCode(asciiLowerCaseStart + integer)).join('');
  const contents = encodeBech32(polynomial.slice(separatorPosition + 1));
  return `${prefix}:${contents}`;
};
var CashAddressCorrectionError;

(function (CashAddressCorrectionError) {
  CashAddressCorrectionError["tooManyErrors"] = "This address has more than 2 errors and cannot be corrected.";
})(CashAddressCorrectionError || (CashAddressCorrectionError = {}));

const finiteFieldOrder = 32;
/**
 * Attempt to correct up to 2 errors in a CashAddress. The CashAddress must be
 * properly formed (include a prefix and only contain Bech32 characters).
 *
 * ## **Improper use of this method carries the risk of lost funds.**
 *
 * It is strongly advised that this method only be used under explicit user
 * control. With enough errors, this method is likely to find a plausible
 * correction for any address (but for which no private key exists). This is
 * effectively equivalent to burning the funds.
 *
 * Only 2 substitution errors can be corrected (or a single swap) â deletions
 * and insertions (errors which shift many other characters and change the
 * length of the payload) can never be safely corrected and will produce an
 * error.
 *
 * Errors can be corrected in both the prefix and the payload, but attempting to
 * correct errors in the prefix prior to this method can improve results, e.g.
 * for `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x`, the string
 * `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can be corrected, while
 * `typo:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can not.
 *
 * @internalRemarks
 * Derived from: https://github.com/deadalnix/cashaddressed
 *
 * @param address the CashAddress on which to attempt error correction
 */
// eslint-disable-next-line complexity

const attemptCashAddressFormatErrorCorrection = address => {
  const parts = address.toLowerCase().split(':'); // eslint-disable-next-line @typescript-eslint/no-magic-numbers

  if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
    return CashAddressDecodingError.invalidFormat;
  }

  const [prefix, payload] = parts;

  if (!isBech32(payload)) {
    return CashAddressDecodingError.malformedPayload;
  }

  const decodedPayload = decodeBech32(payload);
  const polynomial = [...maskCashAddressPrefix(prefix), 0, ...decodedPayload];
  const originalChecksum = cashAddressPolynomialModulo(polynomial);

  if (originalChecksum === 0) {
    return {
      address: cashAddressPolynomialToCashAddress(polynomial),
      corrections: []
    };
  }

  const syndromes = {}; // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus

  for (let term = 0; term < polynomial.length; term++) {
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let errorVector = 1; errorVector < finiteFieldOrder; errorVector++) {
      // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
      polynomial[term] ^= errorVector;
      const correct = cashAddressPolynomialModulo(polynomial);

      if (correct === 0) {
        return {
          address: cashAddressPolynomialToCashAddress(polynomial),
          corrections: [term]
        };
      } // eslint-disable-next-line no-bitwise


      const s0 = (BigInt(correct) ^ BigInt(originalChecksum)).toString(); // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data

      syndromes[s0] = term * finiteFieldOrder + errorVector; // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data

      polynomial[term] ^= errorVector;
    }
  } // eslint-disable-next-line functional/no-loop-statement


  for (const [s0, pe] of Object.entries(syndromes)) {
    // eslint-disable-next-line no-bitwise
    const s1Location = (BigInt(s0) ^ BigInt(originalChecksum)).toString();
    const s1 = syndromes[s1Location];

    if (s1 !== undefined) {
      const correctionIndex1 = Math.trunc(pe / finiteFieldOrder);
      const correctionIndex2 = Math.trunc(s1 / finiteFieldOrder); // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data

      polynomial[correctionIndex1] ^= pe % finiteFieldOrder; // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data

      polynomial[correctionIndex2] ^= s1 % finiteFieldOrder;
      return {
        address: cashAddressPolynomialToCashAddress(polynomial),
        corrections: [correctionIndex1, correctionIndex2].sort((a, b) => a - b)
      };
    }
  }

  return CashAddressCorrectionError.tooManyErrors;
};
// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/address/address.js


// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/lib/lib.js






// CONCATENATED MODULE: ./node_modules/bitcoin-ts/build/module/index.js


/***/ })
/******/ ]);
});